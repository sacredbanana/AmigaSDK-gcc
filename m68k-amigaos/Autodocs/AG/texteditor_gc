@database "texteditor_gc"
@master "AMIDEV:NDK/Autodocs/texteditor_gc.doc"

@Node Main "texteditor_gc.doc"
@toc "Autodocs/AG/INDEX/Main"
    @{" --background-- " Link "--background--"}
    @{" GA_TEXTEDITOR_AreaMarked() " Link "GA_TEXTEDITOR_AreaMarked()"}
    @{" GA_TEXTEDITOR_ColorMap() " Link "GA_TEXTEDITOR_ColorMap()"}
    @{" GA_TEXTEDITOR_Contents() " Link "GA_TEXTEDITOR_Contents()"}
    @{" GA_TEXTEDITOR_CursorX() " Link "GA_TEXTEDITOR_CursorX()"}
    @{" GA_TEXTEDITOR_CursorY() " Link "GA_TEXTEDITOR_CursorY()"}
    @{" GA_TEXTEDITOR_DoubleClickHook() " Link "GA_TEXTEDITOR_DoubleClickHook()"}
    @{" GA_TEXTEDITOR_ExportHook() " Link "GA_TEXTEDITOR_ExportHook()"}
    @{" GA_TEXTEDITOR_ExportWrap() " Link "GA_TEXTEDITOR_ExportWrap()"}
    @{" GA_TEXTEDITOR_FixedFont() " Link "GA_TEXTEDITOR_FixedFont()"}
    @{" GA_TEXTEDITOR_Flow() " Link "GA_TEXTEDITOR_Flow()"}
    @{" GA_TEXTEDITOR_HasChanged() " Link "GA_TEXTEDITOR_HasChanged()"}
    @{" GA_TEXTEDITOR_HighlighterHook() " Link "GA_TEXTEDITOR_HighlighterHook()"}
    @{" GA_TEXTEDITOR_ImportHook() " Link "GA_TEXTEDITOR_ImportHook()"}
    @{" GA_TEXTEDITOR_ImportWrap() " Link "GA_TEXTEDITOR_ImportWrap()"}
    @{" GA_TEXTEDITOR_IndentWidth() " Link "GA_TEXTEDITOR_IndentWidth()"}
    @{" GA_TEXTEDITOR_InsertMode() " Link "GA_TEXTEDITOR_InsertMode()"}
    @{" GA_TEXTEDITOR_LeftBarHook() " Link "GA_TEXTEDITOR_LeftBarHook()"}
    @{" GA_TEXTEDITOR_LineEndingExport() " Link "GA_TEXTEDITOR_LineEndingExport()"}
    @{" GA_TEXTEDITOR_LineEndingImported() " Link "GA_TEXTEDITOR_LineEndingImported()"}
    @{" GA_TEXTEDITOR_Pen() " Link "GA_TEXTEDITOR_Pen()"}
    @{" GA_TEXTEDITOR_Prop_DeltaFactor() " Link "GA_TEXTEDITOR_Prop_DeltaFactor()"}
    @{" GA_TEXTEDITOR_Prop_Entries() " Link "GA_TEXTEDITOR_Prop_Entries()"}
    @{" GA_TEXTEDITOR_Prop_First() " Link "GA_TEXTEDITOR_Prop_First()"}
    @{" GA_TEXTEDITOR_Prop_Visible() " Link "GA_TEXTEDITOR_Prop_Visible()"}
    @{" GA_TEXTEDITOR_Quiet() " Link "GA_TEXTEDITOR_Quiet()"}
    @{" GA_TEXTEDITOR_ReadOnly() " Link "GA_TEXTEDITOR_ReadOnly()"}
    @{" GA_TEXTEDITOR_RectangularSelections() " Link "GA_TEXTEDITOR_RectangularSelections()"}
    @{" GA_TEXTEDITOR_RedoAvailable() " Link "GA_TEXTEDITOR_RedoAvailable()"}
    @{" GA_TEXTEDITOR_Separator() " Link "GA_TEXTEDITOR_Separator()"}
    @{" GA_TEXTEDITOR_ShowLineNumbers() " Link "GA_TEXTEDITOR_ShowLineNumbers()"}
    @{" GA_TEXTEDITOR_SpacesPerTAB() " Link "GA_TEXTEDITOR_SpacesPerTAB()"}
    @{" GA_TEXTEDITOR_StyleBold() " Link "GA_TEXTEDITOR_StyleBold()"}
    @{" GA_TEXTEDITOR_StyleItalic() " Link "GA_TEXTEDITOR_StyleItalic()"}
    @{" GA_TEXTEDITOR_StyleUnderline() " Link "GA_TEXTEDITOR_StyleUnderline()"}
    @{" GA_TEXTEDITOR_TabKeyPolicy() " Link "GA_TEXTEDITOR_TabKeyPolicy()"}
    @{" GA_TEXTEDITOR_TypeAndSpell() " Link "GA_TEXTEDITOR_TypeAndSpell()"}
    @{" GA_TEXTEDITOR_UndoAvailable() " Link "GA_TEXTEDITOR_UndoAvailable()"}
    @{" GA_TEXTEDITOR_WrapBorder() " Link "GA_TEXTEDITOR_WrapBorder()"}
    @{" GM_TEXTEDITOR_ARexxCmd() " Link "GM_TEXTEDITOR_ARexxCmd()"}
    @{" GM_TEXTEDITOR_ClearText() " Link "GM_TEXTEDITOR_ClearText()"}
    @{" GM_TEXTEDITOR_ExportBlock() " Link "GM_TEXTEDITOR_ExportBlock()"}
    @{" GM_TEXTEDITOR_ExportText() " Link "GM_TEXTEDITOR_ExportText()"}
    @{" GM_TEXTEDITOR_HandleError() " Link "GM_TEXTEDITOR_HandleError()"}
    @{" GM_TEXTEDITOR_InsertText() " Link "GM_TEXTEDITOR_InsertText()"}
    @{" GM_TEXTEDITOR_MacroBegin() " Link "GM_TEXTEDITOR_MacroBegin()"}
    @{" GM_TEXTEDITOR_MacroEnd() " Link "GM_TEXTEDITOR_MacroEnd()"}
    @{" GM_TEXTEDITOR_MacroExecute() " Link "GM_TEXTEDITOR_MacroExecute()"}
    @{" GM_TEXTEDITOR_MarkText() " Link "GM_TEXTEDITOR_MarkText()"}
    @{" GM_TEXTEDITOR_Search() " Link "GM_TEXTEDITOR_Search()"}
    @{" OM_TEXTEDITOR_Replace() " Link "OM_TEXTEDITOR_Replace()"}
@EndNode

@Node "--background--" "texteditor_gc/--background--"

 texteditor.gadget is a fast multiline stringgadget. It can hold quite large
 texts without noticeable slowdowns. It supports the clipboard, it can show
 text with different styles, alignments and colors. It can hold separators,
 it has multilevel undo/redo and it can easily be configured to use an
 external spell checker for type 'n' spell and word guessing.

@EndNode

@Node "GA_TEXTEDITOR_AreaMarked()" "texteditor_gc/GA_TEXTEDITOR_AreaMarked"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_AreaMarked -- [..G], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag will be set to TRUE when text is marked. And back to
        FALSE when nothing is marked.
        You can create a notifyevent with this tag and let your cut/copy
        buttons become ghosted when nothing is marked.

@EndNode

@Node "GA_TEXTEDITOR_ColorMap()" "texteditor_gc/GA_TEXTEDITOR_ColorMap"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ColorMap -- [IS.], @{"LONG" Link "INCLUDE:exec/types.h/Main" 112} *

@{b}    FUNCTION@{ub}
        This is a map of allocated colors, which corresponds to the pen
        number you set with @{"GA_TEXTEDITOR_Pen" Link "texteditor_gc/GA_TEXTEDITOR_Pen()"}.
        By default the map looks like this:

           0 = Normal (user configured text/highlight color)
           1 = Shine
           2 = Halfshine
           3 = Background
           4 = Halfshadow
           5 = Shadow
           6 = @{"Text" Link "graphics/Text()"}
           7 = Fill
           8 = Mark
           9 = @{"Screen" Link "INCLUDE:intuition/screens.h/Main" 139} pen 0
          10 = @{"Screen" Link "INCLUDE:intuition/screens.h/Main" 139} pen 1
          11 = @{"Screen" Link "INCLUDE:intuition/screens.h/Main" 139} pen 3
          .. = ...
         255 = @{"Screen" Link "INCLUDE:intuition/screens.h/Main" 139} pen 246

        If you supply your own colormap, then pen value 0 will still be
        "Normal", i.e. the first entry in your colormap has pen value 1.
        This may seem a bit illogical, suggest an alternative if you want!

        You are allowed to dynamically change the colormap. However if you
        change an entry which is on-screen, then it won't have any immediate
        effect. The idea is that you should e.g. supply a colormap with 16
        unused LONGs, allow the user to select a custom color, allocate that
        color and store the screen pen value into the colormap. Now you can
        use that entry as argument to @{"GA_TEXTEDITOR_Pen" Link "texteditor_gc/GA_TEXTEDITOR_Pen()"}.

        Have in mind that your application may change screen, so the best
        place to allocate/free colors is when you show and hide the
        texteditor.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_Pen" Link "texteditor_gc/GA_TEXTEDITOR_Pen()"}

@EndNode

@Node "GA_TEXTEDITOR_Contents()" "texteditor_gc/GA_TEXTEDITOR_Contents"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Contents -- [IS.], @{"APTR" Link "INCLUDE:exec/types.h/Main" 75}

@{b}    FUNCTION@{ub}
        Set the contents of this gadget. This should normally be a pointer to
        a text buffer, but if you have supplied your own importhook, then you
        can set this to anything you like, e.g. a filehandle.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ImportHook" Link "texteditor_gc/GA_TEXTEDITOR_ImportHook()"}, @{"GM_TEXTEDITOR_InsertText" Link "texteditor_gc/GM_TEXTEDITOR_InsertText()"}

@EndNode

@Node "GA_TEXTEDITOR_CursorX()" "texteditor_gc/GA_TEXTEDITOR_CursorX"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_CursorX -- [ISG], ULONG

@{b}    FUNCTION@{ub}
        You can get or set the cursor's x position with this tag.
        The first character on a paragraph has position 0.
        The position is not affected by the gadgets `autowrap' feature.
        If you set a value higher than the length of the current paragraph, t
hen
        it will automatically be truncated.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_CursorY" Link "texteditor_gc/GA_TEXTEDITOR_CursorY()"}

@EndNode

@Node "GA_TEXTEDITOR_CursorY()" "texteditor_gc/GA_TEXTEDITOR_CursorY"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_CursorY -- [ISG], ULONG

@{b}    FUNCTION@{ub}
        You can get or set the cursor's y position with this tag.
        The first paragraph has position 0.
        The position is not affected by the gadgets `autowrap' feature.
        If you set a value higher than the number of paragraphs, then it will
        automatically be truncated.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_CursorX" Link "texteditor_gc/GA_TEXTEDITOR_CursorX()"}

@EndNode

@Node "GA_TEXTEDITOR_DoubleClickHook()" "texteditor_gc/GA_TEXTEDITOR_DoubleClickHookr_gc/GA_TEXTEDITOR_DoubleClickHook"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_DoubleClickHook -- [IS.], struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *

@{b}    FUNCTION@{ub}
        If you use the gadget in ReadOnly mode then you may want a special
        action to take place when the user doubleclick certain words.
        For example a mail or news client, using this gadget to show mails,
        may want the user to be able to click on URL's to lookup the link.

        The hook will be called with A1 pointing to a @{"ClickMessage" Link "INCLUDE:gadgets/texteditor.h/Main" 205}, and A0
        will point to the hook itself.
        Your hook should return TRUE if it wants to stop the editor from
        blocking.

@{b}    EXAMPLE@{ub}
        // This hook will test if the user doubleclicked an http address

        @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168} URLHookCode (register __a1 struct @{"ClickMessage" Link "INCLUDE:gadgets/texteditor.h/Main" 205} *clickmsg)
        {
           @{"UWORD" Link "INCLUDE:exec/types.h/Main" 116} pos = clickmsg->ClickPosition;

           while(pos && *(clickmsg->LineContents+pos-1) != ' ' &&
           *(clickmsg->LineContents+pos-1) != '<')
           {
              pos--;
           }

           if(strncmp(clickmsg->LineContents+pos, "http:", 5))
           {
              return(FALSE);
           }
           LookupURL(clickmsg->LineContents+pos);
           return(TRUE);
        }

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ReadOnly" Link "texteditor_gc/GA_TEXTEDITOR_ReadOnly()"}, mui/TextEditor_mcc.h

@EndNode

@Node "GA_TEXTEDITOR_ExportHook()" "texteditor_gc/GA_TEXTEDITOR_ExportHook"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ExportHook -- [IS.], struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *

@{b}    SPECIAL INPUTS@{ub}
        GV_TEXTEDITOR_ExportHook_EMail
        GV_TEXTEDITOR_ExportHook_Plain (default)

@{b}    FUNCTION@{ub}
        The EMail export hook will convert a bold word to *bold*, italic
        words to /italic/ and underlined words to _underline_.
        It also export separators such as <sb> or <tsb>.

        See @{"GA_TEXTEDITOR_ImportHook" Link "texteditor_gc/GA_TEXTEDITOR_ImportHook()"} for more documentation.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ExportWrap" Link "texteditor_gc/GA_TEXTEDITOR_ExportWrap()"}, @{"GA_TEXTEDITOR_ImportHook" Link "texteditor_gc/GA_TEXTEDITOR_ImportHook()"}
        @{"GM_TEXTEDITOR_ExportText" Link "texteditor_gc/GM_TEXTEDITOR_ExportText()"}

@EndNode

@Node "GA_TEXTEDITOR_ExportWrap()" "texteditor_gc/GA_TEXTEDITOR_ExportWrap"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ExportWrap -- [ISG], ULONG

@{b}    FUNCTION@{ub}
        This attribute allows the builtin export hooks to perform wordwrap.
        Zero means no wrap (default).

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ExportHook" Link "texteditor_gc/GA_TEXTEDITOR_ExportHook()"}, @{"GA_TEXTEDITOR_WrapBorder" Link "texteditor_gc/GA_TEXTEDITOR_WrapBorder()"}

@EndNode

@Node "GA_TEXTEDITOR_FixedFont()" "texteditor_gc/GA_TEXTEDITOR_FixedFont"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_FixedFont -- [I.G], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        Use this to set a fixed font.

@EndNode

@Node "GA_TEXTEDITOR_Flow()" "texteditor_gc/GA_TEXTEDITOR_Flow"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Flow -- [.SG], @{"UWORD" Link "INCLUDE:exec/types.h/Main" 116}

@{b}    SPECIAL INPUTS@{ub}
        GV_TEXTEDITOR_Flow_Left
        GV_TEXTEDITOR_Flow_Right
        GV_TEXTEDITOR_Flow_Center
        GV_TEXTEDITOR_Flow_Justified (not yet implemented)

@{b}    FUNCTION@{ub}
        Set/get the current paragraphs alignment.
        If an area is marked while you set this attribute, then the new
        alignment will be set for the complete area.

@EndNode

@Node "GA_TEXTEDITOR_HasChanged()" "texteditor_gc/GA_TEXTEDITOR_HasChanged"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_HasChanged -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag will show if the contents of the gadget has changed.
        You can take notify on this tag, so that you can connect it with a
        checkmark or textobject.
        You should set this tag to FALSE whenever you export the contents of
        the gadget (in the sense of saving).

        The tag is not affected by:
         GM_TEXTEDITOR_Export (as you may only be copying and not saving)


@EndNode

@Node "GA_TEXTEDITOR_HighlighterHook()" "texteditor_gc/GA_TEXTEDITOR_HighlighterHookr_gc/GA_TEXTEDITOR_HighlighterHook"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_HighlighterHook -- [ISG], struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *

@{b}    FUNCTION@{ub}
        The supplied hook will be called for every line in the document
        both after load and when the user edits the document

        When calling the hook the object is a value that needs to be passed
        back in when calling HightLightSetFormat(), HighlightSetState()



@EndNode

@Node "GA_TEXTEDITOR_ImportHook()" "texteditor_gc/GA_TEXTEDITOR_ImportHook"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ImportHook -- [IS.], struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *

@{b}    SPECIAL INPUTS@{ub}
        GV_TEXTEDITOR_ImportHook_EMail
        GV_TEXTEDITOR_ImportHook_MIME
        GV_TEXTEDITOR_ImportHook_MIMEQuoted
        GV_TEXTEDITOR_ImportHook_Plain (default)

@{b}    FUNCTION@{ub}
        Since this gadget allows different text styles, you can supply an
        importhook to parse the text correctly.

        The default importhook understands the following escape sequences:

         <ESC> + u      Set the soft style to underline.
         <ESC> + b      Set the soft style to bold.
         <ESC> + i      Set the soft style to italic.
         <ESC> + n      Set the soft style back to normal.
         <ESC> + h      Highlight the current line.
         <ESC> + p[x]   Change to color x, where x is taken from the
                        colormap. 0 means normal. The color is reset for each
                        new line.

        The following sequences are only valid at the beginning of a line.

         <ESC> + l      Left justify current and following lines.
         <ESC> + r      Right justify current and following lines.
         <ESC> + c      Center current and following lines.
         <ESC> + [s:x]  Create a separator. x is a bit combination of flags:
                         Placement (mutually exclusive):
                           1 = Top
                           2 = Middle
                           4 = Bottom
                         Cosmetical:
                           8 = StrikeThru   - @{"Draw" Link "graphics/Draw()"} separator ontop of text.
                          16 = Thick        - Make separator extra thick.


          GV_TEXTEDITOR_ImportHook_MIME:

        This builtin hook will convert quoted-printables (e.g. "=E5") to the
        ASCII representation, and merge lines ending with a "=", it will
        wordwrap the text (using the value set with
        GA_TEXTEDITOR_ImportWrap), it will highlight all lines which start
        with ">" it will make real *bold*, /italic/, _underline_ and
        #colored#, and it will replace <sb> or <tsb> with a real separator
        bar. It stops parsing when it reaches a @{"NULL" Link "rexxsupport/NULL"} byte.

        The color used for #colored# text is colormap entry 6, which defaults
        to MPEN_FILL. To override it, just supply a colormap with entry 6 set
        to whatever color you would like.


          GV_TEXTEDITOR_ImportHook_MIMEQuoted:

        Like the MIME importhook, but each line gets quoted and highlighted.


          GV_TEXTEDITOR_ImportHook_EMail:

        Like the MIME importhook, but it doesn't convert quoted printables.


        You can of course create your own importhook, there is an external
        file which describes the procedure.

@{b}    NOTE@{ub}
        Don't use custom hooks yet.
        Although the above hooks import style correctly, the style informatio
n
        will be garbaged it the user edits the text.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ColorMap" Link "texteditor_gc/GA_TEXTEDITOR_ColorMap()"}, @{"GA_TEXTEDITOR_ExportHook" Link "texteditor_gc/GA_TEXTEDITOR_ExportHook()"}
        @{"GA_TEXTEDITOR_ImportWrap" Link "texteditor_gc/GA_TEXTEDITOR_ImportWrap()"}

@EndNode

@Node "GA_TEXTEDITOR_ImportWrap()" "texteditor_gc/GA_TEXTEDITOR_ImportWrap"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ImportWrap -- [ISG], ULONG

@{b}    FUNCTION@{ub}
        This is here to allow the builtin import hooks to perform wordwrap.
        The builtin hooks accepts a value between 4 and 1024. Defaults to
        1023.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ImportHook" Link "texteditor_gc/GA_TEXTEDITOR_ImportHook()"}, @{"GA_TEXTEDITOR_WrapBorder" Link "texteditor_gc/GA_TEXTEDITOR_WrapBorder()"}

@EndNode

@Node "GA_TEXTEDITOR_IndentWidth()" "texteditor_gc/GA_TEXTEDITOR_IndentWidthexteditor_gc/GA_TEXTEDITOR_IndentWidth"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_IndentWidth -- [IS], ULONG

@{b}    FUNCTION@{ub}
        When changing indentation this is the number of spaces each level is.
        A value of 0 wil use tab characters to indent

@EndNode

@Node "GA_TEXTEDITOR_InsertMode()" "texteditor_gc/GA_TEXTEDITOR_InsertMode"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_InsertMode -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        Not yet implemented...

@EndNode

@Node "GA_TEXTEDITOR_LeftBarHook()" "texteditor_gc/GA_TEXTEDITOR_LeftBarHookexteditor_gc/GA_TEXTEDITOR_LeftBarHook"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_LeftBarHook -- [IS], struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *

@{b}    FUNCTION@{ub}
        When set You will get a left sidebar where the hook will be asked to
        render.
        The supplied hook will be called for every line in the document
        when rendering the document

        It should not draw line numbers. Use @{"GA_TEXTEDITOR_ShowLineNumbers" Link "texteditor_gc/GA_TEXTEDITOR_ShowLineNumbers()"}
        to get line numbers. You can have both linenumbers and a hook.
        Different messages must be handled correctly.
        Unless otherwise specified you should return @{"NULL" Link "rexxsupport/NULL"} for all.

        It will be called with struct @{"LeftBarRenderMessage" Link "INCLUDE:gadgets/texteditor.h/Main" 228} for each line
        The object in the call is for now @{"NULL" Link "rexxsupport/NULL"}
        The implementation can paint using the @{"RastPort" Link "INCLUDE:graphics/rastport.h/Main" 52} which for now isn't c
lipped
        but will be in the future so keep your painting within.
        Font is set and position points to topleft of area.
        You have 20 pixels x TxHeight to render within.

        It will be called with struct LeftBarInputMessage if the user clicks
in
        the area. It is called on the input.device context so be careful.
        Returning TRUE to this message will cause a repaint.


@EndNode

@Node "GA_TEXTEDITOR_LineEndingExport()" "texteditor_gc/GA_TEXTEDITOR_LineEndingExportgc/GA_TEXTEDITOR_LineEndingExport"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_LineEndingExport -- [SG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        Instruct the texteditor to export in this format

        LINEENDING_LF     Amiga/unix/OSX
        LINEENDING_CR     MacOS pre OSX
        LINEENDING_CRLF   Dos and Windows
        LINEENDING_ASIMPORT  Same as was imported (see GA_TEXTEDITOR_LineEndi
ngImported)

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_LineEndingImported" Link "texteditor_gc/GA_TEXTEDITOR_LineEndingImported()"}

@EndNode

@Node "GA_TEXTEDITOR_LineEndingImportedA_TEXTEDITOR_LineEndingImported()" "texteditor_gc/GA_TEXTEDITOR_LineEndingImportedA_TEXTEDITOR_LineEndingImported"

@{b}    NAME@{ub}
        @{"GA_TEXTEDITOR_LineEndingImported" Link "texteditor_gc/GA_TEXTEDITOR_LineEndingImported()"} -- [G], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        Tells what lineendings the latest import had

        LINEENDING_LF     Amiga/unix/OSX
        LINEENDING_CR     MacOS pre OSX
        LINEENDING_CRLF   Dos and Windows

@EndNode

@Node "GA_TEXTEDITOR_Pen()" "texteditor_gc/GA_TEXTEDITOR_Pen"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Pen -- [.SG], @{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} (do you need @{"UWORD" Link "INCLUDE:exec/types.h/Main" 116} or ULONG?)

@{b}    FUNCTION@{ub}
        The value of this tag reflects the current render pen.

        Not yet implemented...

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ColorMap" Link "texteditor_gc/GA_TEXTEDITOR_ColorMap()"}

@EndNode

@Node "GA_TEXTEDITOR_Prop_DeltaFactor()" "texteditor_gc/GA_TEXTEDITOR_Prop_DeltaFactorgc/GA_TEXTEDITOR_Prop_DeltaFactor"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Prop_DeltaFactor -- [..G], ULONG (OBSOLETE)


@{b}    FUNCTION@{ub}
        This tag can tell you how high a line is. This is useful when you set
        the increment value of a slider, as @{"GA_TEXTEDITOR_Prop_Entries" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Entries()"} holds
        the lines in pixels.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_Prop_Visible" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Visible()"}
        @{"GA_TEXTEDITOR_Prop_First" Link "texteditor_gc/GA_TEXTEDITOR_Prop_First()"}, @{"GA_TEXTEDITOR_Prop_Entries" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Entries()"}

@EndNode

@Node "GA_TEXTEDITOR_Prop_Entries()" "texteditor_gc/GA_TEXTEDITOR_Prop_Entriesteditor_gc/GA_TEXTEDITOR_Prop_Entries"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Prop_Entries -- [..G], ULONG


@{b}    FUNCTION@{ub}
        This value is the total number of lines in the editor.
        If you want a slider attached to the gadget you should create a
        notify on this attribute.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_Prop_Visible" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Visible()"}
        @{"GA_TEXTEDITOR_Prop_First" Link "texteditor_gc/GA_TEXTEDITOR_Prop_First()"}, @{"GA_TEXTEDITOR_Prop_DeltaFactor" Link "texteditor_gc/GA_TEXTEDITOR_Prop_DeltaFactor()"}

@EndNode

@Node "GA_TEXTEDITOR_Prop_First()" "texteditor_gc/GA_TEXTEDITOR_Prop_First"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Prop_First -- [.SG], ULONG

@{b}    FUNCTION@{ub}
        Get or set the first displayed line.
        The purpose of this attribute is to allow connection between the
        editorgadget and a scrollbar.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_Prop_Visible" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Visible()"}
        @{"GA_TEXTEDITOR_Prop_Entries" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Entries()"}, @{"GA_TEXTEDITOR_Prop_DeltaFactor" Link "texteditor_gc/GA_TEXTEDITOR_Prop_DeltaFactor()"}

@EndNode

@Node "GA_TEXTEDITOR_Prop_Visible()" "texteditor_gc/GA_TEXTEDITOR_Prop_Visibleteditor_gc/GA_TEXTEDITOR_Prop_Visible"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Prop_Visible -- [..G], ULONG

@{b}    FUNCTION@{ub}
        This value is the number of lines that currently fits in the window.
        If you want a slider attached to the gadget you should create a
        notify on this attribute.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_Prop_Entries" Link "texteditor_gc/GA_TEXTEDITOR_Prop_Entries()"}
        @{"GA_TEXTEDITOR_Prop_First" Link "texteditor_gc/GA_TEXTEDITOR_Prop_First()"}, @{"GA_TEXTEDITOR_Prop_DeltaFactor" Link "texteditor_gc/GA_TEXTEDITOR_Prop_DeltaFactor()"}

@EndNode

@Node "GA_TEXTEDITOR_Quiet()" "texteditor_gc/GA_TEXTEDITOR_Quiet"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Quiet -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        If you need to insert a lot of text "line by line" you should
        set this tag to TRUE before starting, and then back to FALSE when you
        are done adding text.

@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_InsertText" Link "texteditor_gc/GM_TEXTEDITOR_InsertText()"}

@EndNode

@Node "GA_TEXTEDITOR_ReadOnly()" "texteditor_gc/GA_TEXTEDITOR_ReadOnly"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ReadOnly -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag is not supported in the ReAction version. Use GA_ReadOnly
        instead.

        In ReadOnly-mode there will be:
        No cursor (but a normal TAB-frame).
        TAB will activate the next gadget (instead of alt TAB).
        The frame will be set to a ReadListFrame. (may change).
        There is no ARexx support, except "Copy".

        The GA_TEXTEDITOR_StyleXXX tags are still useable.

@EndNode

@Node "GA_TEXTEDITOR_RectangularSelectionsEDITOR_RectangularSelections()" "texteditor_gc/GA_TEXTEDITOR_RectangularSelectionsEDITOR_RectangularSelections"

@{b}    NAME@{ub}
        @{"GA_TEXTEDITOR_RectangularSelections" Link "texteditor_gc/GA_TEXTEDITOR_RectangularSelections()"} -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        When set the editor has rectangular selections

@EndNode

@Node "GA_TEXTEDITOR_RedoAvailable()" "texteditor_gc/GA_TEXTEDITOR_RedoAvailableditor_gc/GA_TEXTEDITOR_RedoAvailable"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_RedoAvailable -- [..G], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag is set to TRUE when the user is able to redo his action(s)
        (normally after an undo).
        You can create a notify on this tag and let your redo button be
        ghosted when there is nothing to redo.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_UndoAvailable" Link "texteditor_gc/GA_TEXTEDITOR_UndoAvailable()"}

@EndNode

@Node "GA_TEXTEDITOR_Separator()" "texteditor_gc/GA_TEXTEDITOR_Separator"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_Separator -- [.SG], @{"UWORD" Link "INCLUDE:exec/types.h/Main" 116} *

@{b}    FUNCTION@{ub}
        Each line can act as a separator.

        A separator can be either thick or thin. It can be rendered over the
        lines contents, or only on both sides of the contents. The placement
        can be either top, middle or bottom.

        This tag reflects the current line. See @{"gadgets/texteditor.h" Link "INCLUDE:gadgets/texteditor.h/Main" 0} for
        definitions.

@EndNode

@Node "GA_TEXTEDITOR_ShowLineNumbers()" "texteditor_gc/GA_TEXTEDITOR_ShowLineNumbersr_gc/GA_TEXTEDITOR_ShowLineNumbers"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_ShowLineNumbers -- [ISG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        If TRUE you will get a a left sidebar where linenumbers is shown

@EndNode

@Node "GA_TEXTEDITOR_SpacesPerTAB()" "texteditor_gc/GA_TEXTEDITOR_SpacesPerTABteditor_gc/GA_TEXTEDITOR_SpacesPerTAB"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_SpacesPerTAB -- [IS], ULONG

@{b}    FUNCTION@{ub}
        A tab corresponds to this many spaces.

@EndNode

@Node "GA_TEXTEDITOR_StyleBold()" "texteditor_gc/GA_TEXTEDITOR_StyleBold"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_StyleBold -- [.SG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag shows whether the cursor or selection is over bolded text or
        not. You can set this tag to TRUE or FALSE if you want the style
        changed.

        Not yet implemented...

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_StyleItalic" Link "texteditor_gc/GA_TEXTEDITOR_StyleItalic()"}, @{"GA_TEXTEDITOR_StyleUnderline" Link "texteditor_gc/GA_TEXTEDITOR_StyleUnderline()"}

@EndNode

@Node "GA_TEXTEDITOR_StyleItalic()" "texteditor_gc/GA_TEXTEDITOR_StyleItalicexteditor_gc/GA_TEXTEDITOR_StyleItalic"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_StyleItalic -- [.SG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag shows whether the cursor or selection is over text in italic
s or
        not.
        You can set this tag to TRUE or FALSE if you want the style changed.

@{b}    EXAMPLE@{ub}
        see @{"GA_TEXTEDITOR_StyleBold" Link "texteditor_gc/GA_TEXTEDITOR_StyleBold()"}

        Not yet implemented...

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_StyleBold" Link "texteditor_gc/GA_TEXTEDITOR_StyleBold()"}, @{"GA_TEXTEDITOR_StyleUnderline" Link "texteditor_gc/GA_TEXTEDITOR_StyleUnderline()"}

@EndNode

@Node "GA_TEXTEDITOR_StyleUnderline()" "texteditor_gc/GA_TEXTEDITOR_StyleUnderlinetor_gc/GA_TEXTEDITOR_StyleUnderline"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_StyleUnderline -- [.SG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag shows whether the cursor or selection is over underlined tex
t or
        not.
        You can set this tag to TRUE or FALSE if you want the style changed.

        Not yet implemented...

@{b}    EXAMPLE@{ub}
        see @{"GA_TEXTEDITOR_StyleBold" Link "texteditor_gc/GA_TEXTEDITOR_StyleBold()"}

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_StyleBold" Link "texteditor_gc/GA_TEXTEDITOR_StyleBold()"}, @{"GA_TEXTEDITOR_StyleItalic" Link "texteditor_gc/GA_TEXTEDITOR_StyleItalic()"}

@EndNode

@Node "GA_TEXTEDITOR_TabKeyPolicy()" "texteditor_gc/GA_TEXTEDITOR_TabKeyPolicyteditor_gc/GA_TEXTEDITOR_TabKeyPolicy"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_TabKeyPolicy -- [IS], ULONG

@{b}    FUNCTION@{ub}
        When pressing the tab key and the cursor is past the leading whitespa
ce
        of the block then one of these things can happen:

        GV_TEXTEDITOR_TabKey_IndentsLine      The line is indented
        GV_TEXTEDITOR_TabKey_IndentsAfter    Indents text after the cursor

@EndNode

@Node "GA_TEXTEDITOR_TypeAndSpell()" "texteditor_gc/GA_TEXTEDITOR_TypeAndSpellteditor_gc/GA_TEXTEDITOR_TypeAndSpell"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_TypeAndSpell -- [.SG], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168} (NOT in V47)

@{b}    FUNCTION@{ub}
        This is a shortcut to the Type'n'spell switch that the user can set
        in the .mcp module.
        Never integrate this into the settings of your preferences.

@EndNode

@Node "GA_TEXTEDITOR_UndoAvailable()" "texteditor_gc/GA_TEXTEDITOR_UndoAvailableditor_gc/GA_TEXTEDITOR_UndoAvailable"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_UndoAvailable -- [..G], @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168}

@{b}    FUNCTION@{ub}
        This tag is set to TRUE when the user is able to undo his action(s)
        You can create a notify on this tag and let your undo button be
        ghosted when there is nothing to undo.

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_RedoAvailable" Link "texteditor_gc/GA_TEXTEDITOR_RedoAvailable()"}

@EndNode

@Node "GA_TEXTEDITOR_WrapBorder()" "texteditor_gc/GA_TEXTEDITOR_WrapBorder"

@{b}    NAME@{ub}
        GA_TEXTEDITOR_WrapBorder -- [ISG], ULONG

@{b}    FUNCTION@{ub}
        The gadget will insert a linebreak infront of the current word, if
        the cursor comes beyond the column given here.

        Please remember that the gadget can do nondesctructive dynamic wordwr
ap
        which is much better! This tag is for special cases!!!

@{b}    SEE ALSO@{ub}
        @{"GA_TEXTEDITOR_ExportWrap" Link "texteditor_gc/GA_TEXTEDITOR_ExportWrap()"}, @{"GA_TEXTEDITOR_ImportWrap" Link "texteditor_gc/GA_TEXTEDITOR_ImportWrap()"}

@EndNode

@Node "GM_TEXTEDITOR_ARexxCmd()" "texteditor_gc/GM_TEXTEDITOR_ARexxCmd"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_ARexxCmd

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_ARexxCmd, @{"NULL" Link "rexxsupport/NULL"}, @{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137}
            command);

@{b}    FUNCTION@{ub}
        If the user spends much of his time in the TextEditor gadget, then he
        may want to have the gadgets functions integrated in the programs
        arexx command set.
        This can easily be done with this method, simply call it with the
        command that the user has executed. If the method returns something
        else than FALSE, then the command has been used by the gadget. If it
        does return FALSE, then you should parse the command yourself.

        This method can also be used by you, to communicate with the gadget.

        The following commands are currently supported:

           CLEAR
           CUT
           COPY
           PASTE
           ERASE
           GOTOLINE       Template: /N/A
           GOTOCOLUMN     Template: /N/A
           CURSOR         Template: Up/S,Down/S,Left/S,Right/S
           LINE           Template: /N/A
           COLUMN         Template: /N/A
           @{"NEXT" Link "rexxsupport/NEXT"}           Template: Word/S,Sentence/S,Paragraph/S,Page/S
           PREVIOUS       Template: Word/S,Sentence/S,Paragraph/S,Page/S
           POSITION       Template: SOF/S,EOF/S,SOL/S,EOL/S,SOW/S,EOW/S,
                                    SOV/S,EOV/S
           SETBOOKMARK    Template: OFF/S,TOGGLE/S,/N  but /N is legacy and i
s ignored
           GOTOBOOKMARK   Template: PREVIOUS/S,NEXT/S,/N
           LISTBOOKMARKS
           CLEARBOOKMARKS
           @{"TEXT" Link "INCLUDE:exec/types.h/Main" 156}           Template: /F
           UNDO
           REDO
           GETLINE
           GETCURSOR      Template: Line/S,Column/S
           MARK           Template: On/S,Off/S
           @{"DELETE" Link "rexxsupport/DELETE"}
           BACKSPACE
           GETSELECTEDTEXT
	        BEGINMULTICHANGE
	        ENDMULTICHANGE
	        APICURSOR      Template: On/S,Off/S

@{b}    RESULT@{ub}
        The method will return FALSE if it couldn't use the command.
        It will return TRUE if it did use the command, but the command didn't
        give a result. It will return a pointer (STRPTR) when the command
        gives a result, you should return this pointer to the user
        (CreateArgString() it, and set it as the result, in the REXX
        message), you must free the result yourself with @{"FreeVec()" Link "exec/FreeVec()"}.

@EndNode

@Node "GM_TEXTEDITOR_ClearText()" "texteditor_gc/GM_TEXTEDITOR_ClearText"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_ClearText

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_ClearText, NULL);

@{b}    FUNCTION@{ub}
        This will clear all text in the gadget.

@EndNode

@Node "GM_TEXTEDITOR_ExportBlock()" "texteditor_gc/GM_TEXTEDITOR_ExportBlockexteditor_gc/GM_TEXTEDITOR_ExportBlock"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_ExportBlock

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_ExportBlock, NULL);

@{b}    FUNCTION@{ub}
        Not yet implemented...

@{b}    RESULT@{ub}


@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_InsertText" Link "texteditor_gc/GM_TEXTEDITOR_InsertText()"}, @{"GM_TEXTEDITOR_ExportText" Link "texteditor_gc/GM_TEXTEDITOR_ExportText()"}

@EndNode

@Node "GM_TEXTEDITOR_ExportText()" "texteditor_gc/GM_TEXTEDITOR_ExportText"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_ExportText

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_ExportText, NULL);

@{b}    FUNCTION@{ub}
        This will export the text using the current exporthook.

@{b}    RESULT@{ub}
        This depends on the exporthook. The builtin hooks will return a
        pointer to a null terminated buffer containing all the text. You must
        free this buffer with @{"FreeVec()" Link "exec/FreeVec()"} when you are done using it.

@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_InsertText" Link "texteditor_gc/GM_TEXTEDITOR_InsertText()"}, @{"GM_TEXTEDITOR_ExportBlock" Link "texteditor_gc/GM_TEXTEDITOR_ExportBlock()"}

@EndNode

@Node "GM_TEXTEDITOR_HandleError()" "texteditor_gc/GM_TEXTEDITOR_HandleErrorexteditor_gc/GM_TEXTEDITOR_HandleError"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_HandleError

@{b}    SYNOPSIS@{ub}
        DoMethod(obj, win, req, GM_TEXTEDITOR_HandleError, ULONG errorcode);

@{b}    FUNCTION@{ub}
        This method is not supported by the editorgadget itself. The idea is
        that you should subclass the gadget and implement your own error
        handler. The handler should just bring up a requester or write the
        error in a status line.

        The different errors are:

        Error_ClipboardIsEmpty:        The clipboard doesn't hold any data.
        Error_ClipboardIsNotFTXT:      The clipboard doesn't hold any text.
        Error_MacroBufferIsFull:       Not yet used.
        Error_MemoryAllocationFailed:  Not yet used.
        Error_NoAreaMarked:            The user has tried to copy or cut, but
                                       hasn't marked anything.
        Error_NoMacroDefined:          Not yet used.
        Error_NothingToRedo:           There is nothing more to redo.
        Error_NothingToUndo:           There is nothing more to undo.
        Error_NotEnoughUndoMem:        The user has erased something that is
                                       too big to be saved. This results in a
                                       lost undobuffer.
        Error_StringNotFound:          Not yet used.

@{b}    RESULT@{ub}
        NONE

@EndNode

@Node "GM_TEXTEDITOR_InsertText()" "texteditor_gc/GM_TEXTEDITOR_InsertText"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_InsertText

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_InsertText, @{"NULL" Link "rexxsupport/NULL"}, @{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137}
            text, @{"LONG" Link "INCLUDE:exec/types.h/Main" 112} pos);

@{b}    FUNCTION@{ub}
        This will insert the given text using the current importhook.
        The position of the inserted text can be:

          GV_TEXTEDITOR_InsertText_Cursor
          GV_TEXTEDITOR_InsertText_Top
          GV_TEXTEDITOR_InsertText_Bottom

@{b}    RESULT@{ub}
        NONE

@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_ExportText" Link "texteditor_gc/GM_TEXTEDITOR_ExportText()"}

@EndNode

@Node "GM_TEXTEDITOR_MacroBegin()" "texteditor_gc/GM_TEXTEDITOR_MacroBegin"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_MacroBegin

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_MacroBegin, NULL);

@{b}    FUNCTION@{ub}
        Not yet implemented...

@{b}    RESULT@{ub}


@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_MacroEnd" Link "texteditor_gc/GM_TEXTEDITOR_MacroEnd()"}, @{"GM_TEXTEDITOR_MacroExecute" Link "texteditor_gc/GM_TEXTEDITOR_MacroExecute()"}

@EndNode

@Node "GM_TEXTEDITOR_MacroEnd()" "texteditor_gc/GM_TEXTEDITOR_MacroEnd"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_MacroEnd

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_MacroEnd, NULL);

@{b}    FUNCTION@{ub}
        Not yet implemented...

@{b}    RESULT@{ub}


@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_MacroBegin" Link "texteditor_gc/GM_TEXTEDITOR_MacroBegin()"}, @{"GM_TEXTEDITOR_MacroExecute" Link "texteditor_gc/GM_TEXTEDITOR_MacroExecute()"}

@EndNode

@Node "GM_TEXTEDITOR_MacroExecute()" "texteditor_gc/GM_TEXTEDITOR_MacroExecuteteditor_gc/GM_TEXTEDITOR_MacroExecute"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_MacroExecute

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_MacroExecute, NULL);

@{b}    FUNCTION@{ub}
        Not yet implemented...

@{b}    RESULT@{ub}


@{b}    SEE ALSO@{ub}
        @{"GM_TEXTEDITOR_MacroBegin" Link "texteditor_gc/GM_TEXTEDITOR_MacroBegin()"}, @{"GM_TEXTEDITOR_MacroEnd" Link "texteditor_gc/GM_TEXTEDITOR_MacroEnd()"}

@EndNode

@Node "GM_TEXTEDITOR_MarkText()" "texteditor_gc/GM_TEXTEDITOR_MarkText"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_MarkText

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_MarkText, @{"NULL" Link "rexxsupport/NULL"}, ULONG
            start_x, ULONG start_y, ULONG stop_x, ULONG stop_y);

@{b}    FUNCTION@{ub}
        This method will mark the given area.

@{b}    RESULT@{ub}
        Not defined.

@EndNode

@Node "GM_TEXTEDITOR_Search()" "texteditor_gc/GM_TEXTEDITOR_Search"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_Search

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_Search, @{"NULL" Link "rexxsupport/NULL"}, @{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137}
            string, ULONG flags);

@{b}    FUNCTION@{ub}
        Searches the text for the given string. The string mustn't exceed 120
        characters.

        These flags describe the type of search. Only specify one:

         GF_TEXTEDITOR_Search_FromTop
          Normally the search starts at the cursor position - this flag will
          make it start at the beginning of the text.

         GF_TEXTEDITOR_Search_Backwards
          Search backwards from the current cursor position

         GF_TEXTEDITOR_Search_Next
          Search forward from the current cursor position

         GF_TEXTEDITOR_Highlight_All (V. 47)
          Not a search in traditional sense as the cursor isn't moved. Instea
d
          all matches in the document is highlighed. It returns the number of
 hits.
          The highlights remains active and is kept updated when the text is
changed.
          Search for "" to turn it off again.

         GF_TEXTEDITOR_Search_Incremental (V. 47)
          Also a forward search, but it remembers where it started so if you
make
          repeated searches it will start again form the initial position.
          This makes it possible to implement incremental search, where the s
earch is
          done as the user types in the search word, but the user can then al
so change
          any mis-spellings in the search word, and the search will then work
 as expected.
          If you change the cursor position in any other way that will become
 the
          new starting position for the incremental search.

        These flags modify how the search is done. You can specify more than
one:

         GF_TEXTEDITOR_Search_CaseSensitive
          Makes the search to be case sensitive.

         GF_TEXTEDITOR_Search_WholeWord (V. 47)
          If you want to make sure that the word you searchfor is not part of
 a larger word.
          That is, it has to be delimited by characters not alphanumeric or u
nderscore

         GF_TEXTEDITOR_Search_Cyclic (V. 47)
          For Backwards and Next with this flag set, the search will continue
 from the
          other end of the document.

@{b}    RESULT@{ub}
        TRUE if the string was found, otherwise FALSE.
        For Highlight_All the return value is also the number of hits.

@{b}    NOTE@{ub}
        If the string was found then it's left marked. So in case you want to
        replace it, simply call @{"OM_TEXTEDITOR_Replace" Link "texteditor_gc/OM_TEXTEDITOR_Replace()"}.

@{b}    SEE ALSO@{ub}
        @{"OM_TEXTEDITOR_Replace" Link "texteditor_gc/OM_TEXTEDITOR_Replace()"}
@EndNode

@Node "OM_TEXTEDITOR_Replace()" "texteditor_gc/OM_TEXTEDITOR_Replace"

@{b}    NAME@{ub}
        GM_TEXTEDITOR_Replace

@{b}    SYNOPSIS@{ub}
        DoGadgetMethod(obj, win, req, GM_TEXTEDITOR_Replace, @{"NULL" Link "rexxsupport/NULL"}, @{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137}
            newstring, ULONG flags);

@{b}    FUNCTION@{ub}
        This method replace the marked area with the string given.
        Currently no flags are defined, so pass 0L for now.

@{b}    RESULT@{ub}
        TRUE if the string was replaced. A failure is likely to be because
        nothing was marked when this method got invoked.

@EndNode

