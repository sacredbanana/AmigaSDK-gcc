%PDF-1.1
%«Ïè¢
4 0 obj
<</Length 5 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 16 Tf
-0.00599416 Tc
1 0 0 1 72 757.1 Tm(Preface)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
-280.8 -16 Td( )Tj
/R6 16 Tf
-0.00754886 Tc
0 -17.6 Td(Introduction to USB)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
0.00909736 Tc
-280.8 -16 Td(Introduction)Tj
0 Tc
274.1 0 Td(2)Tj
0.000852083 Tc
-274.1 -14.4 Td(What is the USB bus?)Tj
0 Tc
274.1 0 Td(2)Tj
0.00328133 Tc
-274.1 -14.4 Td(Anatomy of a USB device)Tj
0 Tc
274.1 0 Td(2)Tj
0.00174746 Tc
-274.1 -14.4 Td(Transfers on the USB bus)Tj
0 Tc
274.1 0 Td(3)Tj
-274.1 -14.4 Td( )Tj
/R6 16 Tf
-0.00732803 Tc
0 -17.6 Td(Introducing the USB stack)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
0.00364234 Tc
-280.8 -16 Td(Introductary)Tj
0 Tc
274.1 0 Td(4)Tj
/R6 10 Tf
0.0218284 Tc
-274.1 -12.8 Td(USB concepts)Tj
0 Tc
275.2 0 Td(4)Tj
0.00734558 Tc
-275.2 -12 Td(Function Drivers)Tj
0 Tc
275.2 0 Td(4)Tj
0.0136486 Tc
-275.2 -12 Td(Choosing a driver style)Tj
0 Tc
275.2 0 Td(5)Tj
/R6 12 Tf
0.000896454 Tc
-275.2 -13.6 Td(USB stack datatypes)Tj
0 Tc
274.1 0 Td(6)Tj
/R6 10 Tf
0.0130879 Tc
-274.1 -12.8 Td(UsbRawFunction)Tj
0 Tc
275.2 0 Td(6)Tj
0.0170116 Tc
-275.2 -12 Td(UsbFunction)Tj
0 Tc
275.2 0 Td(6)Tj
0.015013 Tc
-275.2 -12 Td(UsbRawInterface)Tj
0 Tc
275.2 0 Td(6)Tj
0.0191054 Tc
-275.2 -12 Td(UsbInterface)Tj
0 Tc
275.2 0 Td(6)Tj
0.0240112 Tc
-275.2 -12 Td(UsbEndPoint)Tj
0 Tc
275.2 0 Td(6)Tj
0.0200124 Tc
-275.2 -12 Td(USBIOReq)Tj
0 Tc
275.2 0 Td(7)Tj
0.00819189 Tc
-275.2 -12 Td(USBNotifyMsg)Tj
0 Tc
275.2 0 Td(7)Tj
0.0128697 Tc
-275.2 -12 Td(USBFDStartupMsg)Tj
0 Tc
275.2 0 Td(7)Tj
/R6 12 Tf
0.0050087 Tc
-275.2 -13.6 Td(USB datatypes)Tj
0 Tc
274.1 0 Td(7)Tj
/R6 10 Tf
0.0257258 Tc
-274.1 -12.8 Td(USBBusSetupData)Tj
0 Tc
275.2 0 Td(7)Tj
0.0158405 Tc
-275.2 -12 Td(USBBusDscHead)Tj
0 Tc
275.2 0 Td(7)Tj
0.0100056 Tc
-275.2 -12 Td(USBBusDevDsc)Tj
0 Tc
275.2 0 Td(8)Tj
0.0118249 Tc
-275.2 -12 Td(USBBusCfgDsc)Tj
0 Tc
275.2 0 Td(8)Tj
0.0154634 Tc
-275.2 -12 Td(USBBusIntDsc)Tj
0 Tc
275.2 0 Td(8)Tj
0.0150047 Tc
-275.2 -12 Td(USBBusEPDsc)Tj
0 Tc
275.2 0 Td(8)Tj
/R6 12 Tf
0.0071636 Tc
-275.2 -13.6 Td(Locking of datatypes)Tj
0 Tc
274.1 0 Td(8)Tj
-274.1 -14.4 Td( )Tj
/R6 16 Tf
0.0031674 Tc
0 -17.6 Td(Finding a USB Target)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
0.00909736 Tc
-280.8 -16 Td(Introduction)Tj
0 Tc
274.1 0 Td(9)Tj
0.00491819 Tc
-274.1 -14.4 Td(Finding a USB Interface)Tj
0 Tc
274.1 0 Td(9)Tj
0.00858089 Tc
-274.1 -14.4 Td(Finding a USB Function)Tj
0.0560055 Tc
267.4 0 Td(10)Tj
0 Tc
-267.4 -14.4 Td( )Tj
/R6 16 Tf
-0.00892639 Tc
0 -17.6 Td(Getting to know your USB Target)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
0.00909736 Tc
-280.8 -16 Td(Introduction)Tj
0.0560055 Tc
267.4 0 Td(12)Tj
0.000372222 Tc
-267.4 -14.4 Td(Getting to know your USB Interface)Tj
0.0560055 Tc
267.4 0 Td(12)Tj
0.00263357 Tc
-267.4 -14.4 Td(Getting to know your USB Function)Tj
0.0560055 Tc
267.4 0 Td(13)Tj
/R6 10 Tf
0.0136124 Tc
-267.4 -12.8 Td(Read the Device Descriptor)Tj
0.0800295 Tc
269.6 0 Td(13)Tj
0.020967 Tc
-269.6 -12 Td(Configure the Function)Tj
0.0800295 Tc
269.6 0 Td(13)Tj
0.024134 Tc
-269.6 -12 Td(Get the Interfaces)Tj
0.0800295 Tc
269.6 0 Td(15)Tj
/R6 12 Tf
0.000509739 Tc
-269.6 -13.6 Td(Get the EndPoints)Tj
0.0560055 Tc
267.4 0 Td(16)Tj
0 Tc
-267.4 -14.4 Td( )Tj
ET Q
Q
endstream
endobj
5 0 obj
3231
endobj
3 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 4 0 R
>>
endobj
8 0 obj
<</Length 9 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 16 Tf
0.00134277 Tc
1 0 0 1 72 757.1 Tm(Talking with your USB Target)Tj
0 Tc
280.8 0 Td( )Tj
/R6 12 Tf
0.00909736 Tc
-280.8 -16 Td(Introduction)Tj
0.0560055 Tc
267.4 0 Td(18)Tj
0.00416687 Tc
-267.4 -14.4 Td(Basics of transfering data)Tj
0.0560055 Tc
267.4 0 Td(18)Tj
/R6 10 Tf
0.0175133 Tc
-267.4 -12.8 Td(Allocating IO)Tj
0.0800295 Tc
269.6 0 Td(18)Tj
0.0166808 Tc
-269.6 -12 Td(The USBIOReq structure)Tj
0.0800295 Tc
269.6 0 Td(19)Tj
/R6 12 Tf
0.0106291 Tc
-269.6 -13.6 Td(Talking with Control EndPoints)Tj
0.0560055 Tc
267.4 0 Td(20)Tj
/R6 10 Tf
0.0197754 Tc
-267.4 -12.8 Td(Background information on Control EndPoints)Tj
0.0800295 Tc
269.6 0 Td(20)Tj
0.0217531 Tc
-269.6 -12 Td(Setting up your USBIOReq)Tj
0.0800295 Tc
269.6 0 Td(21)Tj
0.0236529 Tc
-269.6 -12 Td(Doing the IO)Tj
0.0800295 Tc
269.6 0 Td(21)Tj
0.020014 Tc
-269.6 -12 Td(Taking the shortcut)Tj
0.0800295 Tc
269.6 0 Td(22)Tj
0.0222359 Tc
-269.6 -12 Td(An example)Tj
0.0800295 Tc
269.6 0 Td(22)Tj
0.0125854 Tc
-269.6 -12 Td(Some things you're not allowed to do)Tj
0.0800295 Tc
269.6 0 Td(24)Tj
/R6 12 Tf
0.0120082 Tc
-269.6 -13.6 Td(Talking with non-Control EndPoints)Tj
0.0560055 Tc
267.4 0 Td(24)Tj
/R6 10 Tf
0.0217531 Tc
-267.4 -12.8 Td(Setting up your USBIOReq)Tj
0.0800295 Tc
269.6 0 Td(24)Tj
0.0236529 Tc
-269.6 -12 Td(Doing the IO)Tj
0.0800295 Tc
269.6 0 Td(25)Tj
0.0222359 Tc
-269.6 -12 Td(An example)Tj
0.0800295 Tc
269.6 0 Td(25)Tj
/R6 12 Tf
-0.00499296 Tc
-269.6 -13.6 Td(IO errors)Tj
0.0560055 Tc
267.4 0 Td(26)Tj
/R6 10 Tf
0.00500706 Tc
-267.4 -12.8 Td(USBERR_DETACHED)Tj
0.0800295 Tc
269.6 0 Td(27)Tj
0.0011848 Tc
-269.6 -12 Td(USBERR_NOBANDWIDTH)Tj
0.0800295 Tc
269.6 0 Td(27)Tj
0.00364616 Tc
-269.6 -12 Td(USBERR_NOMEM)Tj
0.0800295 Tc
269.6 0 Td(27)Tj
0.0128675 Tc
-269.6 -12 Td(USBERR_NOSIGBIT)Tj
0.0800295 Tc
269.6 0 Td(27)Tj
0.0130844 Tc
-269.6 -12 Td(USBERR_BADARGS)Tj
0.0800295 Tc
269.6 0 Td(27)Tj
0.00625896 Tc
-269.6 -12 Td(USBERR_NOENDPOINT)Tj
0.0800295 Tc
269.6 0 Td(28)Tj
0.00588944 Tc
-269.6 -12 Td(USBERR_UNSUPPORTED)Tj
0.0800295 Tc
269.6 0 Td(28)Tj
0.0126739 Tc
-269.6 -12 Td(USBERR_ISPRESENT)Tj
0.0800295 Tc
269.6 0 Td(28)Tj
0.00938416 Tc
-269.6 -12 Td(USBERR_ATTACHFAIL)Tj
0.0800295 Tc
269.6 0 Td(28)Tj
0.0181906 Tc
-269.6 -12 Td(USBERR_STALL)Tj
0.0800295 Tc
269.6 0 Td(28)Tj
0.0128659 Tc
-269.6 -12 Td(USBERR_XFERFAIL)Tj
0.0800295 Tc
269.6 0 Td(29)Tj
0.0122291 Tc
-269.6 -12 Td(USBERR_NAK)Tj
0.0800295 Tc
269.6 0 Td(29)Tj
0.00539574 Tc
-269.6 -12 Td(USBERR_TIMEOUT)Tj
0.0800295 Tc
269.6 0 Td(29)Tj
0.00700989 Tc
-269.6 -12 Td(USBERR_BUFFEROVERFLOW)Tj
0.0800295 Tc
269.6 0 Td(29)Tj
ET Q
Q
endstream
endobj
9 0 obj
2633
endobj
7 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 8 0 R
>>
endobj
11 0 obj
<</Length 12 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R13 10 Tf
0.176685 Tc
1 0 0 1 96.2 168.9 Tm(Date)Tj
0.0200151 Tc
72 0 Td(Version)Tj
0.00901604 Tc
72 0 Td(Description)Tj
/R6 10 Tf
0.0289065 Tc
-144 -13.4 Td(19-09-2004)Tj
0.0500245 Tc
72 0 Td(0.1)Tj
0.0150126 Tc
72 0 Td(Initial draft. Covers USB and USB stack introductory )Tj
0.0188141 Tc
0 -12 Td(chapters and information on locating, claiming and )Tj
0.0197566 Tc
0 -12 Td(configuring USB Functions and Interfaces)Tj
0.0289065 Tc
-144 -13.5 Td(09-10-2004)Tj
0.0500245 Tc
72 0 Td(0.2)Tj
0.0200136 Tc
72 0 Td(Added section on performing IO with USB EndPoints.)Tj
0.0289065 Tc
-144 -13.4 Td(17-10-2004)Tj
0.0500245 Tc
72 0 Td(0.3)Tj
0.0228215 Tc
72 0 Td(Added clarification of the content of the EndPoint number )Tj
0.0200144 Tc
0 -12 Td(to give to USBGetEndPoint\(\).)Tj
ET Q
1 i
954 1262 4014 10 re
f
954 1128 4014 10 re
f
2389 721 10 1054 re
f
954 874 4014 10 re
f
1669 721 10 1054 re
f
954 1636 4014 10 re
f
10 w
1 J
1 j
954 1775 m
4968 1775 l
S
4968 1775 m
4968 721 l
S
4968 721 m
954 721 l
S
954 721 m
954 1775 l
S
q 10 0 0 10 0 0 cm BT
/R6 20 Tf
-0.00332387 Tc
1 0 0 1 72 753.9 Tm(Preface)Tj
/R6 12 Tf
0.00597977 Tc
0 -32 Td(What you have before you now, is a guide to developing USB drivers for he )Tj
0.00262778 Tc
0 -14.4 Td(AmigaOS4 USB stack. The intention of this guide is not to give full insight into the )Tj
0.000682049 Tc
0 -14.4 Td(inner workings of the USB bus. In fact, it propably won't even give give you enough )Tj
0.00364842 Tc
0 -14.4 Td(general USB knowledge to form your own transfer requests for the USB bus. This )Tj
0.00662458 Tc
0 -14.4 Td(job is already taken by the USB specification found at www.usb.org, which contain )Tj
0.00485445 Tc
0 -14.4 Td(all the information needed on that subject  - and a lot of other information as well, )Tj
0.00151295 Tc
0 -14.4 Td(which you can just skip. Afterall, as a driver developer you don't need to know about )Tj
0.00818842 Tc
0 -14.4 Td(USB cable specs, connector tolerances or electrical signal timings.)Tj
0.00438587 Tc
0 -28.8 Td(What this guide aims at is teaching you how to develop USB drivers for the )Tj
0.00167133 Tc
0 -14.4 Td(AmigaOS4 USB stack. The USB API documentation gives a description of each API )Tj
0.00700705 Tc
0 -14.4 Td(function call. The includes files gives comments on bits and pieces. This guide is in)Tj
0 Tc
440.1 0 Td(-)Tj
0.00508961 Tc
-440.1 -14.4 Td(tended to bind these informations together to get a clear understanding of what to do )Tj
0.00180779 Tc
0 -14.4 Td(\(and what not to do\).)Tj
0.00611017 Tc
0 -28.8 Td(You should be somewhat familiar with the USB bus before you start reading this )Tj
-0.00354271 Tc
0 -14.4 Td(guide. Not that you won't succeede without it, but you'll have a much easier job )Tj
0.00659953 Tc
0 -14.4 Td(learning what needs to be learnt if you know a little of USB beforehand.)Tj
0.00572737 Tc
0 -28.8 Td(If sections of this guide is unclear or contains erroneous information, please contact )Tj
0.00244761 Tc
0 -14.4 Td(the author so that it can be corrected in a future revision.)Tj
/R14 12 Tf
-0.00376892 Tc
1 0 0.00000001 1 72 405.1 Tm(Thomas Graff Th¯ger)Tj
0.0112567 Tc
36 -14.4 Td(graff@amigausb.dk)Tj
ET Q
Q
endstream
endobj
12 0 obj
3202
endobj
10 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R14 14 0 R
/R13 13 0 R
/R6 6 0 R
>>
>>
/Contents 11 0 R
>>
endobj
17 0 obj
<</Length 18 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 20 Tf
-0.00110202 Tc
1 0 0 1 72 753.9 Tm(Introduction to USB)Tj
/R6 18 Tf
-0.00452978 Tc
0 -22.4 Td(Introduction)Tj
/R6 12 Tf
0.00484449 Tc
0 -16.8 Td(Although the welcoming text for this guide states that you should be familiar with the )Tj
-0.00201717 Tc
0 -14.4 Td(USB bus before reading, I'm sure some of the readers never did take the time to fa)Tj
0 Tc
438.7 0 Td(-)Tj
0.00642714 Tc
-438.7 -14.4 Td(miliarize yourself with USB anyhow. So a little USB brush-up is in place at this early )Tj
0.00490723 Tc
0 -14.4 Td(stage. Those who have just laid down the USB spec may find that skipping this sec)Tj
0 Tc
440.6 0 Td(-)Tj
0.00205426 Tc
-440.6 -14.4 Td(tion alltogether is not that much of a loss.)Tj
/R6 18 Tf
-0.00398495 Tc
0 -33.6 Td(What is the USB bus?)Tj
/R6 12 Tf
0.00627871 Tc
0 -16.8 Td(The USB bus is a serial bus capable of hot-swapping devices in and out of the bus )Tj
0.00518332 Tc
0 -14.4 Td(topology at any given time. The bus is based on a four wire connection, consisting of )Tj
0.00800781 Tc
0 -14.4 Td(two power lines, and two data lines.)Tj
0.00501922 Tc
0 -14.4 Td(The USB system is based on a structure consisting of a single main host controlling )Tj
0.0059159 Tc
0 -14.4 Td(the bus, and a multitude of slave devices. The host device is responsible for initiating )Tj
0.00608265 Tc
0 -14.4 Td(all transactions on the USB bus - nobody ever speaks without being asked by the )Tj
-0.0039916 Tc
0 -14.4 Td(host.)Tj
0.00365753 Tc
0 -14.4 Td(The bus topology of the USB bus can be seen as a logical star topology. The host )Tj
0.00586754 Tc
0 -14.4 Td(sits in the middle, and all the connected devices sits around it, waiting for commands )Tj
0.00249537 Tc
0 -14.4 Td(from the host. Physically, however, the USB bus has a tree-like topology: The host )Tj
0.00212814 Tc
0 -14.4 Td(holds a number of USB ports, to which USB devices can be connected. If there is not )Tj
0.00498181 Tc
0 -14.4 Td(enough ports to hold the devices required, hubs can be attached to the ports. Hubs )Tj
0.00748081 Tc
0 -14.4 Td(have one connection towards the host \(the upstream connection\))Tj
0.00274337 Tc
345.3 0 Td(, and several ports )Tj
0.00679479 Tc
-345.3 -14.4 Td(for connecting with other USB devices \(the downstream connections\).)Tj
0.00481705 Tc
0 -28.8 Td(An important role of hubs in the USB bus, is their handling of device attachment and )Tj
0.00532435 Tc
0 -14.4 Td(detachment. Hubs are responsible for signalling to the USB System Software \(USB )Tj
0.00627758 Tc
0 -14.4 Td(stack\) when devices are attached or detached from the topology. Once signalled he )Tj
0.00484908 Tc
0 -14.4 Td(USB stack handles the software side of attachment/detachment, which includes )Tj
0.00861781 Tc
0 -14.4 Td(launching drivers, signalling drivers to terminate, as well as other background tasks.)Tj
0.000152956 Tc
0 -14.4 Td(An important thing to note about this is, that due to the hot-swap nature of USB, a )Tj
0.00386286 Tc
0 -14.4 Td(driver must expect that the USB device it is controlling can disappear from the USB )Tj
0.00362614 Tc
0 -14.4 Td(bus at any given time.)Tj
/R6 18 Tf
-0.00416704 Tc
0 -33.6 Td(Anatomy of a USB device)Tj
/R6 12 Tf
0.00655785 Tc
0 -16.8 Td(Each device connected on the USB bus is also called a USB Function- a single USB )Tj
0.00310443 Tc
0 -14.4 Td(entity connected on the USB bus.)Tj
0.00347044 Tc
0 -14.4 Td(Each Function basically hosts a number of Interfaces, which might be thought of as )Tj
0.00581248 Tc
0 -14.4 Td(logical units within the Function. For instance a USB keyboard may hold in it an In)Tj
0 Tc
434 0 Td(-)Tj
0.00217993 Tc
-434 -14.4 Td(terface for the keyboard itself, but also an Interface for a mouse pad or similar )Tj
0.00565473 Tc
0 -14.4 Td(built-in, but functionally different, functionality.)Tj
0.00319708 Tc
0 -14.4 Td(Each Interface has a descriptor describing the type and properties of the Interface, )Tj
0.00495644 Tc
0 -14.4 Td(so you can destinguish interfaces from one another. To actually communicate to a )Tj
0.00348445 Tc
0 -14.4 Td(USB Function \(or, usually the Interfaces within it\) you use EndPoints. Each EndPoint )Tj
0.00442346 Tc
0 -14.4 Td(is a communication channel to the USB Function/Interface. Sometimes EndPoints )Tj
0.00572041 Tc
0 -14.4 Td(are also refered to as pipes.)Tj
0.006057 Tc
0 -14.4 Td(One EndPoint is special. EndPoint 0 \(zero\), also known as the Default Control Pipe )Tj
ET Q
Q
endstream
endobj
18 0 obj
4435
endobj
16 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 17 0 R
>>
endobj
20 0 obj
<</Length 21 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00603218 Tc
1 0 0 1 72 760.3 Tm(\(DCP\), is always present in a USB Function. Using this EndPoint you control generic )Tj
0.00177002 Tc
0 -14.4 Td(features of the USB Function - configuring, status, etc which are general to the USB )Tj
0.00458683 Tc
0 -14.4 Td(Function. Other than the DCP, all EndPoints belong to individual Interfaces. So talk)Tj
0 Tc
440.6 0 Td(-)Tj
0.004601 Tc
-440.6 -14.4 Td(ing to anything but EndPoint 0 will have you talking with an Interface of the USB )Tj
0.00550842 Tc
0 -14.4 Td(Function.)Tj
-0.00264326 Tc
0 -14.4 Td(There is much more to say about Functions, Interfaces and EndPoints. I'll refer you )Tj
0.00410443 Tc
0 -14.4 Td(to the USB specification for that, or I could fill many pages here with something al)Tj
0 Tc
431.2 0 Td(-)Tj
0.0150452 Tc
-431.2 -14.4 Td(ready described elsewhere.)Tj
/R6 18 Tf
-0.00389895 Tc
0 -33.6 Td(Transfers on the USB bus)Tj
/R6 12 Tf
0.00290794 Tc
0 -16.8 Td(All transfers on the USB bus is performed between the host, and an EndPoint at a )Tj
0.000661954 Tc
0 -14.4 Td(Function. The USB bus describes four types of transfers:)Tj
0 Tc
13.5 -14.4 Td(∑)Tj
0.0206744 Tc
12.6 0 Td(Control)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
0.00150776 Tc
12.6 0 Td(Interrupt)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
0.0200113 Tc
12.6 0 Td(Bulk)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
0.0136032 Tc
12.6 0 Td(Isochronous)Tj
0.0055789 Tc
-26.1 -28.8 Td(Without going into too much detail the following can be said about the four transfer )Tj
-0.00319366 Tc
0 -14.4 Td(types:)Tj
0.00690727 Tc
0 -28.8 Td(Control xfer is generally used for sending immediate commands to a USB EndPoint, )Tj
0.00561642 Tc
0 -14.4 Td(such as reading status, setting or clearing switches, reading descriptors etc.)Tj
0.00339499 Tc
0 -28.8 Td(Interrupt xfer is used for xfers needing a regular service interval. E.g. checking if )Tj
0.00589855 Tc
0 -14.4 Td(something has been attached or detached from a USB hub, which must be done )Tj
0.00855598 Tc
0 -14.4 Td(regularly. Another example is reading keyboard keypress data, which must also be )Tj
0.016577 Tc
0 -14.4 Td(done regularly.)Tj
0.00621841 Tc
0 -28.8 Td(Bulk xfer is a transfer type designed for moving larger blocks of data in irregular in)Tj
0 Tc
434.7 0 Td(-)Tj
0.00260944 Tc
-434.7 -14.4 Td(tervals. This is used for things such as transfering data to/from USB harddisks and )Tj
0.00849082 Tc
0 -14.4 Td(reading image data from a scanner.)Tj
0.00114302 Tc
0 -28.8 Td(Isochronous xfer is a timely transfer type. It guarantees timely delivery of data at the )Tj
0.00525969 Tc
0 -14.4 Td(expense of data integrity. This is used for things like streaming of video or audio )Tj
0.00555923 Tc
0 -14.4 Td(where the importance is placed on realtime constraints rather than the correctness of )Tj
-0.00306205 Tc
0 -14.4 Td(data - e.g. it doesn't matter as much if a snip of audio is malformed, as if the audio )Tj
0.00563097 Tc
0 -14.4 Td(looses sync with its videostream.)Tj
0.0027236 Tc
0 -28.8 Td(The transfer type is hardcoded into the EndPoint to which a transfer is made. The )Tj
0.00932349 Tc
0 -14.4 Td(EndPoint type is thus generally already defined in the communication specification )Tj
0.00435191 Tc
0 -14.4 Td(for the type of USB device you are developing a driver for.)Tj
ET Q
Q
endstream
endobj
21 0 obj
3293
endobj
19 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 20 0 R
>>
endobj
23 0 obj
<</Length 24 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 20 Tf
-0.000825246 Tc
1 0 0 1 72 753.9 Tm(Introducing the USB stack)Tj
/R6 18 Tf
-0.00362188 Tc
0 -22.4 Td(Introductary)Tj
/R6 16 Tf
0.00218617 Tc
0 -20 Td(USB concepts)Tj
/R6 12 Tf
0.00545807 Tc
0 -16 Td(The AmigaOS USB stack is, luckily enough, built upon the information held in the )Tj
0.00396002 Tc
0 -14.4 Td(USB specification. As such the topological and structural design of the USB stack is )Tj
0.00685413 Tc
0 -14.4 Td(much alike what is laid out in the USB specification.)Tj
0.00583153 Tc
0 -28.8 Td(The USB stack generally operates with bus entities such as)Tj
0 Tc
13.5 -14.4 Td(∑)Tj
0.00656297 Tc
12.6 0 Td(UsbFunction representing a physical USB Function attached on the USB bus.)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
0.00322178 Tc
12.6 0 Td(UsbInterface representing an Interface of a USB Function.)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
0.00615772 Tc
12.6 0 Td(UsbEndPoint representing an EndPoint in a USB Function or Interface.)Tj
0.00493454 Tc
-26.1 -28.8 Td(These entities forms the basis for all operations regarding the USB bus in the USB )Tj
-0.000801813 Tc
0 -14.4 Td(stack. To simplify the rest of this guide, a USB Function or Interface targeted by a )Tj
0.00306947 Tc
0 -14.4 Td(Function Driver is termed a USB Target, rather than mentioning both Interfaces as )Tj
0.00600688 Tc
0 -14.4 Td(Functions, where a section applies to both.)Tj
0.00285797 Tc
0 -28.8 Td(To actually be able to communicate with EndPoints, the USB stack defines an IO re)Tj
0 Tc
443.1 0 Td(-)Tj
0.00441269 Tc
-443.1 -14.4 Td(quest structure, known as the USBIOReq. How this is created and used will be cov)Tj
0 Tc
439.2 0 Td(-)Tj
0.00400628 Tc
-439.2 -14.4 Td(ered in a later chapter on transfers.)Tj
0.00487851 Tc
0 -28.8 Td(The USB spec also defines a concept known as descriptors, which is a data struc)Tj
0 Tc
431.9 0 Td(-)Tj
0.00443558 Tc
-431.9 -14.4 Td(ture with a fixed header, followed by free form data. Descriptors are what binds the )Tj
0.00995712 Tc
0 -14.4 Td(generic nature of USB with the individual drivers. By reading and understading de)Tj
0 Tc
433 0 Td(-)Tj
0.0035246 Tc
-433 -14.4 Td(scriptor contents a driver can find out information about Functions, Interfaces and )Tj
0.00757351 Tc
0 -14.4 Td(EndPoints, as well as other information depending on the type of device in question.)Tj
0.00376007 Tc
0 -28.8 Td(The above three conceptual main categories forms the foundation of the USB stack. )Tj
0.00455704 Tc
0 -14.4 Td(There is much more, but at this early overview stage, there is now need to compli)Tj
0 Tc
431.2 0 Td(-)Tj
-0.00752109 Tc
-431.2 -14.4 Td(cate things any further. We'll get to that later on.)Tj
/R6 16 Tf
0.00241038 Tc
0 -32 Td(Function Drivers)Tj
/R6 12 Tf
-0.00208646 Tc
0 -16 Td(In context of the AmigaOS USB stack, a driver for a USB Function, or an Interface in )Tj
0.0027671 Tc
0 -14.4 Td(a USB Function, is called a Function Driver, or just an FD.)Tj
0.00132462 Tc
0 -14.4 Td(The USB stack supports two main types of Function Drivers: SelfStarting FDs and )Tj
0.00436247 Tc
0 -14.4 Td(AutoStarting FDs. The difference between them lies in the way in which they are )Tj
-0.00284958 Tc
0 -14.4 Td(started.)Tj
0.00557699 Tc
0 -28.8 Td(SelfStarting FDs are just ordinary programs which opens the USB stack device, lo)Tj
0 Tc
434.6 0 Td(-)Tj
-0.00300401 Tc
-434.6 -14.4 Td(cates the USB Function to use and start using it. There is no surrounding fuss - it's )Tj
0.00442773 Tc
0 -14.4 Td(just a normal program you can run from Workbench or a CLI.)Tj
0.00259362 Tc
0 -28.8 Td(AutoStarting FDs, on the other hand, are Exec libraries which the USB stack itself )Tj
0.0103129 Tc
0 -14.4 Td(will open and use when a USB device which the FD can handle )Tj
0.00291651 Tc
340.1 0 Td(is attached.)Tj
0.00315094 Tc
-340.1 -14.4 Td(If your FD is going to control USB Functions which offers immediate functionality to )Tj
0.00221375 Tc
0 -14.4 Td(the user \(like e.g. hubs, keyboards, mice, harddisks etc.\) it makes life easier for the )Tj
ET Q
Q
endstream
endobj
24 0 obj
4005
endobj
22 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 23 0 R
>>
endobj
26 0 obj
<</Length 27 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00304123 Tc
1 0 0 1 72 760.3 Tm(user if the driver is automatically started when such a Function is attached. In such a )Tj
0.00300751 Tc
0 -14.4 Td(case the FD should be made as an AutoStarting FD - once the Function is attached )Tj
0.00138883 Tc
0 -14.4 Td(it immediately starts offering its services to the user.)Tj
0.00324838 Tc
0 -14.4 Td(If your FD is going to control USB Functions which does not offer immediate func)Tj
0 Tc
429.1 0 Td(-)Tj
0.0039096 Tc
-429.1 -14.4 Td(tionality to the user, or which depends on some other software to be usefull \(e.g. )Tj
0.00237698 Tc
0 -14.4 Td(printers, scanners, ethernet adapters etc.\) there is no need for the driver to be )Tj
0.00358384 Tc
0 -14.4 Td(around at all times. In such cases a SelfStarting FD might be a more suitable choice. )Tj
0.00278104 Tc
0 -14.4 Td(In the end, however, it is up to you to make a clever decision.)Tj
0.00358901 Tc
0 -28.8 Td(For reasons of simplicity this guide will concentrate on SelfStarting FDs thru most of )Tj
-0.00166605 Tc
0 -14.4 Td(the chapters, due to the fact that It is simpler to get to grasps with SelfStarting FDs)Tj
0 Tc
437.4 0 Td(.)Tj
0.0103274 Tc
-437.4 -14.4 Td(Also, debugging of normal programs are much easier than debugging Exec libraries, )Tj
0.00733126 Tc
0 -14.4 Td(making it easier to experiment while working on a SelfStarting FD.)Tj
0.00137478 Tc
0 -14.4 Td(The methods laid out for SelfStarting FDs also hold for AutoStarting FDs. SelfStart)Tj
0 Tc
436.3 0 Td(-)Tj
0.00423973 Tc
-436.3 -14.4 Td(ing FDs can always be changed into an AutoStarting FD at a later time.)Tj
/R6 16 Tf
-0.000900962 Tc
0 -32 Td(Choosing a driver style)Tj
/R6 12 Tf
0.00219013 Tc
0 -16 Td(A USB Function is always bound to a USB device class - e.g. Hub, HID, MassStor)Tj
0 Tc
435 0 Td(-)Tj
0.00427726 Tc
-435 -14.4 Td(age etc. - indicating the type of functionality contained within the Function. This class )Tj
0.0034362 Tc
0 -14.4 Td(can be used by an FD to determine if it can handle that specific USB Function.)Tj
0.00391379 Tc
0 -14.4 Td(Not all USB Functions can, however, be fitted into a single class. Such Functions are )Tj
0.00577258 Tc
0 -14.4 Td(multiclass, and their content class cannot be derived from the Function alone.)Tj
0.000512836 Tc
0 -14.4 Td(In this case one has to look at the Interfaces in the Function. Each Interface also has )Tj
0.00264359 Tc
0 -14.4 Td(a class indicator. By looking at the Interface class it is thus possible to identify the )Tj
0.00161669 Tc
0 -14.4 Td(type of service delivered by the Interface. As opposed to a Function, an Interface )Tj
-0.000172629 Tc
0 -14.4 Td(can't be multiclass. One Interface always belongs to one class only.)Tj
0.00439676 Tc
0 -28.8 Td(As a functionality classes can be assigned to both Functions as well as Interfaces )Tj
0.00306576 Tc
0 -14.4 Td(there are two different approaches to creating a Function Driver: It can either focus )Tj
0.00152483 Tc
0 -14.4 Td(on a Function or an Interface.)Tj
0.00430411 Tc
0 -28.8 Td(Focusing on a Function \(termed a Function based FD\) allows the FD to take full con)Tj
0 Tc
445.2 0 Td(-)Tj
-0.00118703 Tc
-445.2 -14.4 Td(trol of that Function. That is, the FD is free to reconfigure the entire Function as it )Tj
0.000477869 Tc
0 -14.4 Td(sees fit, and use as many of the Interfaces in the Function as it can handle. This is )Tj
0.0056344 Tc
0 -14.4 Td(usefull for vendor specific drivers for devices with more than one Interface where you )Tj
0.00219763 Tc
0 -14.4 Td(need to know that all the Interfaces you have belongs to the same Function. Take for )Tj
0.00815862 Tc
0 -14.4 Td(instance a USB phone device where the microphone and speaker are different Inter)Tj
0 Tc
444.2 0 Td(-)Tj
-0.000591059 Tc
-444.2 -14.4 Td(faces. Here you'd like your driver to handle both Interfaces, and be sure that they are )Tj
0.00555469 Tc
0 -14.4 Td(both from the same phone device.)Tj
0.00390701 Tc
0 -14.4 Td(The price you pay for using a Funtion based FD is that you have to do everything )Tj
0.00405417 Tc
0 -14.4 Td(yourself. If you own the entire Function no other FDs can step in and handle specific )Tj
0.00353681 Tc
0 -14.4 Td(Interfaces within that Function. Thus, you have to handle all required aspects of the )Tj
0.00824946 Tc
0 -14.4 Td(Function without any outside help.)Tj
0.00346318 Tc
0 -28.8 Td(Focusing on an Interface \(termed an Interface based FD\) only gives your FD access )Tj
0.00257516 Tc
0 -14.4 Td(to one Interface, although many Interfaces may exist within an attached Function. )Tj
0.00653149 Tc
0 -14.4 Td(While this may seem limited, most USB devices are logically split into multiple Inter)Tj
0 Tc
440 0 Td(-)Tj
0.00361162 Tc
-440 -14.4 Td(faces each covering a selfcontained part of the Function. Thus an Interface based )Tj
ET Q
Q
endstream
endobj
27 0 obj
4818
endobj
25 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 26 0 R
>>
endobj
29 0 obj
<</Length 30 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.0038506 Tc
1 0 0 1 72 760.3 Tm(FD will not need to know about any other Interfaces.)Tj
-0.000480094 Tc
0 -14.4 Td(The important aspect of Interface based FDs is, that they allow the USB stack to as)Tj
0 Tc
441.5 0 Td(-)Tj
-0.000689839 Tc
-441.5 -14.4 Td(sign different FDs to different Interfaces in the same Function. It thus allows FDs to )Tj
0.00735545 Tc
0 -14.4 Td(cooperate in handling all the various functionalities presented by the Interfaces of a )Tj
0.00550842 Tc
0 -14.4 Td(Function.)Tj
0.00434453 Tc
0 -28.8 Td(When developing FDs it is adviced that you develop Interface based FDs. Only if you )Tj
0.00721571 Tc
0 -14.4 Td(need close linkage between various Interface types, or if you are doing vendor or )Tj
0.00534004 Tc
0 -14.4 Td(product specific FDs should you create Function based FDs.)Tj
/R6 18 Tf
-0.00420888 Tc
0 -33.6 Td(USB stack datatypes)Tj
/R6 12 Tf
0.00294734 Tc
0 -16.8 Td(Before going into descriptions of how to use the USB stack, a short introduction to )Tj
0.00405417 Tc
0 -14.4 Td(the datatypes found in the stack might be a good idea. Use it as an introduction now, )Tj
0.00536174 Tc
0 -14.4 Td(and as a reference later, when reading the rest of this manual.)Tj
/R6 16 Tf
0.0147799 Tc
0 -32 Td(UsbRawFunction)Tj
/R6 12 Tf
0.00494187 Tc
0 -16 Td(The UsbRawFunction acts as a searching and reference key in the USB stack Func)Tj
0 Tc
443.9 0 Td(-)Tj
0.00005559 Tc
-443.9 -14.4 Td(tion lists. It represents a USB Function on the USB bus, but it does not grant you ac)Tj
0 Tc
442.9 0 Td(-)Tj
0.00569974 Tc
-442.9 -14.4 Td(cess to communicate with the USB Function. For communication you will need a Us)Tj
0 Tc
444.6 0 Td(-)Tj
0.0078105 Tc
-444.6 -14.4 Td(bFunction, which is obtained on the basis of a UsbRawFunction.)Tj
/R6 16 Tf
0.00920944 Tc
0 -32 Td(UsbFunction)Tj
/R6 12 Tf
0.00236861 Tc
0 -16 Td(The UsbFunction is the basis for operation for a Function based FD. It represents a )Tj
0.00437686 Tc
0 -14.4 Td(USB Function on the USB bus, but, unlike the UsbRawFunction, the UsbFunction )Tj
0.000970312 Tc
0 -14.4 Td(grants you access to communicate with the Function. Or rather, it grants you access )Tj
0.00588062 Tc
0 -14.4 Td(to find UsbInterfaces and UsbEndPoints in the Function with which you then commu)Tj
0 Tc
446 0 Td(-)Tj
0.00800832 Tc
-446 -14.4 Td(nicate.)Tj
0.00728901 Tc
0 -14.4 Td(A UsbFunction is created from a UsbRawFunction when you claim ownership of the )Tj
0.00451312 Tc
0 -14.4 Td(Function. Once you have a UsbFunction you are guaranteed to be the only user of )Tj
-0.00060683 Tc
0 -14.4 Td(that Function.)Tj
/R6 16 Tf
-0.000277383 Tc
0 -32 Td(UsbRawInterface)Tj
/R6 12 Tf
0.00344964 Tc
0 -16 Td(The UsbRawInterface acts as a searching and reference key in the USB stack Inter)Tj
0 Tc
441.8 0 Td(-)Tj
-0.00158213 Tc
-441.8 -14.4 Td(face lists. It represents a USB Interface on the USB bus, but it does not grant you )Tj
0.0048789 Tc
0 -14.4 Td(access to communicate with it. For communication you will need a UsbInterface, )Tj
0.00722249 Tc
0 -14.4 Td(which is obtained on the basis of a UsbRawInterface.)Tj
/R6 16 Tf
-0.00944866 Tc
0 -32 Td(UsbInterface)Tj
/R6 12 Tf
0.000937174 Tc
0 -16 Td(The UsbInterface is the basis for operation for an Interface based FD. It represents a )Tj
0.00190887 Tc
0 -14.4 Td(USB Interface in a USB Function on the USB bus, but, unlike a UsbRawInterface, a )Tj
-0.000144862 Tc
0 -14.4 Td(UsbInterface grants you access to communicate with the Interface. Or rather, it )Tj
0.00336447 Tc
0 -14.4 Td(grants you access to find the UsbEndPoints which make up the Interface so you can )Tj
0.00419689 Tc
0 -14.4 Td(communicate thru them.)Tj
/R6 16 Tf
0.0124069 Tc
0 -32 Td(UsbEndPoint)Tj
/R6 12 Tf
0.00391072 Tc
0 -16 Td(A UsbEndPoint is the basis for all communication with a USB Function or Interface. )Tj
ET Q
Q
endstream
endobj
30 0 obj
3857
endobj
28 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 29 0 R
>>
endobj
32 0 obj
<</Length 33 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00809097 Tc
1 0 0 1 72 760.3 Tm(All communication takes place thru a UsbEndPoint.)Tj
0.00570014 Tc
0 -14.4 Td(A UsbEndPoint belongs to either a UsbFunction or a UsbInterface. You get UsbEnd)Tj
0 Tc
444 0 Td(-)Tj
0.0066903 Tc
-444 -14.4 Td(Points from their parent UsbFunction or UsbInterface, depending on which they be)Tj
0 Tc
437.4 0 Td(-)Tj
0.00311423 Tc
-437.4 -14.4 Td(long to. One notable exception to this is the Default Control Pipe of a USB Function. )Tj
0.00481742 Tc
0 -14.4 Td(Due to its general usage the Default Control Pipe \(aka EndPoint 0\) is part of both a )Tj
0.00407461 Tc
0 -14.4 Td(UsbFunction and all of the UsbInterfaces in the USB Function.)Tj
/R6 16 Tf
0.00915091 Tc
0 -32 Td(USBIOReq)Tj
/R6 12 Tf
0.00134059 Tc
0 -16 Td(This datatype is an extension of an Exec IORequest structure. It is used for reading )Tj
0.00539183 Tc
0 -14.4 Td(and writing data from/to a UsbEndPoint by performing Exec device-style IO opera)Tj
0 Tc
432.6 0 Td(-)Tj
-0.004957 Tc
-432.6 -14.4 Td(tions \(DoIO\(\), SendIO\(\) etc.\).)Tj
/R6 16 Tf
0.00764604 Tc
0 -32 Td(USBNotifyMsg)Tj
/R6 12 Tf
0.00523035 Tc
0 -16 Td(The USB stack includes a simple notification system used for sending notifications to )Tj
0.00110779 Tc
0 -14.4 Td(FDs if the USB Function or Interface they control has been detached from the USB )Tj
0.005007 Tc
0 -14.4 Td(bus. The USBNotifyMsg is the message used for sending such notifications.)Tj
/R6 16 Tf
0.00486755 Tc
0 -32 Td(USBFDStartupMsg)Tj
/R6 12 Tf
-0.000503931 Tc
0 -16 Td(When the USB stack starts an AutoStarting FD the FD is given a USBFDStartupMsg )Tj
0.0045645 Tc
0 -14.4 Td(as argument. This structure holds information on which USB Target the FD should )Tj
-0.00052592 Tc
0 -14.4 Td(take control of.)Tj
/R6 18 Tf
-0.00498454 Tc
0 -33.6 Td(USB datatypes)Tj
/R6 12 Tf
0.000756836 Tc
0 -16.8 Td(Apart form the above USB stack datatypes there are a set of datatypes defined by )Tj
0.00487546 Tc
0 -14.4 Td(the USB specification. Although not directly defined by the USB stack you will come )Tj
0.00342463 Tc
0 -14.4 Td(across these structures when working with the USB stack.)Tj
0.00190735 Tc
0 -14.4 Td(One thing which is very important to notice is that these structures are USB bus )Tj
0.00265797 Tc
0 -14.4 Td(structures. This means that they are all in LittleEndian data format, as opposed to )Tj
0.00628623 Tc
0 -14.4 Td(the Amiga which operates in BigEndian data format. Whenever a 16 bit integer is )Tj
0.00576619 Tc
0 -14.4 Td(present in a USB datatype you must be sure to perform endianness conversion )Tj
0.00855095 Tc
0 -14.4 Td(\(swaping MSB and LSB of the word\), or you will end up reading or writing wrong val)Tj
0 Tc
444.2 0 Td(-)Tj
0.00667318 Tc
-444.2 -14.4 Td(ues.)Tj
0.00615002 Tc
0 -14.4 Td(A macro has been made in the include file "usb/usb.h" which performs this for 16 bit )Tj
0.00517868 Tc
0 -14.4 Td(integers, named LE_WORD\(\). Use it for both reading and writing to 16 bit fields in )Tj
0.000479754 Tc
0 -14.4 Td(the USB datatypes.)Tj
0.00833236 Tc
0 -14.4 Td(The include file "usb/usb.h" also holds the structure definitions described in this sec)Tj
0 Tc
442.1 0 Td(-)Tj
0.00597977 Tc
-442.1 -14.4 Td(tion. Here you will also find constant definitions used in the structures.)Tj
/R6 16 Tf
0.00971985 Tc
0 -32 Td(USBBusSetupData)Tj
/R6 12 Tf
0.00162863 Tc
0 -16 Td(The USBBusSetupData structure is a structurization of the USB Setup Data packet )Tj
0.00540771 Tc
0 -14.4 Td(used for initiating a Control transfer to a Control EndPoint.)Tj
0.00299373 Tc
0 -14.4 Td(When using a Setup stage in a USBIOReq this is the data structure which )Tj
0.0056276 Tc
0 -14.4 Td(io_SetupData must point to, and its size which must be stored in io_SetupLength.)Tj
/R6 16 Tf
0.0203412 Tc
0 -32 Td(USBBusDscHead)Tj
/R6 12 Tf
0.00104262 Tc
0 -16 Td(This structure is at the head of all USB descriptors. You'll propably never encounter )Tj
ET Q
Q
endstream
endobj
33 0 obj
3945
endobj
31 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 32 0 R
>>
endobj
35 0 obj
<</Length 36 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00220248 Tc
1 0 0 1 72 760.3 Tm(this on its own, rather embedded into a USB descriptor of some sorts. It describes )Tj
0.00230963 Tc
0 -14.4 Td(the type and size of a descriptor.)Tj
/R6 16 Tf
0.0214622 Tc
0 -32 Td(USBBusDevDsc)Tj
/R6 12 Tf
0.00363087 Tc
0 -16 Td(This is a structurization of a USB Device Descriptor. It holds basic information on a )Tj
0.000564999 Tc
0 -14.4 Td(USB Function attached to the USB bus.)Tj
/R6 16 Tf
0.0170989 Tc
0 -32 Td(USBBusCfgDsc)Tj
/R6 12 Tf
0.00448939 Tc
0 -16 Td(This is a structurization of a USB Configuration Descriptor. It describes the proper)Tj
0 Tc
433.2 0 Td(-)Tj
0.00505791 Tc
-433.2 -14.4 Td(ties of one possible configuration of a USB Function. Each USB Function have one )Tj
0.00592213 Tc
0 -14.4 Td(or more possible configurations, but only one can be active at any time.)Tj
/R6 16 Tf
0.00836945 Tc
0 -32 Td(USBBusIntDsc)Tj
/R6 12 Tf
0.000951531 Tc
0 -16 Td(This is a structurization of a USB Interface Descriptor. It describes the properties of a )Tj
0.00329042 Tc
0 -14.4 Td(single Interface within a USB Function. A USB Function may have zero or more In)Tj
0 Tc
435.1 0 Td(-)Tj
0.00579834 Tc
-435.1 -14.4 Td(terfaces, depending on the chosen configuration of the USB Function.)Tj
/R6 16 Tf
0.0240059 Tc
0 -32 Td(USBBusEPDsc)Tj
/R6 12 Tf
0.00219407 Tc
0 -16 Td(This is a structurization of a USB EndPoint Descriptor. It describes the properties of )Tj
0.00529089 Tc
0 -14.4 Td(a specific EndPoint in a USB Function. A USB Function will have one or more End)Tj
0 Tc
436.6 0 Td(-)Tj
0.00714581 Tc
-436.6 -14.4 Td(Points depending on the configuration chosen for the USB Function.)Tj
/R6 18 Tf
-0.00503861 Tc
0 -33.6 Td(Locking of datatypes)Tj
/R6 12 Tf
0.00145798 Tc
0 -16.8 Td(The USB stack is a complex piece of work. Bear in mind that the USB bus is a bus )Tj
0.0105918 Tc
0 -14.4 Td(architecture allowing the user to plug and unplug devices while the computer is pow)Tj
0 Tc
444.4 0 Td(-)Tj
0.00390508 Tc
-444.4 -14.4 Td(ered on. The USB stack must therefore perform cleanup when a USB Function is un)Tj
0 Tc
446.5 0 Td(-)Tj
0.0151164 Tc
-446.5 -14.4 Td(plugged \(detached\).)Tj
0.00450078 Tc
0 -14.4 Td(When the Function is detached there may, however, still be software using the Func)Tj
0 Tc
445.9 0 Td(-)Tj
0.00429281 Tc
-445.9 -14.4 Td(tion and referencing structures in memory related to the just detached USB Function. )Tj
0.0018838 Tc
0 -14.4 Td(The USB stack must therefore keep track of who is using which Functions \(or the In)Tj
0 Tc
443 0 Td(-)Tj
0.00360674 Tc
-443 -14.4 Td(terfaces within it\). For this reason a locking system has been created.)Tj
0.002495 Tc
0 -14.4 Td(As long as a piece of software has a lock on either a Function or an Interface the )Tj
0.002328 Tc
0 -14.4 Td(USB stack will not remove the in-memory structures used for referring to that Func)Tj
0 Tc
437 0 Td(-)Tj
0.00366983 Tc
-437 -14.4 Td(tion/Interface even though the physical USB Function is detached. In order for exter)Tj
0 Tc
443.2 0 Td(-)Tj
0.0029955 Tc
-443.2 -14.4 Td(nal programs to work reliably with the USB stack, they must therefore adhere to the )Tj
0.00227458 Tc
0 -14.4 Td(locking rules of the USB stack.)Tj
0.00405661 Tc
0 -14.4 Td(The locking rules of the USB stack will come to show later in this guide. They are )Tj
0.00908367 Tc
0 -14.4 Td(also explained in the usbsys.device documentation for the individual API calls.)Tj
ET Q
Q
endstream
endobj
36 0 obj
3453
endobj
34 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 35 0 R
>>
endobj
38 0 obj
<</Length 39 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 20 Tf
-0.0105173 Tc
1 0 0 1 72 753.9 Tm(Finding a USB Target)Tj
/R6 18 Tf
-0.00452978 Tc
0 -22.4 Td(Introduction)Tj
/R6 12 Tf
-0.0016781 Tc
0 -16.8 Td(The first thing a FD needs to do, is to find the USB Interface, or Function \(the Tar)Tj
0 Tc
429.4 0 Td(-)Tj
-0.000310031 Tc
-429.4 -14.4 Td(get\), that it wants to control. This is a multi-step operation, due to the nature of the )Tj
0.0088659 Tc
0 -14.4 Td(USB bus design.)Tj
0.00264275 Tc
0 -14.4 Td(This section will go thru the method of finding a suitable USB Target for a FD for )Tj
0.00325012 Tc
0 -14.4 Td(both Interface and Function based FDs.)Tj
/R6 18 Tf
-0.00398532 Tc
0 -33.6 Td(Finding a USB Interface)Tj
/R6 12 Tf
0.00289415 Tc
0 -16.8 Td(An Interface based FD will be developed with a type or make of USB Interface to )Tj
0.00697201 Tc
0 -14.4 Td(control in mind. This is typically defined by either a specific USB vendor and/or prod)Tj
0 Tc
444.1 0 Td(-)Tj
-0.000436995 Tc
-444.1 -14.4 Td(uct number, or a USB Interface class.)Tj
0.00170784 Tc
0 -28.8 Td(When run, an FD starts looking for a USB Interface to handle. This is done by suc)Tj
0 Tc
433 0 Td(-)Tj
0.00586446 Tc
-433 -14.4 Td(cessively calling to USBFindInterfaceA\(\) to find out which Interfaces are available. )Tj
0.00338388 Tc
0 -14.4 Td(Each call returns a reference to a USB Interface matching the search criteria.)Tj
0.00660488 Tc
0 -14.4 Td(USBFindInterfaceA\(\) will return one UsbRawFunction reference every time it is )Tj
0.00603205 Tc
0 -14.4 Td(called. This UsbRawInterface has been locked once to ense that the referenced In)Tj
0 Tc
436.7 0 Td(-)Tj
0.00475731 Tc
-436.7 -14.4 Td(terface is not expunged while we use it. If doing successive USBFindInterfaceA\(\) )Tj
0.00494744 Tc
0 -14.4 Td(calls the first returned reference must be unlocked )Tj
/R14 12 Tf
-0.00299072 Tc
1 0 0.00000001 1 341.7 462.7 Tm(after)Tj
/R6 12 Tf
0.00614984 Tc
1 0 0 1 365.7 462.7 Tm( having obtained the next ref)Tj
0 Tc
151.6 0 Td(-)Tj
0.0062928 Tc
-445.3 -14.4 Td(erence, by calling USBUnlockInterface\(\). Unlocking must not be performed until after )Tj
0.00156831 Tc
0 -14.4 Td(obtaining the next Interface reference, as USBFindInterfaceA\(\) uses the first Inter)Tj
0 Tc
431 0 Td(-)Tj
0.00588953 Tc
-431 -14.4 Td(face reference to return the next. Unlocking before calling USBFindInterfaceA\(\) could )Tj
0.00713564 Tc
0 -14.4 Td(potentially result in the UsbRawInterface given to USBFindInterfaceA\(\) being ex)Tj
0 Tc
423.4 0 Td(-)Tj
0.00646832 Tc
-423.4 -14.4 Td(punged by the time the reference is used inside the function call.)Tj
0.00635417 Tc
0 -14.4 Td(Having found the UsbRawInterface to use, the driver claims it by calling USB)Tj
0 Tc
407.3 0 Td(-)Tj
0.00583376 Tc
-407.3 -14.4 Td(ClaimInterface\(\). By claiming the UsbRawInterface the FD ensures unique access to )Tj
0.000907516 Tc
0 -14.4 Td(the Interface, and is able to communicate with the Interface. Furthermore the FD )Tj
0.00740911 Tc
0 -14.4 Td(bind an \(already initialized\) message port to the Interface for receiving notifications.)Tj
0.00318743 Tc
0 -14.4 Td(After having claimed the Interface the temporary lock set on the UsbRawInterface by )Tj
0.00732459 Tc
0 -14.4 Td(USBFindInterfaceA\(\) can be cleared - the claiming of the UsbRawFunction \(resulting )Tj
0.00494851 Tc
0 -14.4 Td(in a UsbFunction\) is in itself an indirect lock on the Function. The unlocking is, as )Tj
0.0101197 Tc
0 -14.4 Td(mentioned above, done by calling USBUnlockInterface\(\).)Tj
0.00534136 Tc
0 -14.4 Td(The proper way of iterating through possible USB Interfaces with USBFindInterfa)Tj
0 Tc
428.6 0 Td(-)Tj
0.00200738 Tc
-428.6 -14.4 Td(ceA\(\) is therefore:)Tj
0 Tc
36 -14.4 Td( )Tj
/R40 10 Tf
0 -12.8 Td(prevrawifc = NULL;)Tj
0 -12 Td(ifc)Tj
18 0 Td( = NULL;)Tj
-18 -12 Td(do {)Tj
36 -12 Td(rawifc = USBFindInterfaceA\( prevrawifc, ptags \); // Get Inter)Tj
366 0 Td(-)Tj
-75.3 -12 Td(face reference)Tj
-290.7 -12 Td(if \( prevrawifc \) {)Tj
36 -12 Td(USBUnlockInterface\( prevrawifc \); // Unlock previously )Tj
234.9 -12 Td(examined Interface)Tj
-270.9 -12 Td(})Tj
0 -24 Td(if \( rawifc \) {)Tj
36 -12 Td(ifc)Tj
18 0 Td( = USBClaimInterface\( rawifc, ourifcref, msgport \); // )Tj
ET Q
Q
endstream
endobj
39 0 obj
4227
endobj
37 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 38 0 R
>>
endobj
42 0 obj
<</Length 43 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 288 761.9 Tm(Claim Interface and bind to msg port)Tj
-108 -12 Td(if \( ifc \) {)Tj
36 -12 Td(USBUnlockInterface\( rawifc \); // Unlock Interface )Tj
143.1 -12 Td(\(undo lock made by USBFind)Tj
156 0 Td(-)Tj
-156 -12 Td(InterfaceA\(\) now that we )Tj
0 -12 Td(own the Interface\))Tj
-143.1 -12 Td(break; // Exit loop - Interface has been claimed)Tj
-36 -12 Td(} // Interface already claimed by other. Keep searching )Tj
67.5 -12 Td(for another Interface)Tj
-103.5 -12 Td(})Tj
0 -24 Td(prevrawifc = rawifc;)Tj
-36 -12 Td(} while \( rawifc \);)Tj
0 -24 Td(if \( ifc \) {)Tj
36 -12 Td(DoYourStuffWithTheInterface\(\); // Configure and handle the In)Tj
366 0 Td(-)Tj
-167.1 -12 Td(terface \(driver body\))Tj
-198.9 -12 Td(USBDeclaimInterface\( ifc \); // Declaim Interface after use)Tj
-36 -12 Td(} // else do nothing - fall through as we didn't find a suitable In)Tj
402 0 Td(-)Tj
-369.6 -12 Td(terface)Tj
/R6 12 Tf
0.00998113 Tc
-68.4 -28 Td(The above code assumes a message port has already been initialised and is pointed )Tj
0.00467428 Tc
0 -14.4 Td(to by the variable )Tj
/R14 12 Tf
0.00933838 Tc
1 0 0.00000001 1 166.8 491.5 Tm(msgport)Tj
/R6 12 Tf
-0.00759048 Tc
1 0 0 1 210.2 491.5 Tm(, and that )Tj
/R14 12 Tf
0.0120053 Tc
1 0 0.00000001 1 263.5 491.5 Tm(ptags)Tj
/R6 12 Tf
0.00580673 Tc
1 0 0 1 292.9 491.5 Tm( points to a TagItem array holding proper)Tj
0 Tc
217 0 Td(-)Tj
-0.000848679 Tc
-437.9 -14.4 Td(ties of the needed USB Interface type. The )Tj
/R14 12 Tf
0.00700712 Tc
1 0 0.00000001 1 302.1 477.1 Tm(ourifcref)Tj
/R6 12 Tf
0.0106731 Tc
1 0 0 1 345.5 477.1 Tm( variable is an any)Tj
0 Tc
96.9 0 Td(-)Tj
0.00632082 Tc
-370.4 -14.4 Td(thing-but-NULL-goes value which the USB stack will pass to the FD as a reference in )Tj
0.00370344 Tc
0 -14.4 Td(notification messages sent to the message port given in USBClaimInterface\(\). It )Tj
0.00525969 Tc
0 -14.4 Td(could be the UsbRawInterface reference, it could be a pointer to an FD-private struc)Tj
0 Tc
445.3 0 Td(-)Tj
-0.00132533 Tc
-445.3 -14.4 Td(ture holding USB Interface related data, it could be a constant - it's all up to you.)Tj
0.00273914 Tc
0 -28.8 Td(Once claimed the FD has ownership of the Interface it wants to control, and a UsbIn)Tj
0 Tc
445.1 0 Td(-)Tj
0.00000724 Tc
-445.1 -14.4 Td(terface reference for use in further calls to the USB stack.)Tj
/R6 18 Tf
-0.00379581 Tc
0 -33.6 Td(Finding a USB Function)Tj
/R6 12 Tf
0.00410843 Tc
0 -16.8 Td(A Function based FD will be made with a specific type or make of USB Function in )Tj
0.00422965 Tc
0 -14.4 Td(mind, just like an Interface based FD)Tj
0.00490523 Tc
194.9 0 Td(. This can be defined by either a specific vendor )Tj
0.0052247 Tc
-194.9 -14.4 Td(and/or product number, a USB Function class and USB Function subclass.)Tj
0.00527545 Tc
0 -14.4 Td(As you will discover, Function based FDs locate their target Function much like an )Tj
-0.000418156 Tc
0 -14.4 Td(Interface based FD locates its target Interface.)Tj
0.00215797 Tc
0 -28.8 Td(When run, the FD starts looking for a USB Function to handle. This is done by suc)Tj
0 Tc
435.7 0 Td(-)Tj
0.0160031 Tc
-435.7 -14.4 Td(cessively)Tj
0.00655907 Tc
48.8 0 Td( calling USBFindFunctionA\(\), each call returning a reference to a USB )Tj
0.00606063 Tc
-48.8 -14.4 Td(Function matching the search criteria.)Tj
0.00909899 Tc
0 -14.4 Td(USBFindFunctionA\(\) will return a UsbRawFunction reference. The UsbRawFunction )Tj
0.00464922 Tc
0 -14.4 Td(has been locked by USBFindFunctionA\(\) to ense that the referenced Function is not )Tj
0.00679229 Tc
0 -14.4 Td(expunged while in use. If doing successive USBFindFunctionA\(\) calls the first re)Tj
0 Tc
424.7 0 Td(-)Tj
0.00660591 Tc
-424.7 -14.4 Td(turned reference must be unlocked after having obtained the second reference, by )Tj
0.00893383 Tc
0 -14.4 Td(calling USBUnlockFunction\(\). Unlocking must not be performed until after obtaining )Tj
0.00238732 Tc
0 -14.4 Td(the next Function reference, as USBFindFunctionA\(\) uses the first Function refer)Tj
0 Tc
427.7 0 Td(-)Tj
0.0080578 Tc
-427.7 -14.4 Td(ence to return the next. Unlocking before calling USBFindFunctionA\(\) could poten)Tj
0 Tc
433.5 0 Td(-)Tj
0.00750732 Tc
-433.5 -14.4 Td(tially result in the reference given to USBFindFunctionA\(\) being expunged by the )Tj
0.00612446 Tc
0 -14.4 Td(time the reference is used inside the function call.)Tj
ET Q
Q
endstream
endobj
43 0 obj
4411
endobj
41 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 42 0 R
>>
endobj
45 0 obj
<</Length 46 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00871644 Tc
1 0 0 1 72 760.3 Tm(Having found the UsbRawFunction to use, the driver claims it by calling USBClaim)Tj
0 Tc
437.5 0 Td(-)Tj
0.00590437 Tc
-437.5 -14.4 Td(Function\(\). By claiming the UsbRawFunction the FD ensures unique access to the )Tj
0.00639782 Tc
0 -14.4 Td(Function, and is able to bind an \(already initialized\) message port to the Function for )Tj
0.0111373 Tc
0 -14.4 Td(receiving notifications.)Tj
0.00400711 Tc
0 -14.4 Td(After having claimed the Function the temporary lock set on the Function reference )Tj
0.00745967 Tc
0 -14.4 Td(by USBFindFunctionA\(\) can be cleared - the claiming of the UsbRawFunction )Tj
0.00656917 Tc
0 -14.4 Td(\(resulting in a UsbFunction\) is in itself an indirect lock on the Function. The unlocking )Tj
0.00956648 Tc
0 -14.4 Td(is, as mentioned above, done by calling USBUnlockFunction\(\).)Tj
0.0071972 Tc
0 -14.4 Td(The proper way of iterating through possible USB Functions with USBFindFunc)Tj
0 Tc
420.7 0 Td(-)Tj
0.00320778 Tc
-420.7 -14.4 Td(tionA\(\) is therefore:)Tj
0 Tc
36 -14.4 Td( )Tj
/R40 10 Tf
0 -12.8 Td(prevrawfkt = NULL;)Tj
0 -12 Td(fkt = NULL;)Tj
0 -12 Td(do {)Tj
36 -12 Td(rawfkt = USBFindFunctionA\( prevrawfkt, ptags \); // Get Function )Tj
290.7 -12 Td(reference)Tj
-290.7 -12 Td(if \( prevrawfkt \) {)Tj
36 -12 Td(USBUnlockFunction\( prevrawfkt \); // Unlock previously ex)Tj
336 0 Td(-)Tj
-101.1 -12 Td(amined Function)Tj
-270.9 -12 Td(})Tj
0 -24 Td(if \( rawfkt \) {)Tj
36 -12 Td(fkt = USBClaimFunction\( rawfkt, ourfktref, msgport \); // )Tj
164.7 -12 Td(Claim function and bind to )Tj
0 -12 Td(msg port)Tj
-164.7 -12 Td(if \( fkt \) {)Tj
36 -12 Td(USBUnlockFunction\( rawfkt \); // Unlock Function )Tj
143.1 -12 Td(\(undo lock made by USBFind)Tj
156 0 Td(-)Tj
-156 -12 Td(FunctionA\(\) now that we own )Tj
0 -12 Td(the Function\))Tj
-143.1 -12 Td(break; // Exit loop - Function has been claimed)Tj
-36 -12 Td(} // Function already claimed by other. Keep searching )Tj
67.5 -12 Td(for another Function)Tj
-103.5 -12 Td(})Tj
-36 -12 Td( )Tj
36 -12 Td(prevrawfkt = rawfkt;)Tj
-36 -12 Td(} while \( rawfkt \);)Tj
0 -24 Td(if \( fkt \) {)Tj
36 -12 Td(DoYourStuffWithTheFunction\(\); // Configure and handle the Func)Tj
372 0 Td(-)Tj
-173.1 -12 Td(tion \(driver body\))Tj
-198.9 -12 Td(USBDeclaimFunction\( fkt \); // Declaim Function after use)Tj
-36 -12 Td(} // else do nothing - fall through as we didn't find a suitable )Tj
32.4 -12 Td(Function)Tj
/R6 12 Tf
0.00998113 Tc
-68.4 -28 Td(The above code assumes a message port has already been initialised and is pointed )Tj
0.00467428 Tc
0 -14.4 Td(to by the variable )Tj
/R14 12 Tf
0.00933838 Tc
1 0 0.00000001 1 166.8 177.1 Tm(msgport)Tj
/R6 12 Tf
-0.00759048 Tc
1 0 0 1 210.2 177.1 Tm(, and that )Tj
/R14 12 Tf
0.0120053 Tc
1 0 0.00000001 1 263.5 177.1 Tm(ptags)Tj
/R6 12 Tf
0.00580673 Tc
1 0 0 1 292.9 177.1 Tm( points to a TagItem array holding proper)Tj
0 Tc
217 0 Td(-)Tj
0.00121786 Tc
-437.9 -14.4 Td(ties of the required USB Function type. The )Tj
/R14 12 Tf
-0.00576994 Tc
1 0 0.00000001 1 305.5 162.7 Tm(ourfktref )Tj
/R6 12 Tf
0.0134174 Tc
1 0 0 1 352.8 162.7 Tm(variable is an any)Tj
0 Tc
93.6 0 Td(-)Tj
0.0075573 Tc
-374.4 -14.4 Td(thing-but-NULL-goes value which the USB stack will give the FD as a reference in )Tj
0.00467428 Tc
0 -14.4 Td(notification messages sent to the message port given in USBClaimFunction\(\). It )Tj
0.00464884 Tc
0 -14.4 Td(could be the UsbFunction reference, it could a pointer to an FD-private structure )Tj
0.000271044 Tc
0 -14.4 Td(holding USB Function related data, it could be a constant - it's your choice.)Tj
ET Q
Q
endstream
endobj
46 0 obj
3651
endobj
44 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 45 0 R
>>
endobj
48 0 obj
<</Length 49 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00385565 Tc
1 0 0 1 72 760.3 Tm(Once claimed the FD has ownership of the Function it wants to control, and a Usb)Tj
0 Tc
434.5 0 Td(-)Tj
0.00107422 Tc
-434.5 -14.4 Td(Function reference for use in further calls to the USB stack.)Tj
/R6 20 Tf
0.00134277 Tc
0 -35.2 Td(Getting to know your USB Target)Tj
/R6 18 Tf
-0.00452978 Tc
0 -22.4 Td(Introduction)Tj
/R6 12 Tf
0.000320633 Tc
0 -16.8 Td(When an FD has found its USB Target, it knows who to communicate with. But it )Tj
-0.000233478 Tc
0 -14.4 Td(does not know about the properties of its Target, other than the fact that the FD be)Tj
0 Tc
436.9 0 Td(-)Tj
0.00745841 Tc
-436.9 -14.4 Td(lieves it can handle the Target based on vendor/product/class information.)Tj
0.0010545 Tc
0 -14.4 Td(It is now time to find out more about the just aquired USB Target.)Tj
/R6 18 Tf
-0.00398486 Tc
0 -33.6 Td(Getting to know your USB Interface)Tj
/R6 12 Tf
0.00212851 Tc
0 -16.8 Td(With USBFindInterfaceA\(\) the FD has found an Interface which suits its basic needs. )Tj
-0.00951172 Tc
0 -14.4 Td(Now it's time to get to know that Interface better.)Tj
0.00410593 Tc
0 -28.8 Td(Each USB Interface contains a descriptor which describes the properties of that In)Tj
0 Tc
435.2 0 Td(-)Tj
0.000658967 Tc
-435.2 -14.4 Td(terface, as well as the EndPoints it consists of. This descriptor, or rather list of de)Tj
0 Tc
428.9 0 Td(-)Tj
0.00393731 Tc
-428.9 -14.4 Td(scriptors, is obtained by calling USBIntGetAltSettingA\(\).)Tj
0.00362578 Tc
0 -14.4 Td(The list of descriptors you now have, contains descriptors for the Interface and all )Tj
0.00678352 Tc
0 -14.4 Td(EndPoints belonging to it. There may also be other descriptors in the list, depending )Tj
-0.00116936 Tc
0 -14.4 Td(on the class specification for the Interface class. So don't be alarmed if you stuble )Tj
0.00183105 Tc
0 -14.4 Td(upon something you don't recognize in the descriptor list.)Tj
0.00474793 Tc
0 -14.4 Td(What you now have to do is traverse the descriptor list using USBNextDescriptor\(\) )Tj
0.00814855 Tc
0 -14.4 Td(and collect the information you need. Normally this will be extracting information on )Tj
0.00415491 Tc
0 -14.4 Td(the Interface, when you come across the Interface Descriptor, and determine which )Tj
0.00854822 Tc
0 -14.4 Td(EndPoints you will be using, when passing EndPoint Descriptors in the list.)Tj
0.00556302 Tc
0 -28.8 Td(The following code snippet will traverse the descriptor list of an Interface, and identify )Tj
0.00339906 Tc
0 -14.4 Td(the Interface descriptor, as well as EndPoints.)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct USBBusDscHead *dsclist; // Configuration descriptor list ptr)Tj
0 -12 Td(struct USBBusDscHead *dsc; // A descriptor in the cfg list)Tj
0 -12 Td(// ...)Tj
0 -12 Td(dsclist = USBIntGetAltSettingA\( openreq, ifc, NULL \); // Get Inter)Tj
396 0 Td(-)Tj
-84.6 -12 Td(face info.)Tj
-311.4 -12 Td(dsc = dsclist; // Init traversal)Tj
0 -12 Td(while \( dsc \) {)Tj
36 -12 Td(puts\( " Descriptor\\n" \);)Tj
0 -12 Td(printf\( "  ∑ Type: %ld\\n", \(ULONG\) dsc->dh_Type \);)Tj
0 -12 Td(printf\( "  ∑ Length: %ld\\n", \(ULONG\) dsc->dh_Length \);)Tj
-36 -12 Td( )Tj
36 -12 Td(if \( dsc->dh_Type == USBDESC_INTERFACE \) {)Tj
36 -12 Td(puts\( "It's the Interface descriptor!" \);)Tj
-36 -12 Td(})Tj
0 -12 Td(if \( dsc->dh_Type == USBDESC_ENDPOINT \) {)Tj
36 -12 Td(printf\( "It's the descriptor for EndPoint %ld\\n", \(ULONG\) )Tj
48.6 -12 Td(\(\(struct USBBusEPDsc *\) dsc\)->ed_Address \);)Tj
-84.6 -12 Td(})Tj
-36 -12 Td( )Tj
36 -12 Td(dsc = USBNextDescriptor\( dsc \); // Get next descriptor)Tj
ET Q
Q
endstream
endobj
49 0 obj
3629
endobj
47 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 48 0 R
>>
endobj
51 0 obj
<</Length 52 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 108 761.9 Tm(})Tj
0 -12 Td(// ...)Tj
0 -12 Td(USBFreeDescriptors\( dsclist \); // Free Interface descriptor list af)Tj
402 0 Td(-)Tj
-197.7 -12 Td(ter use)Tj
/R6 12 Tf
0.000436692 Tc
-240.3 -28 Td(Note that the descriptor list returned by USBIntGetAltSettingA\(\) is a copy of the cur)Tj
0 Tc
438.9 0 Td(-)Tj
-0.00489807 Tc
-438.9 -14.4 Td(rent configuration of the Interface. Once you've inspected the descriptors and don't )Tj
0.00574615 Tc
0 -14.4 Td(need them anymore, they must be freed by calling USBFreeDescriptors\(\).)Tj
/R6 18 Tf
-0.00386047 Tc
0 -33.6 Td(Getting to know your USB Function)Tj
/R6 16 Tf
-0.000631714 Tc
0 -20 Td(Read the Device Descriptor)Tj
/R6 12 Tf
0.00376616 Tc
0 -16 Td(At this point you have a UsbFunction which you know fits the search criteria set in )Tj
0.00261985 Tc
0 -14.4 Td(USBFindFunctionA\(\). But you may want to know more about the USB Function )Tj
-0.010057 Tc
0 -14.4 Td(you're about to take control of.)Tj
0.00586789 Tc
0 -28.8 Td(Each USB Function hold in it a descriptor which describe its basic properties. This is )Tj
0.00722634 Tc
0 -14.4 Td(the Device Descriptor. The Device Descriptor is obtained from a UsbFunction by call)Tj
0 Tc
447.4 0 Td(-)Tj
0.000641672 Tc
-447.4 -14.4 Td(ing USBEPGetDescriptorA\(\). USBEPGetDescriptorA\(\) is a USB stack API call for )Tj
0.00583002 Tc
0 -14.4 Td(reading single USB descriptors from a USB Function. Due to its general use some )Tj
0.00316667 Tc
0 -14.4 Td(control arguments must be set correctly to read a Device Descriptor. Further more )Tj
0.00510261 Tc
0 -14.4 Td(you will have to specify which UsbEndPoint to read the descriptor from. For a Device )Tj
0.00800817 Tc
0 -14.4 Td(Descriptor this will always be EndPoint 0 \(the Default Control Pipe\).)Tj
-0.00111426 Tc
0 -14.4 Td(We've not dealt with finding EndPoints yet, so just accept that the code snippet be)Tj
0 Tc
434.8 0 Td(-)Tj
0.00758763 Tc
-434.8 -14.4 Td(low uses EndPoint 0.)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct USBBusDevDsc)Tj
144 0 Td(*devdsc;)Tj
-144 -12 Td( )Tj
0 -12 Td(/)Tj
6 0 Td(/ Get the device descriptor)Tj
-6 -12 Td(devdsc = \(struct USBBusDevDsc *\) USBEPGetDescriptorA\( ioreq,)Tj
144 -12 Td(USBGetEndPoint\( fkt, NULL, 0 \),)Tj
0 -12 Td(USBSDT_TYP_STANDARD | USBSDT_REC_DEVICE,)Tj
0 -12 Td(USBDESC_DEVICE, 0, NULL \);)Tj
-144 -12 Td(if \( devdsc \) {)Tj
36 -12 Td(// .. do your examination / information extraction)Tj
-36 -12 Td( )Tj
36 -12 Td(// Cleanup after use)Tj
0 -12 Td(USBFreeDescriptors\( \(struct USBBusDscHead *\) devdsc \);)Tj
-36 -12 Td(})Tj
0 -12 Td(// ...)Tj
/R6 12 Tf
0.00522953 Tc
-36 -28 Td(Here it is assumed that the variable )Tj
/R14 12 Tf
-0.0359859 Tc
1 0 0.00000001 1 263.6 203.5 Tm(fkt)Tj
/R6 12 Tf
0.00435572 Tc
1 0 0 1 276.2 203.5 Tm( is the claimed UsbFunction the FD is going to )Tj
-0.00153057 Tc
-204.2 -14.4 Td(use, and that )Tj
/R14 12 Tf
0.0310059 Tc
1 0 0.00000001 1 144.7 189.1 Tm(ioreq)Tj
/R6 12 Tf
0.00829912 Tc
1 0 0 1 171.5 189.1 Tm( is a USBIOReq request previously allocated with USBAllo)Tj
0 Tc
309.9 0 Td(-)Tj
0.00203935 Tc
-409.4 -14.4 Td(cReqeustA\(\) - something we'll go into more detail with later on.)Tj
/R6 16 Tf
-0.00265866 Tc
0 -32 Td(Configure the Function)Tj
/R6 12 Tf
0.00515785 Tc
0 -16 Td(Now the FD knows about the Function it has obtained. However, it still knows noth)Tj
0 Tc
436.6 0 Td(-)Tj
0.00405484 Tc
-436.6 -14.4 Td(ing about the Interfaces contained within the Function. For this information to be ac)Tj
0 Tc
439.9 0 Td(-)Tj
0.0042572 Tc
-439.9 -14.4 Td(cessible, the FD needs to configure the Function.)Tj
0.00229397 Tc
0 -14.4 Td(At this point in time the UsbFunction may or may not be configured by the USB )Tj
ET Q
Q
endstream
endobj
52 0 obj
3748
endobj
50 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 51 0 R
>>
endobj
54 0 obj
<</Length 55 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00641691 Tc
1 0 0 1 72 760.3 Tm(stack, so from a FD perspective a newly obtained UsbFunction is always unconfig)Tj
0 Tc
434 0 Td(-)Tj
0.00487812 Tc
-434 -14.4 Td(ured. Never expect the Function to be configured, and never trust an already se)Tj
0 Tc
422.6 0 Td(-)Tj
0.00214064 Tc
-422.6 -14.4 Td(lected configuration. It is as simple as that.)Tj
0.0101278 Tc
0 -28.8 Td(Selecting a configuration implies reading the available configurations from the USB )Tj
0.00554213 Tc
0 -14.4 Td(Function, and then selecting a suitable one. This is generally a tricky job, and often )Tj
0.00832849 Tc
0 -14.4 Td(you will find yourself selecting configuration 0, or a pre-specified configuration from )Tj
0.00727927 Tc
0 -14.4 Td(the specification of the device you are going to handle.)Tj
0.00317867 Tc
0 -28.8 Td(A single configuration consists of a list of USB descriptors read from the USB Func)Tj
0 Tc
439.1 0 Td(-)Tj
0.00518332 Tc
-439.1 -14.4 Td(tion. This list holds a configuration descriptor, followed by any number of Interface )Tj
0.00664055 Tc
0 -14.4 Td(descriptors and EndPoint descriptors, as well as some device specific descriptors. )Tj
0.00654304 Tc
0 -14.4 Td(Each configuration has an ID number which sets it apart from other possible configu)Tj
0 Tc
445.4 0 Td(-)Tj
0.00248156 Tc
-445.4 -14.4 Td(rations in the USB Function. These IDs range from zero and up to the maximum )Tj
0.00755454 Tc
0 -14.4 Td(number of possible configurations in the USB Function.)Tj
0.00543987 Tc
0 -14.4 Td(The list of descriptors is obtained from the UsbFunction by calling )Tj
0.00130844 Tc
0 -14.4 Td(USBFktGetCfgDescriptorsA\(\). You specify the UsbFunction as well as the ID of the )Tj
0.00391572 Tc
0 -14.4 Td(configuration you whish to inspect, and receive the first USB descriptor in the list of )Tj
0.00856444 Tc
0 -14.4 Td(descriptors which make up the configuration.)Tj
0.00701942 Tc
0 -14.4 Td(Using USBNextDescriptor\(\)/USBPrevDescriptor\(\) calls you can now traverse the list )Tj
0.0083968 Tc
0 -14.4 Td(and inspect which Interfaces and EndPoints are available in that specific configura)Tj
0 Tc
436.9 0 Td(-)Tj
0.00501108 Tc
-436.9 -14.4 Td(tion.)Tj
0.00588499 Tc
0 -14.4 Td(One EndPoint you will never find, however, is EndPoint 0. This EndPoint is always )Tj
0.00809379 Tc
0 -14.4 Td(available and is not part of any configuration.)Tj
0.00535841 Tc
0 -28.8 Td(The descriptor pointers returned by USBFktGetCfgDescriptorsA\(\), USBNextDescrip)Tj
0 Tc
443.2 0 Td(-)Tj
0.00475769 Tc
-443.2 -14.4 Td(tor\(\) and USBPrevDescriptor\(\) all starts with a USBBusDscHead structure. By evalu)Tj
0 Tc
444.5 0 Td(-)Tj
0.00567336 Tc
-444.5 -14.4 Td(ating the dh_Type field you can find the type of descriptor, and dh_Length specifies )Tj
0.00480695 Tc
0 -14.4 Td(the byte size of the descriptor, including the USBBusDscHead structure.)Tj
0.0102346 Tc
0 -14.4 Td(The following example program will dump the dh_Type value of all descriptors in )Tj
0.0104506 Tc
0 -14.4 Td(configuration zero.)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct USBBusDscHead *dsclist; // Configuration descriptor list ptr)Tj
0 -12 Td(struct USBBusDscHead *dsc; // A descriptor in the cfg list)Tj
0 -12 Td(// ...)Tj
0 -12 Td(dsclist = USBFktGetCfgDescriptorsA\( openreq, fkt, 0, NULL \); // Get )Tj
311.4 -12 Td(configuration.)Tj
-311.4 -12 Td(dsc = dsclist; // Init traversal)Tj
0 -12 Td(while \( dsc \) {)Tj
36 -12 Td(puts\( " Descriptor\\n" \);)Tj
0 -12 Td(printf\( "  ∑ Type: %ld\\n", \(ULONG\) dsc->dh_Type \);)Tj
0 -12 Td(printf\( "  ∑ Length: %ld\\n", \(ULONG\) dsc->dh_Length \);)Tj
0 -12 Td( )Tj
0 -12 Td(dsc = USBNextDescriptor\( dsc \); // Get next descriptor)Tj
-36 -12 Td(})Tj
0 -12 Td(// ...)Tj
0 -12 Td(USBFreeDescriptors\( dsclist \); // Free configuration descriptor list )Tj
204.3 -12 Td(after use)Tj
/R6 12 Tf
0.00429599 Tc
-240.3 -28 Td(Note that the above example finishes off by freeing the descriptor list returned by )Tj
ET Q
Q
endstream
endobj
55 0 obj
3983
endobj
53 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 54 0 R
>>
endobj
57 0 obj
<</Length 58 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00154701 Tc
1 0 0 1 72 760.3 Tm(USBFktGetCfgDescriptorsA\(\).)Tj
0.00818048 Tc
0 -14.4 Td(The standard dh_Type values are defined in the usb/usb.h include file.)Tj
0.00540619 Tc
0 -28.8 Td(When you have found \(or chosen\) the configuration to use, you are ready to config)Tj
0 Tc
438 0 Td(-)Tj
0.00360378 Tc
-438 -14.4 Td(ure the USB Function. This is done using the USBSetFktConfigurationA\(\) API call:)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(if \( USBSetFktConfigurationA\( ioreq, fkt, cfgdsc, NULL \) == )Tj
29.7 -12 Td(USBSETCONFIG_OK \) {)Tj
6.30002 -12 Td(// Fkt is configured - Interfaces and EndPoints are available.)Tj
-36 -12 Td(})Tj
0 -12 Td(else {)Tj
36 -12 Td(// Something went wrong - can't use Fkt as it is not)Tj
0 -12 Td(//)Tj
12 0 Td( properly configured)Tj
-48 -12 Td(})Tj
0 -12 Td(// ...)Tj
/R6 12 Tf
0.00862745 Tc
-36 -28 Td(In the above code ioreq is a USBIOReq request allocated using USBAllocRe)Tj
0 Tc
406.8 0 Td(-)Tj
0.00107734 Tc
-406.8 -14.4 Td(questA\(\), fkt is the Function the FD controls, and cfgdsc is a pointer to the Configura)Tj
0 Tc
446.3 0 Td(-)Tj
0.0038176 Tc
-446.3 -14.4 Td(tion Descriptor of the configuration to use in the USB Function.)Tj
/R6 16 Tf
-0.0225844 Tc
0 -32 Td(Get the Interfaces)Tj
/R6 12 Tf
0.00476654 Tc
0 -16 Td(The Function has now been configured, and the USB stack has prepared itself for )Tj
0.00880682 Tc
0 -14.4 Td(handling the Function using that specific configuration.)Tj
0.00179515 Tc
0 -14.4 Td(What you do not yet have, is access to the Interfaces contained in the configuration, )Tj
-0.000775213 Tc
0 -14.4 Td(or access to the EndPoints of those Interfaces.)Tj
0.00715675 Tc
0 -14.4 Td(When selecting a suitable Function configuration the FD has traversed the descrip)Tj
0 Tc
436.1 0 Td(-)Tj
0.00415764 Tc
-436.1 -14.4 Td(tors in the configuration. The FD thus also knows which Interfaces and EndPoints )Tj
0.00203103 Tc
0 -14.4 Td(are available. So all it has to do is to gain access to the Interfaces, and thru them )Tj
0.00703389 Tc
0 -14.4 Td(gain access to the EndPoints required.)Tj
0.0032845 Tc
0 -28.8 Td(The Interfaces of the newly configured Function is found thru the Function based FD )Tj
0.000123378 Tc
0 -14.4 Td(specific API call USBGetInterface\(\).)Tj
0.00223004 Tc
0 -14.4 Td(USBGetInterface\(\) will return a UsbInterface for the requested Interface in a Func)Tj
0 Tc
431.7 0 Td(-)Tj
0.000771855 Tc
-431.7 -14.4 Td(tion. It is important to note that it is a claimed Interface which is returned. Therefore )Tj
0.00572842 Tc
0 -14.4 Td(the Interface must be declaimed using USBDeclaimInterface\(\) once the FD is done )Tj
0.0060091 Tc
0 -14.4 Td(using it.)Tj
0.000193396 Tc
0 -28.8 Td(Let us assume the FD has identified a specific Interface that it wants to use from the )Tj
0.0100761 Tc
0 -14.4 Td(Function held in the variable )Tj
/R14 12 Tf
-0.0359859 Tc
1 0 0.00000001 1 225.7 217.9 Tm(fkt)Tj
/R6 12 Tf
-0.000596532 Tc
1 0 0 1 238.3 217.9 Tm(. And let us assume that a pointer to the Interface de)Tj
0 Tc
278.8 0 Td(-)Tj
0.00539863 Tc
-445.1 -14.4 Td(scriptor is held in the )Tj
/R14 12 Tf
0.0056057 Tc
1 0 0.00000001 1 185.5 203.5 Tm(ifcdsc)Tj
/R6 12 Tf
0.00765065 Tc
1 0 0 1 216.2 203.5 Tm( variable. Then the following code snippet will get that )Tj
0.0023464 Tc
-144.2 -14.4 Td(specfic Interface, use it for something, and clean up:)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct UsbInterface)Tj
144 0 Td(*ifc;)Tj
-144 -24 Td(if \( ifc = USBGetInterface\( fkt, ifcdsc->id_InterfaceID \) \) {)Tj
36 -12 Td(// .. let's do something here. This would propably be)Tj
0 -12 Td(// .. )Tj
36 0 Td(the driver body or something similar.)Tj
-36 -12 Td( )Tj
0 -12 Td(puts\( "Got the Interface" \);)Tj
ET Q
Q
endstream
endobj
58 0 obj
3772
endobj
56 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 57 0 R
>>
endobj
60 0 obj
<</Length 61 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 144 749.9 Tm(// Now we're done, and declaim the Interface)Tj
0 -12 Td(USBDeclaimInterface\( ifc \);)Tj
-36 -12 Td(})Tj
0 -12 Td(else {)Tj
36 -12 Td(puts\( "Darn! The Interface does not exist in the Function af)Tj
360 0 Td(-)Tj
-321.3 -12 Td(terall!" \);)Tj
-74.7 -12 Td(})Tj
0 -12 Td(// ...)Tj
/R6 18 Tf
-0.00548267 Tc
-36 -32.8 Td(Get the EndPoints)Tj
/R6 12 Tf
0.00476982 Tc
0 -16.8 Td(Regardless of wether the FD is Interface or Function based it will need EndPoints to )Tj
0.00446848 Tc
0 -14.4 Td(be able to do any communication over the USB bus. Functions and Interfaces them)Tj
0 Tc
441.9 0 Td(-)Tj
0.00564298 Tc
-441.9 -14.4 Td(selves are just means by which to group and classify the EndPoints.)Tj
0.00603268 Tc
0 -28.8 Td(An Interface based FD finds out which EndPoints it needs while examining the Inter)Tj
0 Tc
442.7 0 Td(-)Tj
0.00580044 Tc
-442.7 -14.4 Td(face descriptor list, as explained earlier in this guide. A Function based FD finds out )Tj
0.00934056 Tc
0 -14.4 Td(which EndPoints it needs while examining the entire Configuration descriptor list of )Tj
0.00409031 Tc
0 -14.4 Td(the configuration it has chosen for the Function.)Tj
0.00704405 Tc
0 -14.4 Td(In either case, the FD already knows which EndPoints it will be needing, as well as )Tj
0.00454451 Tc
0 -14.4 Td(which Interfaces are holding those EndPoints. What the FD needs to do now, is gain )Tj
0.00276514 Tc
0 -14.4 Td(acces to those EndPoints. This is done using the API call USBGetEndPoint\(\).)Tj
0.00631362 Tc
0 -28.8 Td(Let us assume the variable )Tj
/R14 12 Tf
0.0210018 Tc
1 0 0.00000001 1 218.9 443.5 Tm(epdsc)Tj
/R6 12 Tf
0.00416213 Tc
1 0 0 1 251 443.5 Tm( points to an EndPoint descriptor for an EndPoint in )Tj
-0.00337689 Tc
-179 -14.4 Td(the Interface )Tj
/R14 12 Tf
0.00001240 Tc
1 0 0.00000001 1 142 429.1 Tm(ifc)Tj
/R6 12 Tf
0.00443704 Tc
1 0 0 1 154 429.1 Tm(. Then the following code will get that EndPoint for use:)Tj
/R40 10 Tf
0 Tc
-46 -27.2 Td(// ...)Tj
0 -12 Td(ep = USBGetEndPoint\( NULL, ifc, epdsc->ed_Address \);)Tj
0 -12 Td(if \( ep \) {)Tj
36 -12 Td(puts\( "We got the EndPoint!" \);)Tj
-36 -12 Td(})Tj
0 -12 Td(else {)Tj
36 -12 Td(puts\( "The EndPoint does not exist!" \);)Tj
-36 -12 Td(})Tj
0 -12 Td(// ...)Tj
/R6 12 Tf
0.00349604 Tc
-36 -28 Td(One thing which is important to note here is, that there is no cleanup after using the )Tj
0.00557069 Tc
0 -14.4 Td(EndPoint. EndPoints are not lockable resources - they live in the belly of their parent )Tj
-0.000372387 Tc
0 -14.4 Td(USB Interface or Function, and follow the locking of that: If you own the Interface, )Tj
0.00142204 Tc
0 -14.4 Td(you also have acces to the EndPoints of the Interface. The same goes for EndPoints )Tj
0.00600751 Tc
0 -14.4 Td(in Functions.)Tj
0.00405484 Tc
0 -14.4 Td(One thing to be very carefull about, though, is that changing the configuration of a )Tj
0.00337368 Tc
0 -14.4 Td(Function or an Interface will change the use of EndPoints in that Function or Inter)Tj
0 Tc
430.5 0 Td(-)Tj
0.00248428 Tc
-430.5 -14.4 Td(face. The result of this is that all EndPoints previously obtained by the FD from USB)Tj
0 Tc
444.4 0 Td(-)Tj
0.00499471 Tc
-444.4 -14.4 Td(GetEndPoint\(\) are obsoleted at the moment the FD either changes the configuration )Tj
0.00057935 Tc
0 -14.4 Td(of a Function, or changes the Alternate Setting of an Interface.)Tj
0.00270614 Tc
0 -14.4 Td(However, if your FD does not change the configuration of its Function or Interface, )Tj
0.00511012 Tc
0 -14.4 Td(you need not worry about this.)Tj
0.0044518 Tc
0 -28.8 Td(A common source of problems when trying to find an EndPoint is to belive that you )Tj
ET Q
Q
endstream
endobj
61 0 obj
3688
endobj
59 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R6 6 0 R
>>
>>
/Contents 60 0 R
>>
endobj
63 0 obj
<</Length 64 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00365245 Tc
1 0 0 1 72 760.3 Tm(can just request a predefined EndPoint number. However, normally you'll have to )Tj
0.00595874 Tc
0 -14.4 Td(search thru the EndPoint descriptors to find a suitable EndPoint based on EndPoint )Tj
0.00385642 Tc
0 -14.4 Td(properties. Once found you get the EndPoint number to use with USBGetEndPoint\(\) )Tj
0.00448354 Tc
0 -14.4 Td(from ed_Address of the EndPoint descriptor.)Tj
0.00572803 Tc
0 -14.4 Td(Should you try to get your EndPoints by hardcoded number anyhow, e.g. because a )Tj
0.0044518 Tc
0 -14.4 Td(device specification actually calls for this, you must remember that the EndPoint )Tj
0.00815113 Tc
0 -14.4 Td(number you supply, is in fact the value which would be found in an ed_Address field )Tj
0.00284316 Tc
0 -14.4 Td(of a descriptor for the EndPoint. That is, the EndPoint number and any extended )Tj
-0.00054245 Tc
0 -14.4 Td(flags which may be set for the EndPoint in ed_Address. For example, if you're in )Tj
0.00339254 Tc
0 -14.4 Td(need of the OUT \(write\) version of EndPoint 1 you would ask for EndPoint 0x01. )Tj
0.00670738 Tc
0 -14.4 Td(Should you need the IN \(read\) version of EndPoint 1 you would instead ask for End)Tj
0 Tc
442.1 0 Td(-)Tj
0.00493782 Tc
-442.1 -14.4 Td(Point 0x81. The difference between the two lies in the direction bit of the ed_Address )Tj
0.011211 Tc
0 -14.4 Td(field.)Tj
0.00224772 Tc
0 -28.8 Td(Just because the USB system sees IN and OUT dataflows as separate EndPoints )Tj
-0.000236325 Tc
0 -14.4 Td(doesn't mean that EndPoints come in pairs. You may very well have only the IN part )Tj
-0.000990974 Tc
0 -14.4 Td(of a given EndPoint, or the OUT part.)Tj
0.00492363 Tc
0 -14.4 Td(This is, however, not true for Control EndPoints due to their bidirectional nature. )Tj
0.00981685 Tc
0 -14.4 Td(Control EndPoints are always bidirectional, and consist of a single EndPoint capable )Tj
0.00948871 Tc
0 -14.4 Td(of both reading and writing.)Tj
ET Q
Q
endstream
endobj
64 0 obj
1993
endobj
62 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 63 0 R
>>
endobj
66 0 obj
<</Length 67 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 20 Tf
-0.00665848 Tc
1 0 0 1 72 753.9 Tm(Talking with your USB Target)Tj
/R6 18 Tf
-0.00452978 Tc
0 -22.4 Td(Introduction)Tj
/R6 12 Tf
0.00785637 Tc
0 -16.8 Td(The previous sections have described how to find, examine and configure your USB )Tj
0.00363123 Tc
0 -14.4 Td(Target. All that is just groundwork building up to the real task of an FD, namely talk)Tj
0 Tc
438.5 0 Td(-)Tj
0.00248901 Tc
-438.5 -14.4 Td(ing with the USB Target and get it to do something.)Tj
0.00457177 Tc
0 -14.4 Td(This section will go thru the various ways to communicate with your USB Target.)Tj
/R6 18 Tf
-0.00374634 Tc
0 -33.6 Td(Basics of transfering data)Tj
/R6 16 Tf
-0.000325521 Tc
0 -20 Td(Allocating IO)Tj
/R6 12 Tf
0.00279217 Tc
0 -16 Td(The USB stack is designed as an Exec device. What this basically means is, that )Tj
0.00400711 Tc
0 -14.4 Td(you use Exec-style IO request passing for USB communication.)Tj
-0.00218496 Tc
0 -28.8 Td(Due to the nature of the USB stack it is not sufficient to use )Tj
/R14 12 Tf
-0.00239258 Tc
1 0 0.00000001 1 388.7 558.7 Tm(struct IORequest)Tj
/R6 12 Tf
0.00100708 Tc
1 0 0 1 478.7 558.7 Tm( or even )Tj
/R14 12 Tf
-0.00484794 Tc
1 0 0.00000001 1 72 544.3 Tm(struct IOStdReq)Tj
/R6 12 Tf
0.00352956 Tc
1 0 0 1 157.3 544.3 Tm( requests with the USB stack. More information than can be given in )Tj
-0.000522108 Tc
-85.3 -14.4 Td(these IO request types is needed for IO to find its destination on the USB bus. The )Tj
0.00306019 Tc
0 -14.4 Td(USB stack therefore introduces its own )Tj
/R14 12 Tf
-0.00198964 Tc
1 0 0.00000001 1 282.2 515.5 Tm(struct USBIOReq)Tj
/R6 12 Tf
-0.00383179 Tc
1 0 0 1 374.2 515.5 Tm( IO request. This request )Tj
0.000531514 Tc
-302.2 -14.4 Td(type must be used for any interaction with the USB stack which involves IO. That is, )Tj
0.00555725 Tc
0 -14.4 Td(when doing Exec IO operations directly with usbsys.device, or when using USB API )Tj
0.00503227 Tc
0 -14.4 Td(calls which maps to IO operations. The usbsys.device API documentation clearly )Tj
-0.00220249 Tc
0 -14.4 Td(states which API functions performs IO.)Tj
0.00196296 Tc
0 -14.4 Td(One very important aspect to be aware of with )Tj
/R14 12 Tf
0.00687081 Tc
1 0 0.00000001 1 320.2 443.5 Tm(USBIOReq)Tj
/R6 12 Tf
-0.00415222 Tc
1 0 0 1 379.6 443.5 Tm( requests is the fact that)Tj
/R13 12 Tf
-0.00595507 Tc
-271.6 -28.8 Td(you must never build your own USBIOReq structures in memory.)Tj
/R6 12 Tf
0.00286585 Tc
-36 -28.8 Td(It is a simple rule, and it must be followed. All )Tj
/R14 12 Tf
0.00687081 Tc
1 0 0.00000001 1 314.9 385.9 Tm(USBIOReq)Tj
/R6 12 Tf
0.000154283 Tc
1 0 0 1 374.3 385.9 Tm( structures must instead be )Tj
0.00513673 Tc
-302.3 -14.4 Td(allocated using the USB stack API call USBAllocRequestA\(\). This is the only sup)Tj
0 Tc
427.9 0 Td(-)Tj
0.00417391 Tc
-427.9 -14.4 Td(ported way of creating a )Tj
/R14 12 Tf
0.00687081 Tc
1 0 0.00000001 1 203.5 357.1 Tm(USBIOReq)Tj
/R6 12 Tf
-0.00519295 Tc
1 0 0 1 262.9 357.1 Tm( structure.)Tj
0.00610733 Tc
-190.9 -14.4 Td("Why", you ask? Because your driver will fail miserably otherwise. The USB stack )Tj
0.00800627 Tc
0 -14.4 Td(needs internal resource tracking to be able to correctly handle untimely detachment )Tj
0.00232875 Tc
0 -14.4 Td(of USB devices. Some of this tracking includes pending IO, so the USB stack needs )Tj
0.00742404 Tc
0 -14.4 Td(a private data area to be allocated along with a )Tj
/R14 12 Tf
0.00687081 Tc
1 0 0.00000001 1 324.5 299.5 Tm(USBIOReq)Tj
/R6 12 Tf
0 Tc
1 0 0 1 383.9 299.5 Tm(.)Tj
0.00400854 Tc
-311.9 -14.4 Td(When your FD is done with a )Tj
/R14 12 Tf
0.00687081 Tc
1 0 0.00000001 1 229.5 285.1 Tm(USBIOReq)Tj
/R6 12 Tf
0.00548152 Tc
1 0 0 1 288.9 285.1 Tm( it must be disposed of using USBFreeRe)Tj
0 Tc
220.3 0 Td(-)Tj
0.00286375 Tc
-437.2 -14.4 Td(quest\(\).)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(struct IORequest)Tj
108 0 Td(*usbopenreq;)Tj
-108 -12 Td(struct USBIOReq)Tj
108 0 Td(*usbio;)Tj
-108 -24 Td(// Allocate IORequest for <usbopenreq>, and open usbsys.device with )Tj
18 -12 Td(it here)Tj
-18 -12 Td(// ...)Tj
0 -24 Td(if \( usbio = USBAllocRequestA\( usbopenreq, NULL \) \) {)Tj
36 -12 Td(// .. good to go ..)Tj
0 -12 Td(// ...)Tj
0 -24 Td(USBFreeRequest\( usbio \);)Tj
-36 -12 Td(})Tj
ET Q
Q
endstream
endobj
67 0 obj
4262
endobj
65 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R14 14 0 R
/R13 13 0 R
/R6 6 0 R
>>
>>
/Contents 66 0 R
>>
endobj
69 0 obj
<</Length 70 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 108 761.9 Tm(// ...)Tj
0 -12 Td(// Close usbsys.device and free <usbopenreq>)Tj
/R6 16 Tf
-0.00665937 Tc
-36 -45.6 Td(The USBIOReq structure)Tj
/R6 12 Tf
0.00215484 Tc
0 -16 Td(The USBIOReq structure itself is defined in the include file "usb/system.h". It is )Tj
0.00454794 Tc
0 -14.4 Td(based on a standard Exec IOStdReq, but has been extended with USB specific )Tj
0.00161708 Tc
0 -14.4 Td(fields. We'll go thru the individual structure fields now, and then get into using them )Tj
0.00480728 Tc
0 -14.4 Td(afterwards.)Tj
/R40 10 Tf
0 Tc
40.5 -27.2 Td(struct USBIOReq {)Tj
21.6 -12 Td(// *** IOStdReq structure)Tj
0 -12 Td(struct  Message)Tj
117 0 Td(io_Message;)Tj
-117 -12 Td(struct  Device)Tj
117 0 Td(*io_Device;)Tj
-117 -12 Td(struct  Unit)Tj
117 0 Td(*io_Unit;)Tj
-117 -12 Td(UWORD)Tj
117 0 Td(io_Command;)Tj
-117 -12 Td(UBYTE)Tj
117 0 Td(io_Flags;)Tj
-117 -12 Td(BYTE)Tj
117 0 Td(io_Error;)Tj
-117 -12 Td(ULONG)Tj
117 0 Td(io_Actual;)Tj
-117 -12 Td(ULONG)Tj
117 0 Td(io_Length;)Tj
-117 -12 Td(APTR)Tj
117 0 Td(io_Data;)Tj
-117 -12 Td(ULONG)Tj
117 0 Td(io_Offset;)Tj
-117 -12 Td(// *** USB Extension)Tj
0 -12 Td(struct UsbEndPoint)Tj
117 0 Td(*io_EndPoint;)Tj
-117 -12 Td(APTR)Tj
117 0 Td(io_SetupData;)Tj
-117 -12 Td(ULONG)Tj
117 0 Td(io_SetupLength;)Tj
-138.6 -12 Td(};)Tj
/R6 12 Tf
-0.00398763 Tc
-40.5 -28 Td(The )Tj
/R13 12 Tf
0.074674 Tc
24 0 Td(io_Message)Tj
/R6 12 Tf
-0.0719728 Tc
68.7 0 Td(, )Tj
/R13 12 Tf
0.00900841 Tc
6.60002 0 Td(io_Device)Tj
/R6 12 Tf
0.00300932 Tc
56.1 0 Td( and )Tj
/R13 12 Tf
-0.0113201 Tc
26.7 0 Td(io_Unit)Tj
/R6 12 Tf
0.00209843 Tc
40.6 0 Td( fields are off limits, and used by Exec and )Tj
0.00128104 Tc
-222.7 -14.4 Td(the USB stack for general AmigaOS IO passing.)Tj
/R13 12 Tf
0.06579 Tc
0 -28.8 Td(io_Command)Tj
/R6 12 Tf
0.000420514 Tc
76.6 0 Td( is the command to send. At the time of writing the USB stack will re)Tj
0 Tc
359.5 0 Td(-)Tj
0.00741757 Tc
-436.1 -14.4 Td(spond positively to three commands:)Tj
0.0380125 Tc
13.5 -14.4 Td(CMD)Tj
0.023016 Tc
27.4 0 Td(_READ)Tj
0 Tc
116.6 0 Td(-)Tj
0.00250753 Tc
10.8 0 Td(Read data from the target)Tj
0.00501347 Tc
-154.8 -14.4 Td(CMD_WRITE)Tj
0 Tc
144 0 Td(-)Tj
-0.00277378 Tc
10.8 0 Td(Write data to the target)Tj
0.032032 Tc
-154.8 -14.4 Td(NS)Tj
0.0111574 Tc
16.7 0 Td(CMD_DEVICEQUERY)Tj
0 Tc
127.3 0 Td(-)Tj
0.00416626 Tc
10.8 0 Td(Query usbsys.device for its capabilities. This you )Tj
-0.000333096 Tc
0 -14.4 Td(generally won't use as an FD developer. See the )Tj
0.00692431 Tc
0 -14.4 Td(AmigaOS NewStyleDevice documentation for further )Tj
0.00622898 Tc
0 -14.4 Td(information on this request.)Tj
0.00793983 Tc
-168.3 -14.4 Td(All other commands will be failed with a IOERR_NOCMD error.)Tj
/R13 12 Tf
0.0737272 Tc
0 -28.8 Td(io_Flags)Tj
/R6 12 Tf
0.000925033 Tc
49.2 0 Td( are standard Exec IO flags. See Exec documentation for these.)Tj
-0.000376138 Tc
-49.2 -14.4 Td(One thing to note is that the USB stack will not go into Quick IO. All IO will be en)Tj
0 Tc
425.5 0 Td(-)Tj
0.0140047 Tc
-425.5 -14.4 Td(queued and handled in a synchronous manner.)Tj
/R13 12 Tf
0.00287029 Tc
0 -28.8 Td(io_Error)Tj
/R6 12 Tf
0.00192708 Tc
46.7 0 Td( holds the error code of the IO request when it is returned. The error code )Tj
0.000819026 Tc
-46.7 -14.4 Td(set is the merged set of Exec IOERR_ and the USB stack USBERR_ error codes.)Tj
/R13 12 Tf
0.0735106 Tc
0 -28.8 Td(io_Actual)Tj
/R6 12 Tf
-0.00132568 Tc
54.6 0 Td( returns, as always with Exec IO, the actual number of bytes written to, or )Tj
-0.00265866 Tc
-54.6 -14.4 Td(read from, the target.)Tj
ET Q
Q
endstream
endobj
70 0 obj
3622
endobj
68 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R13 13 0 R
/R6 6 0 R
>>
>>
/Contents 69 0 R
>>
endobj
72 0 obj
<</Length 73 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R13 12 Tf
-0.0169859 Tc
1 0 0 1 72 760.3 Tm(io_Length)Tj
/R6 12 Tf
-0.000400465 Tc
57.2 0 Td( is the byte size of the data bufferpointed to by )Tj
0.0246747 Tc
248.8 0 Td(io_Data)Tj
-0.00732295 Tc
41.5 0 Td(. If this field is )Tj
-0.000754583 Tc
-347.5 -14.4 Td(non-zero, then the USB stack can use the io_Data buffer for transfers. If zero, then )Tj
-0.00532214 Tc
0 -14.4 Td(the )Tj
0.0246747 Tc
20 0 Td(io_Data)Tj
0.00679525 Tc
41.5 0 Td( buffer pointer is never followed.)Tj
/R13 12 Tf
0.209342 Tc
-61.5 -28.8 Td(io_Data)Tj
/R6 12 Tf
0.000315348 Tc
44.6 0 Td( is a pointer to the data buffer for the actual transfer. Only if io_Length is )Tj
0.00238002 Tc
-44.6 -14.4 Td(non-zero will this pointer be followed. I.e. data read from, or written to, the buffer.)Tj
/R13 12 Tf
-0.000991821 Tc
0 -28.8 Td(io_Offset)Tj
/R6 12 Tf
0.00000778 Tc
52 0 Td( is private to the USB stack and must be left alone.)Tj
/R13 12 Tf
-0.0207832 Tc
-52 -28.8 Td(io_EndPoint)Tj
/R6 12 Tf
0.000730726 Tc
69.8 0 Td( is the first USB specific IO field. Here you store the UsbEndPoint refer)Tj
0 Tc
374.2 0 Td(-)Tj
0.00528748 Tc
-444 -14.4 Td(ence of the EndPoint you whish to communicate with.)Tj
/R13 12 Tf
0.11092 Tc
0 -28.8 Td(io_SetupData)Tj
/R6 12 Tf
0.00895957 Tc
77.9 0 Td( is a field used sololy when communicating with Control type End)Tj
0 Tc
344.7 0 Td(-)Tj
-0.000980677 Tc
-422.6 -14.4 Td(Points. It points to a data block to use for a Control transfer Setup stage. Keep this to )Tj
0.00000916 Tc
0 -14.4 Td(NULL if you're not talking with a Control EndPoint.)Tj
/R13 12 Tf
-0.0132176 Tc
0 -28.8 Td(io_SetupLength)Tj
/R6 12 Tf
0.000306542 Tc
90.5 0 Td( defines the byte size of the buffer pointed to by io_SetupData. If )Tj
0.00350007 Tc
-90.5 -14.4 Td(there is no io_SetupData buffer for any reason, this field must be zero.)Tj
/R6 18 Tf
-0.00302124 Tc
0 -33.6 Td(Talking with Control EndPoints)Tj
/R6 16 Tf
-0.00218346 Tc
0 -20 Td(Background information on Control EndPoints)Tj
/R6 12 Tf
0.00870036 Tc
0 -16 Td(Before going into details on communicating with Control EndPoints, some back)Tj
0 Tc
419.5 0 Td(-)Tj
0.00794732 Tc
-419.5 -14.4 Td(ground information on this special kind of EndPoint may be in order.)Tj
0.00675468 Tc
0 -14.4 Td(Control EndPoints plays a special role in the USB framework. They handle all \(or at )Tj
0.00846383 Tc
0 -14.4 Td(least most of\) the sideband signalling and housekeeping of the USB bus.)Tj
0.0053402 Tc
0 -14.4 Td(Therefore Control EndPoints has a more complex nature when it comes to the actual )Tj
0.00300751 Tc
0 -14.4 Td(transfers performed on the USB bus for a single IO operation.)Tj
0.00481987 Tc
0 -14.4 Td(A transaction with a Control EndPoint is broken into three steps:)Tj
-0.00798321 Tc
13.5 -28.8 Td(1.)Tj
0.0056076 Tc
12.6 0 Td(Setup stage)Tj
-0.00798321 Tc
-12.6 -14.4 Td(2.)Tj
0.00756285 Tc
12.6 0 Td(Data stage)Tj
-0.00798321 Tc
-12.6 -14.4 Td(3.)Tj
0.0155063 Tc
12.6 0 Td(Acknowledge stage)Tj
-0.00168637 Tc
-26.1 -28.8 Td(Of these three steps, only the first two are of interest for FD developers, but the Ac)Tj
0 Tc
437.4 0 Td(-)Tj
0.0089754 Tc
-437.4 -14.4 Td(knowledge stage is also mentioned here for reasons of completeness.)Tj
-0.00998942 Tc
0 -28.8 Td(In the )Tj
/R13 12 Tf
0.0584106 Tc
33.3 0 Td(Setup stage)Tj
/R6 12 Tf
0.000820637 Tc
68.6 0 Td( a Setup packet is sent to the Control EndPoint. This packet, rep)Tj
0 Tc
340.9 0 Td(-)Tj
0.00625164 Tc
-442.8 -14.4 Td(resented by the struct USBBusSetupData defined in the include file "usb/usb.h", con)Tj
0 Tc
446.6 0 Td(-)Tj
0.00537258 Tc
-446.6 -14.4 Td(tains information about the transfer. This include information such as the command )Tj
0.000150408 Tc
0 -14.4 Td(to perform at the target, the data direction of the Data stage \(read or write data\), )Tj
0.00130104 Tc
0 -14.4 Td(command arguments, number of bytes to transfer in the Data stage etc.)Tj
-0.00998942 Tc
0 -28.8 Td(In the )Tj
/R13 12 Tf
0.212896 Tc
33.3 0 Td(Data stage)Tj
/R6 12 Tf
0.0049448 Tc
62.6 0 Td( data is transfered to or from the Control EndPoint depending on )Tj
0.00158804 Tc
-95.9 -14.4 Td(the content of the Setup data. The Data stage will transfer as much data as was de)Tj
0 Tc
439.7 0 Td(-)Tj
0.00348697 Tc
-439.7 -14.4 Td(fined in the Setup data.)Tj
-0.00322978 Tc
0 -28.8 Td(As the last stage the )Tj
/R13 12 Tf
0.0355101 Tc
112 0 Td(Acknowledge stage)Tj
/R6 12 Tf
0.00273802 Tc
112.6 0 Td( verifies that the transaction was success)Tj
0 Tc
218.2 0 Td(-)Tj
ET Q
Q
endstream
endobj
73 0 obj
4502
endobj
71 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R13 13 0 R
/R6 6 0 R
>>
>>
/Contents 72 0 R
>>
endobj
75 0 obj
<</Length 76 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00564402 Tc
1 0 0 1 72 760.3 Tm(fully carried out. You, as a Function Driver developer will not need to think about this )Tj
0.000357819 Tc
0 -14.4 Td(stage, however, as it is hidden by the USB stack. But now you know that it exist.)Tj
/R6 16 Tf
-0.00434146 Tc
0 -32 Td(Setting up your USBIOReq)Tj
/R6 12 Tf
0.00430037 Tc
0 -16 Td(The special transfer style used on the USB bus for a Control EndPoint, as outlined )Tj
0.00498141 Tc
0 -14.4 Td(above, means that IO concerning a Control EndPoint needs two separate data buff)Tj
0 Tc
439.3 0 Td(-)Tj
-0.0016922 Tc
-439.3 -14.4 Td(ers to be passed to the USB stack: One for the Setup stage data, and one for the )Tj
0.00513383 Tc
0 -14.4 Td(Data stage data. As you might have guessed by now, the io_SetupData and )Tj
0.00308041 Tc
0 -14.4 Td(io_SetupLength fields of the USBIOReq structure are there for exactly this reason: )Tj
0.0032081 Tc
0 -14.4 Td(To define a Setup data buffer for IO concerning Control EndPoints.)Tj
0.0033702 Tc
0 -28.8 Td(You therefore need to take three steps to talk with a Control EndPoint)Tj
0 Tc
369.1 0 Td(:)Tj
-0.00798321 Tc
-355.6 -28.8 Td(1.)Tj
0.0165803 Tc
12.6 0 Td(Allocate)Tj
0.00557277 Tc
42.8 0 Td( a struct USBBusSetupData buffer in a publicly accessible memory area )Tj
0.0025871 Tc
-41.9 -14.4 Td(and fill in the fields according to the command you're sending.)Tj
-0.00798321 Tc
-13.5 -14.4 Td(2.)Tj
0.000933721 Tc
12.6 0 Td(Set up the USBIOReq fields.)Tj
-0.00798321 Tc
-12.6 -14.4 Td(3.)Tj
-0.00210317 Tc
12.6 0 Td(Pass on the request to the USB stack.)Tj
0.00850159 Tc
-26.1 -28.8 Td(The actual values to place in the USBBusSetupData fields will not be explained in )Tj
0.00477913 Tc
0 -14.4 Td(this document. The USBBusSetupData structure has a field-to-field mapping with the  )Tj
0.00283167 Tc
0 -14.4 Td(Setup Data structure defined in the USB specification, where you'll also find a defini)Tj
0 Tc
443.1 0 Td(-)Tj
0.00546172 Tc
-443.1 -14.4 Td(tion of all the standard commands.)Tj
0.00719679 Tc
0 -14.4 Td(One thing which should be mentioned about the USBBusSetupData here, is that)Tj
/R13 12 Tf
0.0362846 Tc
12 -28.8 Td(the USBBusSetupData is a USB bus structure - it is LittleEndian by nature.)Tj
/R6 12 Tf
0.00375633 Tc
-12 -28.8 Td(When you read or write values other than byte-size, you must remember to perform )Tj
0.00810391 Tc
0 -14.4 Td(endianness conversion of the values. The include file "usb/usb.h" defines a macro, )Tj
0.00720749 Tc
0 -14.4 Td(LE_WORD\(\), which will perform endianness convertion to/from LittleEndian of a 16 )Tj
0.00493152 Tc
0 -14.4 Td(bit data word.)Tj
-0.00965772 Tc
0 -28.8 Td(Once you've filled the USBBusSetupData it's time to roll the IO request. Here you'll )Tj
0.00806536 Tc
0 -14.4 Td(set the io_Command to CMD_READ or CMD_WRITE, depending on the intended )Tj
0.00196808 Tc
0 -14.4 Td(direction of the Data stage of the Control transfer.)Tj
0.00475464 Tc
0 -14.4 Td(You then set the io_SetupData and io_SetupLength to that of your USBBusSetup)Tj
0 Tc
431.3 0 Td(-)Tj
0.000292642 Tc
-431.3 -14.4 Td(Data structure.)Tj
0.0010777 Tc
0 -14.4 Td(Now is a good time to define the data buffer for the Data stage of the transfer, which )Tj
0.00732459 Tc
0 -14.4 Td(is done with io_Data and io_Length. If there is no Data stage involved with the Con)Tj
0 Tc
439.5 0 Td(-)Tj
-0.000887821 Tc
-439.5 -14.4 Td(trol transfer, then you're free to leave these at NULL and zero respectively.)Tj
0.00167885 Tc
0 -14.4 Td(The only thing missing now, is the EndPoint to talk to. That you specify in the )Tj
0.0035443 Tc
0 -14.4 Td(io_EndPoint field of the USBIOReq structure.)Tj
/R6 16 Tf
-0.0112665 Tc
0 -32 Td(Doing the IO)Tj
/R6 12 Tf
0.0053057 Tc
0 -16 Td(With the steps explained above performed, everything is now ready for the USB )Tj
0.00100781 Tc
0 -14.4 Td(stack to start handling the transfer. The IO is initiated by passing the USBIOReq on )Tj
-0.00709481 Tc
0 -14.4 Td(to the USB stack using Exec's SendIO\(\) or DoIO\(\) functions.)Tj
ET Q
Q
endstream
endobj
76 0 obj
4032
endobj
74 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R13 13 0 R
/R6 6 0 R
>>
>>
/Contents 75 0 R
>>
endobj
78 0 obj
<</Length 79 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 16 Tf
-0.00910526 Tc
1 0 0 1 72 757.1 Tm(Taking the shortcut)Tj
/R6 12 Tf
0.00267349 Tc
0 -16 Td(As you might have discovered, Control transfers are not the simplest form of data )Tj
0.00370006 Tc
0 -14.4 Td(transfer on the USB bus. It involves some setting up, and a preallocated USBBus)Tj
0 Tc
430.5 0 Td(-)Tj
0.00253376 Tc
-430.5 -14.4 Td(SetupData structure.)Tj
0.00350141 Tc
0 -14.4 Td(To make things a bit easier, the USB stack has an API call for handling Control )Tj
0.0021807 Tc
0 -14.4 Td(transfers in a more friendly way. That API call is USBEPControlXferA\(\).)Tj
0.00351367 Tc
0 -14.4 Td(The upside of this call is that you can specify the USBBusSetupData as function ar)Tj
0 Tc
438.5 0 Td(-)Tj
0.00724928 Tc
-438.5 -14.4 Td(guments, rather than rolling your own USBBusSetupData. USBEPControlXferA\(\) will )Tj
0.0114354 Tc
0 -14.4 Td(internally build the USBBusSetupData and handle endianness conversion for you )Tj
0.0100075 Tc
0 -14.4 Td(where it is required.)Tj
0.00371947 Tc
0 -14.4 Td(The downside of USBEPControlXferA\(\) is that it is a synchronous call. It will not re)Tj
0 Tc
435.8 0 Td(-)Tj
0.00554868 Tc
-435.8 -14.4 Td(turn until the Control transfer has finished. If you need asynchronous Control trans)Tj
0 Tc
436 0 Td(-)Tj
-0.00909634 Tc
-436 -14.4 Td(fers, then you're on your own.)Tj
/R6 16 Tf
0.00222948 Tc
0 -32 Td(An example)Tj
/R6 12 Tf
0.0052747 Tc
0 -16 Td(Two methods for Control transfers have been described above. To give a better view )Tj
0.00527663 Tc
0 -14.4 Td(of these methods, and their differences, an example is in place.)Tj
0.00190811 Tc
0 -14.4 Td(What we want to achieve in the example code, is to read the status word of a USB )Tj
0.00258974 Tc
0 -14.4 Td(Function. The status word is a 16 bit bitmask holding the Function status flags.)Tj
-0.00469791 Tc
0 -14.4 Td(First we'll read the status word by rolling the IO request by hand. Then we'll do the )Tj
-0.000623603 Tc
0 -14.4 Td(same thing once more, but this time make a shortcut thru the USB stack API US)Tj
0 Tc
424.8 0 Td(-)Tj
0.00619229 Tc
-424.8 -14.4 Td(BEPControlXferA\(\) call.)Tj
0.00863728 Tc
0 -14.4 Td(Both example code snippets below assumes that usbsys.device has already been )Tj
0.00930374 Tc
0 -14.4 Td(opened using an IORequest named "usbopenreq", and that USBSysBase has been )Tj
0.00646495 Tc
0 -14.4 Td(set to the value of usbopenreq->io_Device. Furthermore the variable "fkt" holds the )Tj
0.00117493 Tc
0 -14.4 Td(claimed USB Function to get the status word from.)Tj
0.00659021 Tc
0 -28.8 Td(First the manualy build Control transfer version:)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct UsbEndPoint )Tj
114 0 Td(*dcp; // Default Control Pipe)Tj
-114 -12 Td(struct )Tj
42 0 Td(USBIOReq    )Tj
72 0 Td(*usbio;)Tj
-114 -12 Td(UBYTE)Tj
36 0 Td(             )Tj
78 0 Td(*)Tj
6 0 Td(buffer; // Buffer for the Function status)Tj
-120 -12 Td( )Tj
0 -12 Td(// ** Get Control EP to talk to)Tj
0 -12 Td(dcp = USBGetEndPoint\( fkt, NULL, 0 \);)Tj
0 -24 Td(// ** Allocate IO and buffer)Tj
0 -12 Td(usbio = USBAllocRequestA\( usbopenreq, NULL \);)Tj
0 -12 Td(buffer = AllocMem\( 2, MEMF_PUBLIC \);)Tj
0 -24 Td(if \( dcp && usbio && buffer \) {)Tj
36 -12 Td(struct USBBusSetupData)Tj
144 0 Td(*setupdata;)Tj
-144 -24 Td(if \( setupdata = AllocMem\( sizeof\( struct USBBusSetupData \), )Tj
162.9 -12 Td(MEMF_PUBLIC \) \) {)Tj
-126.9 -12 Td(// ** Set up the Setup stage data)Tj
0 -12 Td(setupdata->sd_RequestType = USBSDT_DIR_DEVTOHOST | )Tj
169.2 -12 Td(USBSDT_TYP_STANDARD | )Tj
0 -12 Td(USBSDT_REC_DEVICE;)Tj
-169.2 -12 Td(setupdata->sd_Request = USBREQC_GET_STATUS;)Tj
ET Q
Q
endstream
endobj
79 0 obj
3653
endobj
77 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 78 0 R
>>
endobj
81 0 obj
<</Length 82 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 180 761.9 Tm(setupdata->sd_Value = LE_WORD\(0\); // \(LE_WORD is absurd )Tj
96.3 -12 Td(for zero value, but you get the idea...\))Tj
-96.3 -12 Td(setupdata->sd_Index = LE_WORD\(0\);)Tj
0 -12 Td(setupdata->sd_Length = LE_WORD\(2\); // This must match us)Tj
336 0 Td(-)Tj
-107.4 -12 Td(bio->io_Length)Tj
-228.6 -24 Td(// ** Setup the IO request)Tj
0 -12 Td(usbio->io_Command = CMD_READ;)Tj
0 -12 Td(usbio->io_SetupData = setupdata;)Tj
0 -12 Td(usbio->io_SetupLength = sizeof\( struct USBBusSetupData \);)Tj
0 -12 Td(usbio->io_Data = buffer;)Tj
0 -12 Td(usbio->io_Length = 2;)Tj
0 -12 Td(usbio->io_EndPoint = dcp;)Tj
0 -24 Td(// ** Perform the Control transfer)Tj
0 -12 Td(DoIO\( \(struct IORequest *\) usbio \);)Tj
0 -24 Td(if \( usbio->io_Error == USBERR_NOERROR \) {)Tj
36 -12 Td(// ... use the result for something)Tj
-36 -12 Td(})Tj
0 -24 Td(FreeMem\( setupdate, sizeof\( struct USBBusSetupData \) \);)Tj
-36 -12 Td(})Tj
-36 -12 Td(})Tj
0 -24 Td(if \( buffer \) FreeMem\( buffer, 2 \);)Tj
0 -12 Td(if \( usbio \) USBFreeRequest\( usbio \);)Tj
0 -12 Td(// ...)Tj
/R6 12 Tf
0.00236736 Tc
-36 -28 Td(And now for the short version of the exact same functionality:)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(// ...)Tj
0 -12 Td(struct UsbEndPoint )Tj
114 0 Td(*dcp; // Default Control Pipe)Tj
-114 -12 Td(struct USBIOReq)Tj
108 0 Td( )Tj
6 0 Td(*usbio;)Tj
-114 -12 Td(UBYTE)Tj
36 0 Td(             )Tj
78 0 Td(*buffer; // Buffer for the Function status)Tj
-114 -12 Td( )Tj
0 -12 Td(// ** Get Control EP to talk to)Tj
0 -12 Td(dcp = USBGetEndPoint\( fkt, NULL, 0 \);)Tj
0 -24 Td(// ** Allocate IO and buffer)Tj
0 -12 Td(usbio = USBAllocRequestA\( usbopenreq, NULL \);)Tj
0 -12 Td(buffer = AllocMem\( 2, MEMF_PUBLIC \);)Tj
0 -24 Td(if \( dcp && usbio && buffer \) {)Tj
36 -12 Td(LONG err;)Tj
0 -24 Td(err = )Tj
36 0 Td(USBEPControlXferA\( usbio, dcp, USBREQC_GET_STATUS, )Tj
114.3 -12 Td(USBSDT_DIR_DEVTOHOST | )Tj
0 -12 Td(USBSDT_TYP_STANDARD | )Tj
0 -12 Td(USBSDT_REC_DEVICE, 0, 0, 2, NULL \);)Tj
-150.3 -12 Td(if \( err == USBERR_NOERROR \) {)Tj
36 -12 Td(// ... use the result for something)Tj
-36 -12 Td(})Tj
-36 -12 Td(})Tj
0 -24 Td(if \( buffer \) FreeMem\( buffer, 2 \);)Tj
0 -12 Td(if \( usbio \) USBFreeRequest\( usbio \);)Tj
ET Q
Q
endstream
endobj
82 0 obj
2287
endobj
80 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 81 0 R
>>
endobj
84 0 obj
<</Length 85 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 108 761.9 Tm(// ...)Tj
/R6 12 Tf
0.0025131 Tc
-36 -28 Td(It is quite easy to spot the difference in code complexity between the two methods. )Tj
0.000198728 Tc
0 -14.4 Td(Most of the time it suffices to use USBEPControlXferA\(\), but on rare occasions, such )Tj
0.00683735 Tc
0 -14.4 Td(as asynchronous Control xfers, you will need to do it all by hand.)Tj
/R6 16 Tf
-0.0181641 Tc
0 -32 Td(Some things you're not allowed to do)Tj
/R6 12 Tf
0.00958779 Tc
0 -16 Td(As explained earlier, Control EndPoints handle the housekeeping of USB entities at)Tj
0 Tc
443 0 Td(-)Tj
-0.00105304 Tc
-443 -14.4 Td(tached to the USB bus. If you read up on the standard Control commands, you'll find )Tj
0.00233353 Tc
0 -14.4 Td(that configuration of USB Functions and selection of Alternate Settings for Interfaces )Tj
0.00647691 Tc
0 -14.4 Td(are also done by Control transfers.)Tj
0.00218107 Tc
0 -14.4 Td(Due to the structural nature of USB Function and Interface configuration, the USB )Tj
0.00593621 Tc
0 -14.4 Td(stack needs to be in full control of when and why a configuration is changed. Only in )Tj
0.00259543 Tc
0 -14.4 Td(knowing that, can the USB stack create the required internal structures that keeps it )Tj
0.00519707 Tc
0 -14.4 Td(all working. For this specific reason some of the standard Control transfer commands )Tj
0.00633043 Tc
0 -14.4 Td(are disallowed by the USB stack:)Tj
0 Tc
13.5 -28.8 Td(∑)Tj
-0.00498486 Tc
12.6 0 Td(SET_CONFIGURATION)Tj
0 Tc
-12.6 -14.4 Td(∑)Tj
-0.00131607 Tc
12.6 0 Td(SET_INTERFACE)Tj
-0.0102245 Tc
-26.1 -28.8 Td(Don't use them - it's as simple as that. At best you'll have the USB stack complaining )Tj
0.00474774 Tc
0 -14.4 Td(about your FD, at worst somethings goes terribly wrong.)Tj
0.00461511 Tc
0 -14.4 Td(Instead of using the forbidden lowlevel Control commands, the USB stack has API )Tj
0.00511428 Tc
0 -14.4 Td(calls which maps to these commands. The replacement API calls are )Tj
0.00154935 Tc
0 -14.4 Td(USBFktSetConfigurationA\(\) for SET_CONFIGURATION and U)Tj
-0.0026543 Tc
333.5 0 Td(SBIntSetAltSettingA\(\) )Tj
-0.00539712 Tc
-333.5 -14.4 Td(for SET_INTERFACE.)Tj
/R6 18 Tf
-0.0031988 Tc
0 -33.6 Td(Talking with non-Control EndPoints)Tj
/R6 12 Tf
0.00438029 Tc
0 -16.8 Td(In the previous section we've been going thru communicating with Control End)Tj
0 Tc
416.5 0 Td(-)Tj
0.00189029 Tc
-416.5 -14.4 Td(Points. In this section we'll take a look at communicating with non-Control EndPoints.)Tj
0.00615075 Tc
0 -14.4 Td(On the IO request level all non-Control EndPoints are used alike. All these EndPoint )Tj
0.00494699 Tc
0 -14.4 Td(types are therefore covered as one.)Tj
/R6 16 Tf
-0.00434146 Tc
0 -32 Td(Setting up your USBIOReq)Tj
/R6 12 Tf
0.0055789 Tc
0 -16 Td(As non-Control EndPoints do not involve any Setup stage in their transactions, these )Tj
0.00390468 Tc
0 -14.4 Td(EndPoints are much easier to communicate with on an IO request level. In other )Tj
0.00345188 Tc
0 -14.4 Td(words, there is no USBBusSetupData structure to prepare, and as a result )Tj
0.00495509 Tc
0 -14.4 Td(io_SetupData and io_SetupLength of the USBIOReq structure are simply kept at )Tj
0.00238732 Tc
0 -14.4 Td(NULL and zero respecetively. The rest of the USBIOReq structure is used just as )Tj
0.00837291 Tc
0 -14.4 Td(with Control EndPoints:)Tj
-0.00798321 Tc
13.5 -28.8 Td(1.)Tj
0.00432158 Tc
12.6 0 Td(Set io_Command to CMD_READ to read data in from the EndPoint, or )Tj
0.000318087 Tc
0.900024 -14.4 Td(CMD_WRITE to write data to the EndPoint.)Tj
-0.00798321 Tc
-13.5 -14.4 Td(2.)Tj
0.00589667 Tc
12.6 0 Td(Set io_SetupData to NULL and io_SetupLength to zero as there is no Setup )Tj
0.00763226 Tc
0.900024 -14.4 Td(stage for non-Control EndPoint0s.)Tj
0 Tc
-13.5 -14.4 Td(3)Tj
6.69998 0 Td(.)Tj
0.00246094 Tc
5.9 0 Td(Set io_Data to point to your data buffer. Remember the buffer must be in pub)Tj
0 Tc
408.4 0 Td(-)Tj
0.01437 Tc
-407.5 -14.4 Td(licly available memory.)Tj
ET Q
Q
endstream
endobj
85 0 obj
3984
endobj
83 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 84 0 R
>>
endobj
87 0 obj
<</Length 88 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
1 0 0 1 85.5 760.3 Tm(4)Tj
6.69998 0 Td(.)Tj
0.00233487 Tc
5.9 0 Td(Set io_Length to the number of data bytes to read/write.)Tj
0 Tc
-12.6 -14.4 Td(5)Tj
6.69998 0 Td(.)Tj
0.00541178 Tc
5.9 0 Td(Set io_EndPoint to the EndPoint with which to communicate.)Tj
0.00366211 Tc
-26.1 -28.8 Td(Sometimes it is required to do a zero length write to an EndPoint. Such  a transac)Tj
0 Tc
432.5 0 Td(-)Tj
0.00770279 Tc
-432.5 -14.4 Td(tion is created by having a zero io_Length and a non-NULL io_Data. In this case )Tj
0.00551884 Tc
0 -14.4 Td(io_Data does not have to point to any specific memory area - it will never be refer)Tj
0 Tc
431.3 0 Td(-)Tj
0.00578421 Tc
-431.3 -14.4 Td(enced. Any value is safe, as long as io_Length is zero.)Tj
/R6 16 Tf
-0.0112665 Tc
0 -32 Td(Doing the IO)Tj
/R6 12 Tf
0.00559645 Tc
0 -16 Td(With the USBIOReq prepared as described above, everything is now ready for the )Tj
0.000458145 Tc
0 -14.4 Td(USB stack to start handling the transfer. The IO is initiated by passing the USBI)Tj
0 Tc
420.9 0 Td(-)Tj
-0.00621396 Tc
-420.9 -14.4 Td(OReq to the USB stack using Exec's SendIO\(\) or DoIO\(\) functions.)Tj
/R6 16 Tf
0.00222948 Tc
0 -32 Td(An example)Tj
/R6 12 Tf
0.00642866 Tc
0 -16 Td(The following example will write a buffer to non-Control EndPoint 2 of a USB Inter)Tj
0 Tc
432.7 0 Td(-)Tj
0.00525703 Tc
-432.7 -14.4 Td(face, followed by reading some data from non-Control EndPoint 3 of the same Inter)Tj
0 Tc
441.3 0 Td(-)Tj
-0.0039916 Tc
-441.3 -14.4 Td(face.)Tj
0.00635254 Tc
0 -14.4 Td(It is assumed that usbsys.device has already been opened using an IORequest )Tj
0.00736694 Tc
0 -14.4 Td(named "usbopenreq", and that USBSysBase has been set to the value of usbopen)Tj
0 Tc
438 0 Td(-)Tj
0.00747048 Tc
-438 -14.4 Td(req->io_Device. Furthermore the variable "ifc" holds the claimed USB Interface host)Tj
0 Tc
444.3 0 Td(-)Tj
0.000507991 Tc
-444.3 -14.4 Td(ing the EndPoint we're going to communicate with.)Tj
/R40 10 Tf
0 Tc
36 -27.2 Td(struct UsbEndPoint *ep;)Tj
0 -12 Td(struct USBIOReq *usbio;)Tj
0 -12 Td(UBYTE *buffer;)Tj
0 -24 Td(// ...)Tj
0 -24 Td(// ** Allocate IO and buffer)Tj
0 -12 Td(usbio = USBAllocRequestA\( usbopenreq, NULL \);)Tj
0 -12 Td(buffer = AllocMem\( 10, MEMF_PUBLIC \);)Tj
0 -24 Td(if \( usbio && buffer \) {)Tj
36 -24 Td(// ** Get EndPoint to write to)Tj
0 -12 Td(if \( )Tj
30 0 Td(ep = USBGetEndPoint\( NULL, ifc, 2 \) \) {)Tj
6 -24 Td(// ** Setup and perform data write)Tj
0 -12 Td(usbio->io_Command = CMD_WRITE;)Tj
0 -12 Td(usbio->io_SetupData = NULL;)Tj
0 -12 Td(usbio->io_SetupLength = 0;)Tj
0 -12 Td(usbio->io_Data = buffer;)Tj
0 -12 Td(usbio->io_Length = 10;)Tj
0 -12 Td(usbio->io_EndPoint = ep;)Tj
0 -12 Td( )Tj
0 -12 Td(SendIO\( usbio \);)Tj
0 -12 Td(// .. perhaps you'd like to do something until IO is done)Tj
0 -12 Td(WaitIO\( usbio \);)Tj
0 -12 Td( )Tj
0 -12 Td(if \( usbio->io_Error != USBERR_NOERROR \) {)Tj
36 -12 Td(// Uh, oh, something went wrong!)Tj
-36 -12 Td(})Tj
ET Q
Q
endstream
endobj
88 0 obj
3002
endobj
86 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 87 0 R
>>
endobj
90 0 obj
<</Length 91 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R40 10 Tf
1 0 0 1 144 761.9 Tm(})Tj
0 -24 Td(// ** Get EndPoint to read from)Tj
0 -12 Td(if \( ep = USBGetEndPoint\( NULL, ifc, 3 \) \) {)Tj
36 -24 Td(// ** Setup and perform data read)Tj
0 -12 Td(usbio->io_Command = CMD_READ;)Tj
0 -12 Td(usbio->io_SetupData = NULL;)Tj
0 -12 Td(usbio->io_SetupLength = 0;)Tj
0 -12 Td(usbio->io_Data = buffer;)Tj
0 -12 Td(usbio->io_Length = 2;)Tj
0 -12 Td(usbio->io_EndPoint = ep;)Tj
0 -12 Td( )Tj
0 -12 Td(SendIO\( usbio \);)Tj
0 -12 Td(// .. perhaps you'd like to do something until IO is done)Tj
0 -12 Td(WaitIO\( usbio \);)Tj
0 -12 Td( )Tj
0 -12 Td(if \( usbio->io_Error == USBERR_NOERROR \) {)Tj
36 -12 Td(// We got the data - now use it for something...)Tj
-36 -12 Td(})Tj
-36 -12 Td(})Tj
-36 -12 Td(})Tj
0 -24 Td(if \( buffer \) FreeMem\( buffer, 10 \);)Tj
0 -12 Td(if \( usbio \) USBFreeRequest\( usbio \);)Tj
0 -12 Td(// ...)Tj
/R6 18 Tf
-0.00123596 Tc
-36 -32.8 Td(IO errors)Tj
/R6 12 Tf
-0.000369083 Tc
0 -16.8 Td(Every IO request that is returned from the USB stack it carries with it an error code )Tj
0.00258137 Tc
0 -14.4 Td(indicating the status of the request. This chapter is devoted to these error codes, and )Tj
0.00554637 Tc
0 -14.4 Td(will try to explain the meaning of them.)Tj
-0.000723862 Tc
0 -28.8 Td(Apart from the standard Exec IO error codes the USB stack at the time of writing de)Tj
0 Tc
442.8 0 Td(-)Tj
0.00474428 Tc
-442.8 -14.4 Td(fines the following set of error codes:)Tj
/R92 12 Tf
0.0442595 Tc
1 0 0.00000001 1 108 311.5 Tm(Structural errors)Tj
/R6 12 Tf
0.0160157 Tc
1 0 0 1 108 297.1 Tm(USBERR_DETACHED)Tj
0.0096624 Tc
0 -14.4 Td(USBERR_NOBANDWIDTH)Tj
0.0116501 Tc
0 -14.4 Td(USBERR_NOMEM)Tj
-0.00169863 Tc
0 -14.4 Td(USBERR_NOSIGBIT)Tj
0.0110931 Tc
0 -14.4 Td(USBERR_BADARGS)Tj
0.00751495 Tc
0 -14.4 Td(USBERR_NOENDPOINT)Tj
0.0129565 Tc
0 -14.4 Td(USBERR_UNSUPPORTED)Tj
0.0072169 Tc
0 -14.4 Td(USBERR_ISPRESENT)Tj
0.00501633 Tc
0 -14.4 Td(USBERR_ATTACHFAIL)Tj
/R92 12 Tf
0.074598 Tc
1 0 0.00000001 1 108 153.1 Tm(Transaction errors)Tj
/R6 12 Tf
0.0127418 Tc
1 0 0 1 108 138.7 Tm(USBERR_STALL)Tj
0.00544412 Tc
0 -14.4 Td(USBERR_XFERFAIL)Tj
0.016905 Tc
0 -14.4 Td(USBERR_NAK)Tj
0.00186099 Tc
0 -14.4 Td(USBERR_TIMEOUT)Tj
0.00241547 Tc
0 -14.4 Td(USBERR_BUFFEROVERFLOW)Tj
ET Q
Q
endstream
endobj
91 0 obj
2295
endobj
89 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R92 92 0 R
/R40 40 0 R
/R6 6 0 R
>>
>>
/Contents 90 0 R
>>
endobj
94 0 obj
<</Length 95 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00486392 Tc
1 0 0 1 72 745.9 Tm(The error codes are defined in the include file "usb/system.h". Apart from the above )Tj
0.00608568 Tc
0 -14.4 Td(error codes, the USBERR_NOERROR error code also exist, which is just a naming )Tj
0.00622785 Tc
0 -14.4 Td(of the non-error value zero.)Tj
0.00967817 Tc
0 -14.4 Td(In the following sections each error code will be explained in turn.)Tj
/R6 16 Tf
0.0380151 Tc
0 -32 Td(USBERR_DETACHED)Tj
/R6 12 Tf
0.00212777 Tc
0 -16 Td(You will see this error code if the target of the IO request has been detached from )Tj
0.00455869 Tc
0 -14.4 Td(the USB bus before or during the processing of the request.)Tj
0.00653397 Tc
0 -14.4 Td(This is most likely to happen around the time when a USB Function has been de)Tj
0 Tc
426.7 0 Td(-)Tj
0.00388729 Tc
-426.7 -14.4 Td(tached from the USB bus. Any pending IO will then be returned with )Tj
0.00688093 Tc
0 -14.4 Td(USBERR_DETACHED, and any subsequently initiated IO will be sent back with this )Tj
0.00956217 Tc
0 -14.4 Td(error code as well.)Tj
0.00300789 Tc
0 -28.8 Td(Due to the multitasking nature of the USB stack and its Host Controller Drivers, )Tj
0.00709108 Tc
0 -14.4 Td(which handles the lowlevel USB bus drivers, USBERR_TIMEOUT or )Tj
0.00543867 Tc
0 -14.4 Td(USBERR_XFERFAIL errors may be returned in place of USBERR_DETACHED for )Tj
0.00232081 Tc
0 -14.4 Td(IO requests until the USB system is fully aware that the target has actually been de)Tj
0 Tc
440.4 0 Td(-)Tj
0.00667318 Tc
-440.4 -14.4 Td(tached.)Tj
/R6 16 Tf
0.0266024 Tc
0 -32 Td(USBERR_NOBANDWIDTH)Tj
/R6 12 Tf
0.00520307 Tc
0 -16 Td(This error indicates that there is not sufficient bandwidth available on the USB bus to )Tj
0.00379582 Tc
0 -14.4 Td(support the request.)Tj
0.00237101 Tc
0 -14.4 Td(This error is not directly tied to IO operations, but rather to situations where the over)Tj
0 Tc
444.4 0 Td(-)Tj
0.00867364 Tc
-444.4 -14.4 Td(all USB configuration changes in a way that influences on bandwidth usage. The )Tj
0.0039591 Tc
0 -14.4 Td(mostprominent example of this is when a new USB Function is being attached. If the )Tj
0.00637742 Tc
0 -14.4 Td(USB stack determines that there is not enough bandwidth available to sustain this )Tj
0.00956838 Tc
0 -14.4 Td(new Function, it will deny its addition. The same will happen when reconfiguring a )Tj
0.00670853 Tc
0 -14.4 Td(USB Function or USB Interface if the new configuration will claim more bandwidth )Tj
0.00737138 Tc
0 -14.4 Td(than is available on that particular USB bus.)Tj
/R6 16 Tf
0.0185602 Tc
0 -32 Td(USBERR_NOMEM)Tj
/R6 12 Tf
0.000341143 Tc
0 -16 Td(If at any time the USB stack fails to allocate memory for the handling of a request, )Tj
0.00819189 Tc
0 -14.4 Td(the request will be failed with USBERR_NOMEM.)Tj
/R6 16 Tf
0.0120098 Tc
0 -32 Td(USBERR_NOSIGBIT)Tj
/R6 12 Tf
0.00172886 Tc
0 -16 Td(Not directly related to IO this error is used if the USB stack is unable to allocate a )Tj
0.0128308 Tc
0 -14.4 Td(signal bit for internal signalling.)Tj
0.00959686 Tc
0 -14.4 Td(Generally you should make sure at least one free signal bit is available when operat)Tj
0 Tc
445 0 Td(-)Tj
-0.000870972 Tc
-445 -14.4 Td(ing with the USB stack APIs to be on the safe side.)Tj
/R6 16 Tf
0.0301643 Tc
0 -32 Td(USBERR_BADARGS)Tj
/R6 12 Tf
-0.000325158 Tc
0 -16 Td(If you pass invalid arguments to the USB stack, be it in IO requests or in API calls )Tj
0.00178077 Tc
0 -14.4 Td(returning a USB error code, you will get this error - if the USB stack is able to detect )Tj
-0.00399145 Tc
0 -14.4 Td(the error, that is.)Tj
0.00894466 Tc
0 -14.4 Td(As an FD developer this error typically indicates something very bad is happening )Tj
ET Q
Q
endstream
endobj
95 0 obj
3714
endobj
93 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 94 0 R
>>
endobj
97 0 obj
<</Length 98 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00550052 Tc
1 0 0 1 72 760.3 Tm(within your FD. You should check and recheck your code until you find the source of )Tj
0.00849221 Tc
0 -14.4 Td(the problem. A properly implemented FD will *never* see this error.)Tj
0.00420761 Tc
0 -14.4 Td(Typically a log entry with further information is added to the USB system log in )Tj
0.00800982 Tc
0 -14.4 Td("T:usb.log".)Tj
/R6 16 Tf
0.0225134 Tc
0 -32 Td(USBERR_NOENDPOINT)Tj
/R6 12 Tf
0.00321641 Tc
0 -16 Td(This error is returned if the USB stack for some reason is unable to find a referenced )Tj
0.00569502 Tc
0 -14.4 Td(EndPoint during IO or an API call. Either the EndPoint has been detached obsoleting )Tj
0.00560684 Tc
0 -14.4 Td(your EndPoint reference, or something is wrong further down the foodchain of the )Tj
-0.00181045 Tc
0 -14.4 Td(USB stack. In any case you won't in the touch with the referenced EndPoint any)Tj
0 Tc
423.4 0 Td(-)Tj
0.00700712 Tc
-423.4 -14.4 Td(more.)Tj
/R6 16 Tf
0.0329545 Tc
0 -32 Td(USBERR_UNSUPPORTED)Tj
/R6 12 Tf
0.00570104 Tc
0 -16 Td(This error is used for indicating that a requested operation is not supported. The rea)Tj
0 Tc
444.7 0 Td(-)Tj
0.00474661 Tc
-444.7 -14.4 Td(sons for not supporting a specific request can be many:)Tj
0 Tc
36 -14.4 Td(∑)Tj
0.00550699 Tc
36 0 Td(The hardware does not support it.)Tj
0 Tc
-36 -14.4 Td(∑)Tj
0.00616064 Tc
36 0 Td(The hardware driver does not support it.)Tj
0 Tc
-36 -14.4 Td(∑)Tj
-0.000719475 Tc
36 0 Td(The USB stack does not support it.)Tj
0 Tc
-36 -14.4 Td(∑)Tj
0.00267334 Tc
36 0 Td(.. add your own reasons here ..)Tj
0.0070304 Tc
-72 -28.8 Td(What should be mentioned here is that only lowlevel lack of support for a request will )Tj
0.00372205 Tc
0 -14.4 Td(result in this error. Any unsupported feature on a USB Function/Interface/EndPoint or)Tj
0.00470538 Tc
0 -14.4 Td(USB class level is identified and reported within the contents of IO transactions with )Tj
0.00727081 Tc
0 -14.4 Td(an EndPoint in the unsupporting entity.)Tj
/R6 16 Tf
0.0296112 Tc
0 -32 Td(USBERR_ISPRESENT)Tj
/R6 12 Tf
0.00648244 Tc
0 -16 Td(This is not an error as such, rather a special return value used when registering an )Tj
0.00660782 Tc
0 -14.4 Td(AutoStarting FD with usbresource.library.)Tj
0.00624557 Tc
0 -14.4 Td(Seeing this return value simply indicates that the FD is already registered with the )Tj
-0.0057674 Tc
0 -14.4 Td(USB stack.)Tj
0.00499396 Tc
0 -28.8 Td(The error code may come to use in other places where it can come in handy to know )Tj
0.00596246 Tc
0 -14.4 Td(if something already exist. Currently, though,)Tj
0.00732347 Tc
237.7 0 Td( it is only used with usbresource.library.)Tj
/R6 16 Tf
0.0275135 Tc
-237.7 -32 Td(USBERR_ATTACHFAIL)Tj
/R6 12 Tf
0.00630113 Tc
0 -16 Td(Only hub driver FDs should ever come to experience this error.)Tj
0.00625725 Tc
0 -14.4 Td(The error indicates that it was impossible to handle attachment of a newly added )Tj
0.00563709 Tc
0 -14.4 Td(USB entity on the USB bus. The error relates to the lowlevel adding and address as)Tj
0 Tc
444 0 Td(-)Tj
0.00903171 Tc
-444 -14.4 Td(signment going on in the Host Controller Driver handling the USB bus at a hardware )Tj
0.00580186 Tc
0 -14.4 Td(level before the USB stack takes over and makes the USB Function publicly avail)Tj
0 Tc
431.3 0 Td(-)Tj
0.0210085 Tc
-431.3 -14.4 Td(able.)Tj
0.00457807 Tc
0 -14.4 Td(This error does not relate to Function Driver IO operations whatsoever.)Tj
/R6 16 Tf
0.029102 Tc
0 -32 Td(USBERR_STALL)Tj
/R6 12 Tf
0.00353132 Tc
0 -16 Td(This error indicates that the target EndPoint of the IO request stalled while process)Tj
0 Tc
438.5 0 Td(-)Tj
0.00563617 Tc
-438.5 -14.4 Td(ing the IO. Stalling is a way for EndPoints to indicate being busy or being in failure.)Tj
ET Q
Q
endstream
endobj
98 0 obj
3778
endobj
96 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 97 0 R
>>
endobj
100 0 obj
<</Length 101 0 R>>
stream
0.1 0 0 0.1 0 0 cm
q
q 10 0 0 10 0 0 cm BT
/R6 12 Tf
0.00619761 Tc
1 0 0 1 72 760.3 Tm(The actual meaning of the stall is dependent on the specification of the device or de)Tj
0 Tc
444.1 0 Td(-)Tj
0.00643227 Tc
-444.1 -14.4 Td(vice class the FD is dealing with.)Tj
/R6 16 Tf
0.0262974 Tc
0 -32 Td(USBERR_XFERFAIL)Tj
/R6 12 Tf
0.00552832 Tc
0 -16 Td(A transfer failure on the USB bus will result in USBERR_XFERFAIL being returned )Tj
0.00141077 Tc
0 -14.4 Td(for the IO request being processed at the time of failure.)Tj
0.00210208 Tc
0 -14.4 Td(The reason for a transfer failure is hard to predict, but may very well come from tem)Tj
0 Tc
443 0 Td(-)Tj
0.00853513 Tc
-443 -14.4 Td(porary conditions such babble or noise on the USB bus.)Tj
/R6 16 Tf
0.0373459 Tc
0 -32 Td(USBERR_NAK)Tj
/R6 12 Tf
0.00381018 Tc
0 -16 Td(If the target EndPoint of an IO operation gives a negative acknowledge on the USB )Tj
0.00314717 Tc
0 -14.4 Td(bus as response to a transaction, the IO request is retired with a USBERR_NAK er)Tj
0 Tc
439.1 0 Td(-)Tj
0.00586718 Tc
-439.1 -14.4 Td(ror. Depending on the device or class specification this might not be an error, rather )Tj
0.00444049 Tc
0 -14.4 Td(a signal to the FD that the EndPoint is busy processing an asyncronous request, has )Tj
-0.00075531 Tc
0 -14.4 Td(no data to deliver, can't process any more data at the moment, or something entirely )Tj
0.000898149 Tc
0 -14.4 Td(different.)Tj
/R6 16 Tf
0.0178598 Tc
0 -32 Td(USBERR_TIMEOUT)Tj
/R6 12 Tf
0.00198364 Tc
0 -16 Td(This error occurs if there was no response on the USB bus from the target EndPoint, )Tj
0.00375139 Tc
0 -14.4 Td(so the bus controller had to retire the request.)Tj
0.00762167 Tc
0 -14.4 Td(This will typically happen just when a USB Function is physically detached from the )Tj
-0.000235581 Tc
0 -14.4 Td(USB bus. The USB stack is not yet aware that the Function is detached, so it keeps )Tj
0.00185033 Tc
0 -14.4 Td(on sending IO for EndPoints in the Function. Those IO requests will time out.)Tj
0.00435753 Tc
0 -14.4 Td(If timeouts occur for a prolonged duration it could point to a dead USB Function.)Tj
/R6 16 Tf
0.0232132 Tc
0 -32 Td(USBERR_BUFFEROVERFLOW)Tj
/R6 12 Tf
0.00273653 Tc
0 -16 Td(The buffer overflow error indicates that the io_Data buffer of an IO request has been )Tj
0.00722559 Tc
0 -14.4 Td(filled completely, and that excess data bytes have been discarded to avoid overwrit)Tj
0 Tc
440.8 0 Td(-)Tj
0.0101114 Tc
-440.8 -14.4 Td(ing innocent memory.)Tj
0.00244456 Tc
0 -14.4 Td(This error will occur if a request for data at the target EndPoint results in more data )Tj
0.00638762 Tc
0 -14.4 Td(than expected. Whether this is an error condition depends upon the specification for )Tj
0.00378995 Tc
0 -14.4 Td(the target device or the device class.)Tj
ET Q
Q
endstream
endobj
101 0 obj
2785
endobj
99 0 obj
<<
/Type /Page
/MediaBox [0 0 612 792]
/Parent 2 0 R
/Resources << /ProcSet [/PDF /Text]
/Font <<
/R6 6 0 R
>>
>>
/Contents 100 0 R
>>
endobj
92 0 obj
<</Type/Font/Name/R92/Subtype/Type1/BaseFont/Helvetica-BoldOblique>>
endobj
40 0 obj
<</Type/Font/Name/R40/Subtype/Type1/BaseFont/Courier>>
endobj
14 0 obj
<</Type/Font/Name/R14/Subtype/Type1/BaseFont/Helvetica-Oblique/Encoding 15 0 R>>
endobj
15 0 obj
<</Type/Encoding/Differences[
248/oslash]>>
endobj
13 0 obj
<</Type/Font/Name/R13/Subtype/Type1/BaseFont/Helvetica-Bold>>
endobj
6 0 obj
<</Type/Font/Name/R6/Subtype/Type1/BaseFont/Helvetica>>
endobj
2 0 obj
<< /Type /Pages /Kids [
3 0 R
7 0 R
10 0 R
16 0 R
19 0 R
22 0 R
25 0 R
28 0 R
31 0 R
34 0 R
37 0 R
41 0 R
44 0 R
47 0 R
50 0 R
53 0 R
56 0 R
59 0 R
62 0 R
65 0 R
68 0 R
71 0 R
74 0 R
77 0 R
80 0 R
83 0 R
86 0 R
89 0 R
93 0 R
96 0 R
99 0 R
] /Count 31
>>
endobj
1 0 obj
<< /Type /Catalog /Pages 2 0 R
>>
endobj
102 0 obj
<< /CreationDate (D:20041029191121)
/Producer (Aladdin Ghostscript 5.10)
>>
endobj
xref
0 103
0000000000 65535 f 
0000119891 00000 n 
0000119622 00000 n 
0000003316 00000 n 
0000000015 00000 n 
0000003296 00000 n 
0000119551 00000 n 
0000006167 00000 n 
0000003464 00000 n 
0000006147 00000 n 
0000009590 00000 n 
0000006315 00000 n 
0000009569 00000 n 
0000119473 00000 n 
0000119316 00000 n 
0000119413 00000 n 
0000014272 00000 n 
0000009764 00000 n 
0000014251 00000 n 
0000017788 00000 n 
0000014422 00000 n 
0000017767 00000 n 
0000022016 00000 n 
0000017938 00000 n 
0000021995 00000 n 
0000027057 00000 n 
0000022166 00000 n 
0000027036 00000 n 
0000031137 00000 n 
0000027207 00000 n 
0000031116 00000 n 
0000035305 00000 n 
0000031287 00000 n 
0000035284 00000 n 
0000038981 00000 n 
0000035455 00000 n 
0000038960 00000 n 
0000043431 00000 n 
0000039131 00000 n 
0000043410 00000 n 
0000119245 00000 n 
0000048089 00000 n 
0000043605 00000 n 
0000048068 00000 n 
0000051987 00000 n 
0000048263 00000 n 
0000051966 00000 n 
0000055863 00000 n 
0000052161 00000 n 
0000055842 00000 n 
0000059846 00000 n 
0000056025 00000 n 
0000059825 00000 n 
0000064076 00000 n 
0000060020 00000 n 
0000064055 00000 n 
0000068083 00000 n 
0000064238 00000 n 
0000068062 00000 n 
0000072018 00000 n 
0000068257 00000 n 
0000071997 00000 n 
0000074258 00000 n 
0000072192 00000 n 
0000074237 00000 n 
0000078743 00000 n 
0000074408 00000 n 
0000078722 00000 n 
0000082624 00000 n 
0000078929 00000 n 
0000082603 00000 n 
0000087373 00000 n 
0000082798 00000 n 
0000087352 00000 n 
0000091640 00000 n 
0000087535 00000 n 
0000091619 00000 n 
0000095528 00000 n 
0000091802 00000 n 
0000095507 00000 n 
0000098050 00000 n 
0000095690 00000 n 
0000098029 00000 n 
0000102269 00000 n 
0000098212 00000 n 
0000102248 00000 n 
0000105506 00000 n 
0000102431 00000 n 
0000105485 00000 n 
0000108036 00000 n 
0000105668 00000 n 
0000108015 00000 n 
0000119160 00000 n 
0000111997 00000 n 
0000108210 00000 n 
0000111976 00000 n 
0000115998 00000 n 
0000112147 00000 n 
0000115977 00000 n 
0000119009 00000 n 
0000116148 00000 n 
0000118987 00000 n 
0000119940 00000 n 
trailer
<< /Size 103 /Root 1 0 R /Info 102 0 R
>>
startxref
120033
%%EOF
