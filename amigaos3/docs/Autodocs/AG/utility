@database "utility"
@master "AMIDEV:NDK/Autodocs/utility.doc"

@Node Main "utility.doc"
@toc "Autodocs/AG/INDEX/Main"
    @{" AddNamedObject() " Link "AddNamedObject()"}
    @{" AllocateTagItems() " Link "AllocateTagItems()"}
    @{" AllocNamedObjectA() " Link "AllocNamedObjectA()"}
    @{" Amiga2Date() " Link "Amiga2Date()"}
    @{" ApplyTagChanges() " Link "ApplyTagChanges()"}
    @{" AttemptRemNamedObject() " Link "AttemptRemNamedObject()"}
    @{" CallHookPkt() " Link "CallHookPkt()"}
    @{" CheckDate() " Link "CheckDate()"}
    @{" CloneTagItems() " Link "CloneTagItems()"}
    @{" Date2Amiga() " Link "Date2Amiga()"}
    @{" FilterTagChanges() " Link "FilterTagChanges()"}
    @{" FilterTagItems() " Link "FilterTagItems()"}
    @{" FindNamedObject() " Link "FindNamedObject()"}
    @{" FindTagItem() " Link "FindTagItem()"}
    @{" FreeNamedObject() " Link "FreeNamedObject()"}
    @{" FreeTagItems() " Link "FreeTagItems()"}
    @{" GetTagData() " Link "GetTagData()"}
    @{" GetUniqueID() " Link "GetUniqueID()"}
    @{" MapTags() " Link "MapTags()"}
    @{" NamedObjectName() " Link "NamedObjectName()"}
    @{" NextTagItem() " Link "NextTagItem()"}
    @{" PackBoolTags() " Link "PackBoolTags()"}
    @{" PackStructureTags() " Link "PackStructureTags()"}
    @{" RefreshTagItemClones() " Link "RefreshTagItemClones()"}
    @{" ReleaseNamedObject() " Link "ReleaseNamedObject()"}
    @{" RemNamedObject() " Link "RemNamedObject()"}
    @{" SDivMod32() " Link "SDivMod32()"}
    @{" SDivMod64() " Link "SDivMod64()"}
    @{" SMult32() " Link "SMult32()"}
    @{" SMult64() " Link "SMult64()"}
    @{" Stricmp() " Link "Stricmp()"}
    @{" Strncat() " Link "Strncat()"}
    @{" Strncpy() " Link "Strncpy()"}
    @{" Strnicmp() " Link "Strnicmp()"}
    @{" TagInArray() " Link "TagInArray()"}
    @{" ToLower() " Link "ToLower()"}
    @{" ToUpper() " Link "ToUpper()"}
    @{" UDivMod32() " Link "UDivMod32()"}
    @{" UDivMod64() " Link "UDivMod64()"}
    @{" UMult32() " Link "UMult32()"}
    @{" UMult64() " Link "UMult64()"}
    @{" UnpackStructureTags() " Link "UnpackStructureTags()"}
    @{" VSNPrintf() " Link "VSNPrintf()"}
@EndNode

@Node "AddNamedObject()" "utility.library/AddNamedObject"

@{b}   NAME@{ub}
	AddNamedObject -- add a named object to the given namespace. (V39)

@{b}   SYNOPSIS@{ub}
	success = AddNamedObject(nameSpace, object);
	D0			 A0         A1

	@{"BOOL" Link "INCLUDE:exec/types.h/Main" 168} AddNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *, struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Adds a new item to a NameSpace.  If the NameSpace doesn't support
	duplicate names, a search for a duplicate will be made, and
	0 (failure) will be returned.  Otherwise, the entry will be
	Enqueue()ed to the NameSpace.

@{b}   INPUTS@{ub}
	nameSpace - the name space to add to (NULL for root namespace)
	object - the object to add  (If @{"NULL" Link "rexxsupport/NULL"}, will return failure)

@{b}   RESULT@{ub}
	success - whether the operation succeeded.  Check this always!

@{b}   SEE ALSO@{ub}
	@{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}

@EndNode

@Node "AllocateTagItems()" "utility.library/AllocateTagItems"

@{b}   NAME@{ub}
	AllocateTagItems -- allocate a tag list. (V36)

@{b}   SYNOPSIS@{ub}
	tagList = AllocateTagItems(numTags);
	D0		           D0

	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *AllocateTagItems(ULONG);

@{b}   FUNCTION@{ub}
	Allocates the specified number of usable TagItems slots.

	Note that to access the TagItems in 'tagList', you should use
	the function @{"NextTagItem()" Link "NextTagItem()"}. This will insure you respect any
	chaining (TAG_MORE) and secret hiding places (TAG_IGNORE) that
	this function might generate.

@{b}   INPUTS@{ub}
	numTags - the number of @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} slots you want to allocate.

@{b}   RESULTS@{ub}
	tagList	- the allocated chain of @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} structures, or @{"NULL" Link "rexxsupport/NULL"} if
	          there was not enough memory. An allocated tag list must
	          eventually be freed using @{"FreeTagItems()" Link "FreeTagItems()"}.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"FreeTagItems()" Link "FreeTagItems()"}, @{"CloneTagItems()" Link "CloneTagItems()"}

@EndNode

@Node "AllocNamedObjectA()" "utility.library/AllocNamedObjectA"

@{b}   NAME@{ub}
	AllocNamedObjectA -- allocate a named object. (V39)

@{b}   SYNOPSIS@{ub}
	object = AllocNamedObjectA(name, tagList);
	D0                         A0    A1

	struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *AllocNamedObjectA(STRPTR, struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

	object = AllocNamedObject(name, Tag1, ...);

	struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *AllocNamedObject(STRPTR, ULONG, ...);

@{b}   FUNCTION@{ub}
	Allocates a @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} and initializes it as needed to the
	name given. This object can then be used as an object in the
	namespaces. Tags can be given to make an object contain a
	namespace such that nested namespaces can be built.
	When the object is allocated, it automatically has one use.
	If you later wish to release this object such that others may
	remove it from the namespace you must do a @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}.

@{b}   INPUTS@{ub}
	name - name for the object (must not be NULL)
	tagList - tags with additional information for the allocation or @{"NULL" Link "rexxsupport/NULL"}

@{b}   TAGS@{ub}
	ANO_NameSpace - @{"BOOL" Link "INCLUDE:exec/types.h/Main" 168} tag, default FALSE.  If this tag is
	                TRUE, the named object will also have a
	                name space attached to it.
	ANO_UserSpace - ULONG tag, default 0.  If this tag is non-NULL
	                it defines the size (in bytes) of the user
	                space to be allocated with the named object
	                and that will be pointed to by the no_Object
	                pointer.  This memory is long-word aligned.
	                If no space is defined, no_Object will be @{"NULL" Link "rexxsupport/NULL"}.
	ANO_Priority  - @{"BYTE" Link "INCLUDE:exec/types.h/Main" 118} tag, default 0.  This tag lets you pick
	                a priority for the named object for when it is
	                placed into a name space.
	ANO_Flags     - ULONG tag, default 0.  This tag lets you set
	                the flags of the NameSpace (if you allocated
	                one)  There currently are only TWO flags.
	                Do *NOT* set *any* other bits as they are for
	                future use!!!  (You can't read them anyway)
	                The flags are:
	                NSF_NODUPS	- Name space must be unique.
	                NSF_CASE	- Name space is case sensitive

@{b}   RESULT@{ub}
	object - the object allocated, or @{"NULL" Link "rexxsupport/NULL"} for failure. The object
	         is defined as a pointer to a pointer.  You can do what you
	         wish with the pointer. (It may be @{"NULL" Link "rexxsupport/NULL"} or contain a pointer
	         to memory that you had asked for in the tags.)

@{b}   SEE ALSO@{ub}
	@{"FreeNamedObject()" Link "FreeNamedObject()"}, @{"<utility/name.h>" Link "INCLUDE:utility/name.h/Main" 0}

@EndNode

@Node "Amiga2Date()" "utility.library/Amiga2Date"

@{b}   NAME@{ub}
	Amiga2Date -- fill in a @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure based on a system
		      time stamp (V36)

@{b}   SYNOPSIS@{ub}
	Amiga2Date(seconds,result);
	           D0      A0

	VOID Amiga2Date(ULONG,struct @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} *);

@{b}   FUNCTION@{ub}
	Fills in a @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure with the date and time calculated
	from a ULONG containing the number of seconds from 01-Jan-1978
	to the date.

@{b}   INPUTS@{ub}
	seconds - the number of seconds from 01-Jan-1978.
	result - a pointer to a @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure that will be altered
		 by this function

@{b}   SEE ALSO@{ub}
	@{"CheckDate()" Link "CheckDate()"}, @{"Date2Amiga()" Link "Date2Amiga()"}

@EndNode

@Node "ApplyTagChanges()" "utility.library/ApplyTagChanges"

@{b}   NAME@{ub}
	ApplyTagChanges -- change a tag list based on a second tag list. (V39)

@{b}   SYNOPSIS@{ub}
	ApplyTagChanges(list,changeList);
			A0   A1

	VOID ApplyTagChanges(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *, struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	For any tag that appears in both 'list' and 'changeList', this
	function will change the ti_Data field of the tag in 'list' to
	match the ti_Data field of the tag in 'changeList'. In effect,
	'changeList' contains a series of new values for tags already in
	'list'. Any tag in 'changeList' that is not in 'list' is ignored.

@{b}   INPUTS@{ub}
	list - a list of existing tags (may be NULL)
	changeList - a list of tags to modify 'list' with (may be NULL)

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"FilterTagChanges()" Link "FilterTagChanges()"}

@EndNode

@Node "AttemptRemNamedObject()" "utility.library/AttemptRemNamedObject"

@{b}   NAME@{ub}
	AttemptRemNamedObject -- attempt to remove a named object. (V39)

@{b}   SYNOPSIS@{ub}
	result = AttemptRemNamedObject(object);
	D0                             A0

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} AttemptRemNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Attempts to remove an object from whatever NameSpace it's in.
	You must have found the object first (in order to get a use count)
	before trying to remove it.  If the object is in use or is
	in the process of being removed, this function will return
	a failure code.  If the object is fully removed, the object will
	then be available to be @{"FreeNamedObject()" Link "FreeNamedObject()"}.

@{b}   INPUTS@{ub}
	object - the object to attempt to remove  The object must be valid

@{b}   RESULT@{ub}
	success - FALSE if object is still in use (somewhere)
	          TRUE if object was removed

@{b}   SEE ALSO@{ub}
	@{"RemNamedObject()" Link "RemNamedObject()"}, @{"AddNamedObject()" Link "AddNamedObject()"}, @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}

@EndNode

@Node "CallHookPkt()" "utility.library/CallHookPkt"

@{b}   NAME@{ub}
	CallHookPkt -- invoke a @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} function callback. (V36)

@{b}   SYNOPSIS@{ub}
	return = CallHookPkt(hook,object,message);
	D0		     A0   A2	 A1

	ULONG CallHookPkt(struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *,@{"APTR" Link "INCLUDE:exec/types.h/Main" 75},APTR);

@{b}   FUNCTION@{ub}
	Performs the callback standard defined by a @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} structure.
	This function is really very simple; it effectively performs
	a JMP to Hook->h_Entry.

	It is probably just as well to do this operation in an
	assembly language function linked in to your program, possibly
	from a compiler supplied library or a builtin function.

	It is anticipated that C programs will often call a 'varargs'
	variant of this function which will be named @{"CallHook" Link "amiga_lib/CallHook()"}. This
	function must be provided in a compiler specific library, but
	an example of use would be:

	result = CallHook(hook,dataobject,COMMAND_ID,param1,param2);

	The function @{"CallHook()" Link "amiga_lib/CallHook()"} can be implemented in many C compilers
	like this:

	ULONG CallHook(struct @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} *hook, @{"APTR" Link "INCLUDE:exec/types.h/Main" 75} object, ULONG command, ... )
	{
	    return(CallHookPkt(hook,object,(APTR)&command));
	}

@{b}   INPUTS@{ub}
	hook - pointer to an initialized @{"Hook" Link "INCLUDE:utility/hooks.h/Main" 26} structure as defined in
	       @{"<utility/hooks.h>" Link "INCLUDE:utility/hooks.h/Main" 0}
	object - useful data structure in the particular context the hook is
		 being used for.
	message - pointer to a message to be passed to the hook. This is not
		  an Exec @{"Message" Link "INCLUDE:exec/ports.h/Main" 45} structure, but is a message in the OOP sense.

@{b}   RESULTS@{ub}
	return - the value returned by the hook function.

@{b}   WARNING@{ub}
	The functions called through this function should follow normal
	register conventions unless EXPLICITLY documented otherwise (and
	they have a good reason too).

@{b}   SEE ALSO@{ub}
	@{"<utility/hooks.h>" Link "INCLUDE:utility/hooks.h/Main" 0}

@EndNode

@Node "CheckDate()" "utility.library/CheckDate"

@{b}   NAME@{ub}
	CheckDate -- checks a @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure for legal date. (V36)

@{b}   SYNOPSIS@{ub}
	seconds = CheckDate(date);
	D0                  A0

	ULONG CheckDate(struct @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} *);

@{b}   FUNCTION@{ub}
	Determines if the @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure contains legal date information
	and returns the number of seconds from 01-Jan-1978 to that date, or 0
	if the @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure contains illegal data.

@{b}   INPUTS@{ub}
	date - a filled-in @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure

@{b}   RESULTS@{ub}
	seconds	- 0 if date is invalid, otherwise the number of seconds from
		  01-Jan-1978 to the date

@{b}   BUGS@{ub}
	The wday field of the @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure is not checked.

@{b}   SEE ALSO@{ub}
	@{"Amiga2Date()" Link "Amiga2Date()"}, @{"Date2Amiga()" Link "Date2Amiga()"}

@EndNode

@Node "CloneTagItems()" "utility.library/CloneTagItems"

@{b}   NAME@{ub}
	CloneTagItems -- copy a tag list. (V36)

@{b}   SYNOPSIS@{ub}
	clone = CloneTagItems(original);
	D0		      A0

	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *CloneTagItems(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	Copies the essential contents of a tag list into a new tag list.

	The cloning is such that calling @{"FindTagItem()" Link "FindTagItem()"} with a given tag on
	the original or cloned tag lists will always return the same
	tag value. That is, the ordering of the tags is maintained.

@{b}   INPUTS@{ub}
	original - tag list to clone. May be @{"NULL" Link "rexxsupport/NULL"}, in which case an
		   empty tag list is returned.

@{b}   RESULTS@{ub}
	clone - copy of the original tag list, or @{"NULL" Link "rexxsupport/NULL"} if there was not enough
		memory. This tag list must eventually by freed by calling
		@{"FreeTagItems()" Link "FreeTagItems()"}.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"AllocateTagItems()" Link "AllocateTagItems()"}, @{"FreeTagItems()" Link "FreeTagItems()"},
	@{"RefreshTagItemClones()" Link "RefreshTagItemClones()"}

@EndNode

@Node "Date2Amiga()" "utility.library/Date2Amiga"

@{b}   NAME@{ub}
	Date2Amiga -- calculate seconds from 01-Jan-1978. (V36)

@{b}   SYNOPSIS@{ub}
	seconds = Date2Amiga(date);
	D0                   A0

	ULONG Date2Amiga(struct @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} *);

@{b}   FUNCTION@{ub}
	Calculates the number of seconds from 01-Jan-1978 to the date
	specified in the @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure.

@{b}   INPUTS@{ub}
	date - pointer to a @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22} structure containing the date of
	       interest.

@{b}   RESULTS@{ub}
	seconds	- the number of seconds from 01-Jan-1978 to the date specified.

@{b}   WARNING@{ub}
	This function does no sanity checking of the data in the @{"ClockData" Link "INCLUDE:utility/date.h/Main" 22}
	structure.

@{b}   SEE ALSO@{ub}
	@{"Amiga2Date()" Link "Amiga2Date()"}, @{"CheckDate()" Link "CheckDate()"}

@EndNode

@Node "FilterTagChanges()" "utility.library/FilterTagChanges"

@{b}   NAME@{ub}
	FilterTagChanges -- eliminate tags which specify no change. (V36)

@{b}   SYNOPSIS@{ub}
	FilterTagChanges(changeList,originalList,apply);
			 A0	    A1           D0

	VOID FilterTagChanges(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *, struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *, ULONG);

@{b}   FUNCTION@{ub}
	This function goes through changeList. For each item found in
	changeList, if the item is also present in originalList, and their
	data values are identical, then the tag is removed from changeList.
	If the two tag's data values are different and the 'apply' value is
	non-zero, then the tag data in originalList will be updated to match
	the value from changeList.

@{b}   INPUTS@{ub}
	changeList - list of new tags (may be NULL)
	originalList - a list of existing tags (may be NULL)
	apply - boolean specification as to whether the data values in
		originalList are to be updated to the data values in
		changeList.

@{b}   EXAMPLE@{ub}
	Assume you have an attribute list for an object (originalList)
	which looks like this:

		{ATTR_Size,  "large"},
		{ATTR_Color, "orange"},
		{ATTR_Shape, "square"}

	If you receive a new tag list containing some changes (changeList),
	which looks like this:

		{ATTR_Size,  "large"},
		{ATTR_Shape, "triangle"}

	If you call FilterTagChanges(), changeList will be modified to
	contain only those attributes which are different from those
	in originalList. All other items will have their tag values set to
	TAG_IGNORE. The resulting changeList will become:

		{TAG_IGNORE, "large"},
		{ATTR_Shape, "triangle"}

	If 'apply' was set to 0, originalList would be unchanged. If 'apply'
	was non-zero, originalList would be changed to:

		{ATTR_Size,  "large"},
		{ATTR_Color, "orange"},
		{ATTR_Shape, "triangle"}

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}

@EndNode

@Node "FilterTagItems()" "utility.library/FilterTagItems"

@{b}   NAME@{ub}
	FilterTagItems -- remove selected items from a tag list. (V36)

@{b}   SYNOPSIS@{ub}
	numValid = FilterTagItems(tagList,filterArray,logic);
	D0		          A0	  A1	      D0

	ULONG FilterTagItems(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *,@{"Tag" Link "INCLUDE:utility/tagitem.h/Main" 28} *,ULONG);

@{b}   FUNCTION@{ub}
	Removes tag items from a tag list (by changing ti_Tag to
	TAG_IGNORE) depending on whether its ti_Tag value is
	found in an array of tag values.

	If the 'logic' parameter is TAGFILTER_AND, then all items
	not appearing in 'tagArray' are excluded from 'tagList'.

	If 'logic' is TAGFILTER_NOT, then items not found in 'tagArray'
	are preserved, and the ones in the array are cast out.

@{b}   INPUTS@{ub}
	tagList	- input list of tag items which is to be filtered by having
		  selected items changed to TAG_IGNORE.
	filterArray - an array of tag values, terminated by TAG_DONE, as
		      specified in the documentation for @{"TagInArray()" Link "TagInArray()"}.
	logic - specification whether items in 'tagArray' are to be included
		or excluded in the filtered result.

@{b}   RESULTS@{ub}
	numValid - number of valid items left in resulting filtered list.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"TagInArray()" Link "TagInArray()"}

@EndNode

@Node "FindNamedObject()" "utility.library/FindNamedObject"

@{b}   NAME@{ub}
	FindNamedObject -- find the next object of a given name. (V39)

@{b}   SYNOPSIS@{ub}
	object = FindNamedObject(nameSpace, name, lastObject);
	D0                       A0         A1    A2

	struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *FindNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *, @{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137},
					    struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Finds an object and adds to the open count of the object. The
	object is guaranteed not to be freed until @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"} is
	called. The name comparison is caseless, using the current
	locale string comparison routines.

	If name is @{"NULL" Link "rexxsupport/NULL"}, then all objects will be matched.

	If lastObject is non-NULL, it must be an object from the same
	NameSpace found on a previous call to FindNamedObject(). It
	will not be freed by this call. The search will start at the
	node after lastobject, if non-NULL.

	nameSpace is the name space from the named object given
	or the root name space if @{"NULL" Link "rexxsupport/NULL"} is given.

@{b}   INPUTS@{ub}
	nameSpace - the name space to search
	name - the name of the object to search for
	lastObject - the starting point for the search or @{"NULL" Link "rexxsupport/NULL"}

@{b}   RESULT@{ub}
	object - the first match found, or @{"NULL" Link "rexxsupport/NULL"} for no match

@{b}   SEE ALSO@{ub}
	@{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}, @{"<utility/name.h>" Link "INCLUDE:utility/name.h/Main" 0}

@EndNode

@Node "FindTagItem()" "utility.library/FindTagItem"

@{b}   NAME@{ub}
	FindTagItem -- scan a tag list for a specific tag. (V36)

@{b}   SYNOPSIS@{ub}
	tag = FindTagItem(tagValue,tagList);
	D0		  D0	   A0

	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *FindTagItem(Tag,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	Scans a tag list and returns a pointer to the first item with
	ti_Tag matching the 'tagValue' parameter.

@{b}   INPUTS@{ub}
	tagValue - tag value to search for
	tagList	- tag item list to search (may be NULL)

@{b}   RESULTS@{ub}
	tag - a pointer to the item with ti_Tag matching 'tagValue' or @{"NULL" Link "rexxsupport/NULL"}
	      if no match was found.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"NextTagItem()" Link "NextTagItem()"}

@EndNode

@Node "FreeNamedObject()" "utility.library/FreeNamedObject"

@{b}   NAME@{ub}
	FreeNamedObject -- frees a name object. (V39)

@{b}   SYNOPSIS@{ub}
	FreeNamedObject(object);
			A0

	VOID FreeNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Free one of a number of structures used by utility.library.
	The item must not be a member of any NameSpace, and no one
	may have it open other than yourself. If the object also
	contained a NameSpace, that namespace must be empty.
	Any additional space allocated via the datasize parameter
	for AllocNamedObject() is also released.

@{b}   INPUTS@{ub}
	object - the object to be freed

@{b}   SEE ALSO@{ub}
	@{"AllocNamedObjectA()" Link "AllocNamedObjectA()"}

@EndNode

@Node "FreeTagItems()" "utility.library/FreeTagItems"

@{b}   NAME@{ub}
	FreeTagItems -- free an allocated tag list. (V36)

@{b}   SYNOPSIS@{ub}
	FreeTagItems(tagList);
		     A0

	VOID FreeTagItems(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	Frees the memory of a @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} list allocated either by
	@{"AllocateTagItems()" Link "AllocateTagItems()"} or @{"CloneTagItems()" Link "CloneTagItems()"}.

@{b}   INPUTS@{ub}
	tagList - list to free, must have been obtained from
		  @{"AllocateTagItems()" Link "AllocateTagItems()"} or @{"CloneTagItems()" Link "CloneTagItems()"} (may be NULL)

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"AllocateTagItems()" Link "AllocateTagItems()"}, @{"CloneTagItems()" Link "CloneTagItems()"}

@EndNode

@Node "GetTagData()" "utility.library/GetTagData"

@{b}   NAME@{ub}
	GetTagData -- obtain the data corresponding to a tag. (V36)

@{b}   SYNOPSIS@{ub}
	value = GetTagData(tagValue,defaultVal,tagList);
	D0		   D0	    D1	       A0

	ULONG GetTagData(Tag,ULONG,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	Searches a tag list for a matching tag, and returns the
	corresponding ti_Data value for the @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} found. If no match is
	found, this function returns the value passed in as 'default'.

@{b}   INPUTS@{ub}
	tagValue - tag value to search for.
	defaultVal - value to be returned if tagValue is not found.
	tagList - the tag list to search.

@{b}   RESULTS@{ub}
	value - the ti_Data value for the first matching @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30}, or 'default'
		if a ti_Tag matching 'Tag' is not found.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"NextTagItem()" Link "NextTagItem()"}

@EndNode

@Node "GetUniqueID()" "utility.library/GetUniqueID"

@{b}   NAME@{ub}
	GetUniqueID -- return a relatively unique number. (V39)

@{b}   SYNOPSIS@{ub}
	id = GetUniqueID();
	D0

	ULONG GetUniqueID(VOID);

@{b}   FUNCTION@{ub}
	Returns a unique value each time it is called. This is useful for
	things that need unique ID such as the GadgetHelp ID, etc.
	Note that this is only unique for 4,294,967,295 calls to this
	function. Under normal use this is not a problem.
	This function is safe in interrupts.

@{b}   RESULT@{ub}
	id - a 32-bit value that is unique.

@EndNode

@Node "MapTags()" "utility.library/MapTags"

@{b}   NAME@{ub}
	MapTags	-- convert ti_Tag values in a list via map pairing. (V36)

@{b}   SYNOPSIS@{ub}
	MapTags(tagList,mapList,mapType);
		A0	A1      D0

	VOID MapTags(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *,ULONG);

@{b}   FUNCTION@{ub}
	Apply a "mapping list" mapList to tagList.

	If the ti_Tag field of an item in tagList appears as ti_Tag in some
	item in mapList, overwrite ti_Tag with the corresponding ti_Data
	from the map list.

	The mapType parameter specifies how the mapping operation is to
	proceed, with the following available types:

		MAP_REMOVE_NOT_FOUND
		If a tag in tagList does not appear in the mapList, remove
		it from tagList.

		MAP_KEEP_NOT_FOUND
		To have items which do not appear in the mapList survive the
		mapping process as-is.

	MapTags() is central to BOOPSI gadget interconnections where you want
	to convert the tag values from one space (the sender) to another (the
	receiver).

	The procedure will change the values of the input tag list
	tagList (but not mapList).

	You can "filter" a list by passing MAP_REMOVE_NOT_FOUND as mapType,
	and having the data items in mapList equal the corresponding tags.

	You can perform the inverse filter ("everything but") by passing
	a mapType of MAP_KEEP_NOT_FOUND, and creating a map item for every tag
	you want to filter out, pairing it with a mapped data value of
	TAG_IGNORE.

	For safety and "order independence" of tag item arrays, if you
	attempt to map some tag to the value TAG_DONE, the value TAG_IGNORE
	will be substituted instead.

@{b}   INPUTS@{ub}
	tagList	- input list of tag items which is to be mapped to tag values
		  as specified in mapList.
	mapList - a "mapping list" tag list which pairs tag values expected to
		  appear in tagList with new values to be substituted in the
		  ti_Tag fields of tagList (may be NULL)
	mapType - one of the available mapping types as defined in
		  @{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}

@{b}   EXAMPLE@{ub}
	\* Consider this source list: *\
	    struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} list[] =
	    {
		{MY_SIZE, 	71},
		{MY_WEIGHT, 	200},
		{TAG_DONE,	}
           };

	\* And the mapping list: *\
	    struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} map[] =
	    {
		{MY_SIZE, 	HIS_TALL},
		{TAG_DONE,	}
	    };

	\* Then after MapTags(list,map,MAP_REMOVE_NOT_FOUND), 'list' will
	   become: *\
		{HIS_TALL,71},
		{TAG_IGNORE,},
		{TAG_DONE,}

	\* Or after MapTags(list,map,MAP_KEEP_NOT_FOUND), 'list' will
	   become: *\
		{HIS_TALL,  71},
		{MY_WEIGHT, 200},
		{TAG_DONE,  }

@{b}   BUGS@{ub}
	Prior to V39, the mapType parameter did not work. The function
	always behaved as if the parameter was set to MAP_KEEP_NOT_FOUND.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}, @{"FilterTagChanges()" Link "FilterTagChanges()"}

@EndNode

@Node "NamedObjectName()" "utility.library/NamedObjectName"

@{b}   NAME@{ub}
	NamedObjectName -- return the name of the object. (V39)

@{b}   SYNOPSIS@{ub}
	name = NamedObjectName(object);
	D0                     A0

	@{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137} NamedObjectName(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Returns the name of the object passed in...
	Note that the name string is passed back as just a pointer to
	a read-only name. If the object goes away, so does the name.

@{b}   INPUTS@{ub}
	object - the object, may be @{"NULL" Link "rexxsupport/NULL"} in which case this function
		 returns @{"NULL" Link "rexxsupport/NULL"}.

@{b}   RESULT@{ub}
	name - pointer to the name string, or @{"NULL" Link "rexxsupport/NULL"} if 'object' is @{"NULL" Link "rexxsupport/NULL"}.

@{b}   SEE ALSO@{ub}
	@{"FindNamedObject()" Link "FindNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}

@EndNode

@Node "NextTagItem()" "utility.library/NextTagItem"

@{b}   NAME@{ub}
	NextTagItem -- iterate through a tag list. (V36)

@{b}   SYNOPSIS@{ub}
	tag = NextTagItem(tagItemPtr);
	D0		  A0

	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *NextTagItem(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} **);

@{b}   FUNCTION@{ub}
	Iterates through a tag list, skipping and chaining as dictated by
	system tags. TAG_SKIP will cause it to skip the entry and a number
	of following tags as specified in ti_Data. TAG_IGNORE ignores that
	single entry, and TAG_MORE has a pointer to another array of tags (and
	terminates the current array!). TAG_DONE also terminates the current
	array. Each call returns either the next tagitem you should examine,
	or @{"NULL" Link "rexxsupport/NULL"} when the end of the list has been reached.

@{b}   INPUTS@{ub}
	tagItemPtr - doubly-indirect reference to a @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} structure.
		     The pointer will be changed to keep track of the
		     iteration.

@{b}   RESULTS@{ub}
	nextTag	- each @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} in the array or chain of arrays that should be
		  processed according to system tag values defined in
		  @{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}) is returned in turn with successive
		  calls.

@{b}   EXAMPLE@{ub}
	Iterate(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *tags);
	{
	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *tstate;
	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *tag;

	    tstate = tags;
	    while (tag = NextTagItem(&tstate))
	    {
		switch (tag->ti_Tag)
		{
 		    case TAG1: ...
			       break;

 		    case TAG2: ...
			       break;

		    ...
		}
	    }
   	}

@{b}   WARNING@{ub}
	Do NOT use the value of *tagItemPtr, but rather use the pointer
	returned by NextTagItem().

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"PackBoolTags()" Link "PackBoolTags()"}, @{"FindTagItem()" Link "FindTagItem()"}

@EndNode

@Node "PackBoolTags()" "utility.library/PackBoolTags"

@{b}   NAME@{ub}
	PackBoolTags -- builds a "flag" word from a tag list. (V36)

@{b}   SYNOPSIS@{ub}
	flags = PackBoolTags(initialFlags,tagList,boolMap);
	D0		     D0		  A0      A1

	ULONG PackBoolTags(ULONG,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	Picks out the boolean tag items in a tag list and converts
	them into bit-flag representations according to a correspondence
	defined by the tag list 'boolMap'.

	A boolean tag item is one where only the logical value of
	the ti_Data is relevant. If this field is 0, the value is
	FALSE, otherwise TRUE.

@{b}   INPUTS@{ub}
	initialFlags - a starting set of bit-flags which will be changed
		       by the processing of TRUE and FALSE boolean tags
		       in tagList.
	tagList	- a @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} list which may contain several tag items defined to
		  be boolean by their presence in boolMap. The logical value of
		  ti_Data determines whether a tag item causes the bit-flag
		  value related by boolMap to be set or cleared in the returned
		  flag longword.
	boolMap	- a tag list defining the boolean tags to be recognized, and
		  the bit (or bits) in the returned longword that are to be set
		  or cleared when a boolean @{"Tag" Link "INCLUDE:utility/tagitem.h/Main" 28} is found to be TRUE or FALSE in
		  tagList.

@{b}   RESULTS@{ub}
	flags - the accumulated longword of bit-flags, starting with
		initialFlags and modified by each boolean tag item
		encountered.

@{b}   EXAMPLE@{ub}
	\* define some nice user tag values ... *\
	enum mytags { tag1 = TAG_USER+1, tag2, tag3, tag4, tag5 };

	\* this @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} list defines the correspondence between boolean tags
	 * and bit-flag values.
	 *\
	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} boolMap[] =
	{
	    {tag1,     0x0001},
	    {tag2,     0x0002},
	    {tag3,     0x0004},
	    {tag4,     0x0008},
	    {TAG_DONE, }
	};

	\* You are probably passed these by some client, and you want
	 * to "collapse" the boolean content into a single longword.
	 *\

	struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} boolExample[] =
	{
	    {tag1,     TRUE},
	    {tag2,     FALSE},
	    {tag5,     Irrelevant},
	    {tag3,     TRUE},
	    {TAG_DONE, }
	};

	\* Perhaps 'boolFlags' already has a current value of 0x800002. *\
	boolFlags = PackBoolTags(boolFlags,boolExample,boolMap);

	\* The resulting new value of 'boolFlags' will be 0x80005. \*

@{b}   WARNING@{ub}
	In a case where there is duplication of a tag in tagList, the
	last of the identical tags will hold sway.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"GetTagData()" Link "GetTagData()"}, @{"FindTagItem()" Link "FindTagItem()"}, @{"NextTagItem()" Link "NextTagItem()"}

@EndNode

@Node "PackStructureTags()" "utility.library/PackStructureTags"

@{b}   NAME@{ub}
	PackStructureTags -- pack a structure with values from taglist. (V39)

@{b}   SYNOPSIS@{ub}
	num = PackStructureTags(pack,packTable,tagList);
	D0                      A0   A1        A2

	ULONG PackStructureTags(APTR,ULONG *,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	For each table entry, a @{"FindTagItem()" Link "FindTagItem()"} will be done and if the
	matching tag is found in the taglist, the data field will be
	packed into the given structure based on the packtable
	definition.

@{b}   INPUTS@{ub}
	pack - a pointer to the data area to fill in.
	packTable - a pointer to the packing information table.
		    See @{"<utility/pack.h>" Link "INCLUDE:utility/pack.h/Main" 0} for definition and macros.
	tagList - a pointer to the taglist to pack into the structure

@{b}   RESULTS@{ub}
	num - the number of tag items packed

@{b}   SEE ALSO@{ub}
	@{"<utility/pack.h>" Link "INCLUDE:utility/pack.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"UnpackStructureTags()" Link "UnpackStructureTags()"}

@EndNode

@Node "RefreshTagItemClones()" "utility.library/RefreshTagItemClones"

@{b}   NAME@{ub}
	RefreshTagItemClones -- rejuvenate a clone from the original. (V36)

@{b}   SYNOPSIS@{ub}
	RefreshTagItemClones(clone,original)
			     A0	   A1

	VOID RefreshTagItemClones(struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	If (and only if) the tag list 'clone' was created from 'original' by
	@{"CloneTagItems()" Link "CloneTagItems()"}, and if 'original' has not been changed in any way,
	you can reset the clone list to its original state by using this
	function.

@{b}   INPUTS@{ub}
	clone - return value from CloneTagItems(original)
	original - a tag list that hasn't changed since @{"CloneTagItems()" Link "CloneTagItems()"}

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"CloneTagItems()" Link "CloneTagItems()"}, @{"AllocateTagItems()" Link "AllocateTagItems()"},
	@{"FreeTagItems()" Link "FreeTagItems()"}, @{"ApplyTagChanges()" Link "ApplyTagChanges()"}

@EndNode

@Node "ReleaseNamedObject()" "utility.library/ReleaseNamedObject"

@{b}   NAME@{ub}
	ReleaseNamedObject -- free a named object. (V39)

@{b}   SYNOPSIS@{ub}
	ReleaseNamedObject(object);
			   A0

	VOID ReleaseNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *);

@{b}   FUNCTION@{ub}
	Decrements the open count of the object. If the object has been
	removed, and the count goes to 0, the remover will be notified
	that the object is now free.

@{b}   INPUTS@{ub}
	object - the object to release.  (No action if NULL)

@{b}   SEE ALSO@{ub}
	@{"FindNamedObject()" Link "FindNamedObject()"}, @{"RemNamedObject()" Link "RemNamedObject()"}

@EndNode

@Node "RemNamedObject()" "utility.library/RemNamedObject"

@{b}   NAME@{ub}
	RemNamedObject -- remove a named object. (V39)

@{b}   SYNOPSIS@{ub}
	RemNamedObject(object, message);
	               A0      A1

	VOID RemNamedObject(struct @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23} *, struct @{"Message" Link "INCLUDE:exec/ports.h/Main" 45} *);

@{b}   FUNCTION@{ub}
	This function will post a request to release the object
	from whatever NameSpace it is in.  It will reply the message
	when the object is fully removed.  The message.mn_Node.ln_Name
	field will contain the object pointer or @{"NULL" Link "rexxsupport/NULL"} if the object
	was removed by another process.

	This function will effectively do a @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}
	thus you must have "found" the object first.

@{b}   INPUTS@{ub}
	object - the object to remove: Must be a valid @{"NamedObject" Link "INCLUDE:utility/name.h/Main" 23}.
	message - message to @{"ReplyMsg()" Link "exec/ReplyMsg()"} (must be supplied)

@{b}   RESULT@{ub}
	The message is replied with the ln_Name field either being
	the object or @{"NULL" Link "rexxsupport/NULL"}. If it contains the object, the object
	is completely removed.

@{b}   SEE ALSO@{ub}
	@{"AttemptRemNamedObject()" Link "AttemptRemNamedObject()"}, @{"AddNamedObject()" Link "AddNamedObject()"}, @{"ReleaseNamedObject()" Link "ReleaseNamedObject()"}

@EndNode

@Node "SDivMod32()" "utility.library/SDivMod32"

@{b}   NAME@{ub}
	SDivMod32 -- signed 32 by 32 bit division and modulus. (V36)

@{b}   SYNOPSIS@{ub}
	quotient:remainder = SDivMod32(dividend,divisor);
	D0       D1                    D0       D1

	@{"LONG:LONG" Link "INCLUDE:exec/types.h/Main" 112} SDivMod32(LONG,LONG);

@{b}   FUNCTION@{ub}
	Divides the signed 32 bit dividend by the signed 32 bit divisor
	and returns a signed 32 bit quotient and remainder.

@{b}   INPUTS@{ub}
	dividend - signed 32 bit dividend.
	divisor - signed 32 bit divisor.

@{b}   RESULTS@{ub}
	quotient - signed 32 quotient of the division.
	remainder - signed 32 remainder of the division.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"},
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "SDivMod64()" "utility.library/SDivMod64"

@{b}   NAME@{ub}
	SDivMod64 -- signed 64 by 32 division with 32 bit result (V47)

@{b}   SYNOPSIS@{ub}
	result = SDivMod64(dividendhi,dividendlo,divisor);
	D0:D1               D1   	D0	D2

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} SDivMod64(LONG,ULONG,LONG);

@{b}   FUNCTION@{ub}
	Returns the quotient of the unsigned 64 bit division of the
	divisor in registers D1 and D0, with the upper 32 bits in D1,
	by the divisor in D2 in D0. The remainder is returned in D1.

@{b}   INPUTS@{ub}
	dividendhi, dividendlo: upper and lower 32 bits of the dividend
	divisor: 32 bit divisor

@{b}   RESULTS@{ub}
	result - the 32 bit quotient in D0 and the remainder in D1
	on overflow, registers are unchanged and the V processor bit
	is set

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}
	@{"UMult64()" Link "UMult64()"}, @{"UDivMod64()" Link "UDivMod64()"}

@EndNode

@Node "SMult32()" "utility.library/SMult32"

@{b}   NAME@{ub}
	SMult32 -- signed 32 by 32 bit multiply with 32 bit result. (V36)

@{b}   SYNOPSIS@{ub}
	result = SMult32(arg1,arg2);
	D0               D0   D1

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} SMult32(LONG,LONG);

@{b}   FUNCTION@{ub}
	Returns the signed 32 bit result of multiplying arg1 by arg2.

@{b}   INPUTS@{ub}
	arg1, arg2 - numbers to multiply

@{b}   RESULTS@{ub}
	result - the signed 32 bit result of multiplying arg1 by arg2.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"},
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "SMult64()" "utility.library/SMult64"

@{b}   NAME@{ub}
	SMult64 -- signed 32 by 32 bit multiply with 64 bit result. (V39)

@{b}   SYNOPSIS@{ub}
	result = SMult64(arg1,arg2);
	D0:D1            D0   D1

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} SMult64(LONG,LONG);

@{b}   FUNCTION@{ub}
	Returns the signed 64 bit result of multiplying arg1 by arg2.

@{b}   INPUTS@{ub}
	arg1, arg2 - numbers to multiply

@{b}   RESULTS@{ub}
	result - the signed 64 bit result of multiplying arg1 by arg2.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"UMult32()" Link "UMult32()"}, @{"UMult64()" Link "UMult64()"},
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "Stricmp()" "utility.library/Stricmp"

@{b}   NAME@{ub}
	Stricmp	-- case-insensitive string comparison. (V37)

@{b}   SYNOPSIS@{ub}
	result = Stricmp(string1,string2);
	D0		 A0      A1

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} Stricmp(STRPTR,STRPTR);

@{b}   FUNCTION@{ub}
	This function compares two strings, ignoring case using a generic
	case conversion routine. If the strings have different lengths,
	the shorter is treated as if it were extended with zeros.

@{b}   INPUTS@{ub}
	string1, string2 - strings to be compared

@{b}   RESULTS@{ub}
	result - relationship between string1 and string2
			<0 means string1 < string2
			=0 means string1 = string2
			>0 means string1 > string2

@{b}   NOTES@{ub}
	Whenever locale.library is installed in a system, this function is
	replaced by language-specific code. This means that depending on
	which language the user has currently selected, identical pairs of
	strings may return different values when passed to this function.
	This fact must be taken into consideration when using this function.

@{b}   SEE ALSO@{ub}
	@{"Strnicmp()" Link "Strnicmp()"}, @{"locale.library/StrnCmp()" Link "locale/StrnCmp()"}

@EndNode

@Node "Strncat()" "utility.library/Strncat"

@{b}   NAME@{ub}
	Strncat -- concatenate two strings, length limited (V47)

@{b}   SYNOPSIS@{ub}
	end = Strncat(dst,src,size)
	D0            A1  A0  D0

	@{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *Strncat(UBYTE *dst,const @{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *src,ULONG bufsize);

@{b}   FUNCTION@{ub}
	Appends the source string at the end of the destionation string
	possibly truncating the result to fit to the buffer.
	Returns a pointer to the terminating NUL of the target string,
	or @{"NULL" Link "rexxsupport/NULL"} if the string was truncated.

@{b}   INPUTS@{ub}
	src     - source string to be appended. If @{"NULL" Link "rexxsupport/NULL"}, it is treated as
	          if it were an empty string.
	dst     - buffer to write to, or @{"NULL" Link "rexxsupport/NULL"}. In case the target buffer
	          is @{"NULL" Link "rexxsupport/NULL"}, @{"NULL" Link "rexxsupport/NULL"} is returned immediately.
	bufsize - size of the target buffer in bytes. If this is 0, then
	          no data is copied and @{"NULL" Link "rexxsupport/NULL"} is returned immediately.

@{b}   RESULTS@{ub}
	end     - pointer to the NUL byte of the target string, or @{"NULL" Link "rexxsupport/NULL"}
	          in case the target was truncated.

@{b}   NOTES@{ub}
	The curious return code allows easy chaining of multiple Strncat()
	calls. Even in case the target was truncated, it is always NUL
	terminated.

@{b}   SEE ALSO@{ub}
	@{"RawDoFmt()" Link "exec/RawDoFmt()"}

@EndNode

@Node "Strncpy()" "utility.library/Strncpy"

@{b}   NAME@{ub}
	Strncpy -- copy a string, length limited (V47)

@{b}   SYNOPSIS@{ub}
	end = Strncpy(dst,src,size)
	D0            A1  A0  D0

	@{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *Strncpy(UBYTE *dst,const @{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *src,ULONG bufsize);

@{b}   FUNCTION@{ub}
	Copies one string into another, possibly truncating it to the
	target buffer size. Returns a pointer to the terminating NUL
	of the target string, or @{"NULL" Link "rexxsupport/NULL"} if the target was truncated.

@{b}   INPUTS@{ub}
	src     - source string to be copied. If @{"NULL" Link "rexxsupport/NULL"}, it is treated as
	          if it were an empty string.
	dst     - buffer to write to, or @{"NULL" Link "rexxsupport/NULL"}. In case the target buffer
	          is @{"NULL" Link "rexxsupport/NULL"}, @{"NULL" Link "rexxsupport/NULL"} is returned immediately.
	bufsize - size of the target buffer in bytes. If this is 0, then
	          no data is copied and @{"NULL" Link "rexxsupport/NULL"} is returned immediately.

@{b}   RESULTS@{ub}
	end     - pointer to the NUL byte of the target string, or @{"NULL" Link "rexxsupport/NULL"}
	          in case the target buffer was too short.

@{b}   NOTES@{ub}
	The curious return code allows easy chaining of multiple Strncpy()
	calls, i.e. Strncpy(src2,Strncpy(src1,buffer,size),size) concatenates
	the source strings src1 and src2 in the same buffer. Note that even
	if the target buffer is too small, a partial copy has been performed
	and the result is still NUL-terminated.

@{b}   SEE ALSO@{ub}
	@{"RawDoFmt()" Link "exec/RawDoFmt()"}

@EndNode

@Node "Strnicmp()" "utility.library/Strnicmp"

@{b}   NAME@{ub}
	Strnicmp -- length-limited case-insensitive string compare. (V37)

@{b}   SYNOPSIS@{ub}
	result = Strnicmp(string1,string2,length);
	D0		  A0      A1	  D0

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} Strnicmp(STRPTR,@{"STRPTR" Link "INCLUDE:exec/types.h/Main" 137},LONG);

@{b}   FUNCTION@{ub}
	This function compares two strings, ignoring case using a generic
	case conversion routine. If the strings have different lengths,
	the shorter is treated as if it were extended with zeros. This function
	never compares more than 'length' characters.

@{b}   INPUTS@{ub}
	string1, string2 - strings to be compared
	length - maximum number of characters to examine

@{b}   RESULTS@{ub}
	result - relationship between string1 and string2
			<0 means string1 < string2
			=0 means string1 = string2
			>0 means string1 > string2

@{b}   NOTES@{ub}
	Whenever locale.library is installed in a system, this function is
	replaced by language-specific code. This means that depending on
	which language the user has currently selected, identical pairs of
	strings may return different values when passed to this function.
	This fact must be taken into consideration when using this function.

@{b}   SEE ALSO@{ub}
	@{"Stricmp()" Link "Stricmp()"}, @{"locale.library/StrnCmp()" Link "locale/StrnCmp()"}

@EndNode

@Node "TagInArray()" "utility.library/TagInArray"

@{b}   NAME@{ub}
	TagInArray -- check if a tag value appears in an array of tag values.
		      (V36)

@{b}   SYNOPSIS@{ub}
	result = TagInArray(tagValue,tagArray);
	D0	            D0	     A0

	@{"BOOL" Link "INCLUDE:exec/types.h/Main" 168} TagInArray(Tag,@{"Tag" Link "INCLUDE:utility/tagitem.h/Main" 28} *);

@{b}   FUNCTION@{ub}
	Performs a quick scan to see if a tag value appears in an array
	terminated with TAG_DONE. Returns TRUE if the value is found.

	The 'tagArray' must be terminated by TAG_DONE. Note that this is an
	array of tag values, NOT an array of TagItems.

@{b}   INPUTS@{ub}
	tagValue - tag value to search array for in array.
	tagArray - a simple array of tag values terminated by TAG_DONE.

@{b}   RESULTS@{ub}
	result - TRUE if tagValue was found in tagArray.

@{b}   SEE ALSO@{ub}
	@{"<utility/tagitem.h>" Link "INCLUDE:utility/tagitem.h/Main" 0}, @{"FilterTagItems()" Link "FilterTagItems()"}

@EndNode

@Node "ToLower()" "utility.library/ToLower"

@{b}   NAME@{ub}
	ToLower -- convert a character to lower case. (V37)

@{b}   SYNOPSIS@{ub}
	char = ToLower(char);
	D0	       D0

	@{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} ToLower(UBYTE);

@{b}   FUNCTION@{ub}
	Converts a character to lower case, handling international character
	sets.

@{b}   INPUTS@{ub}
	char - character to be converted.

@{b}   RESULTS@{ub}
	char - lower case version of the input character.

@{b}   NOTES@{ub}
	Whenever locale.library is installed in a system, this function is
	replaced by language-specific code. This means that depending on
	which language the user has currently selected, a given character may
	return different results when passed to this function. This fact must
	be taken into consideration when using this function.

@{b}   SEE ALSO@{ub}
	@{"ToUpper()" Link "ToUpper()"}, @{"locale.library/ConvToLower()" Link "locale/ConvToLower()"}

@EndNode

@Node "ToUpper()" "utility.library/ToUpper"

@{b}   NAME@{ub}
	ToUpper -- convert a character to upper case. (V37)

@{b}   SYNOPSIS@{ub}
	char = ToUpper(char);
	D0	       D0

	@{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} ToUpper(UBYTE);

@{b}   FUNCTION@{ub}
	Converts a character to upper case, handling international character
	sets.

@{b}   INPUTS@{ub}
	char - character to be converted.

@{b}   RESULTS@{ub}
	char - upper case version of input character.

@{b}   NOTES@{ub}
	Whenever locale.library is installed in a system, this function is
	replaced by language-specific code. This means that depending on
	which language the user has currently selected, a given character may
	return different results when passed to this function. This fact must
	be taken into consideration when using this function.

@{b}   SEE ALSO@{ub}
	ToUpper(), @{"locale.library/ConvToLower()" Link "locale/ConvToLower()"}

@EndNode

@Node "UDivMod32()" "utility.library/UDivMod32"

@{b}   NAME@{ub}
	UDivMod32 -- unsigned 32 by 32 bit division and modulus. (V36)

@{b}   SYNOPSIS@{ub}
	quotient:remainder = UDivMod32(dividend,divisor);
	D0       D1                    D0       D1

	ULONG:ULONG UDivMod32(ULONG,ULONG);

@{b}   FUNCTION@{ub}
	Divides the unsigned 32 bit dividend by the unsigned 32 bit divisor
	and returns an unsigned 32 bit quotient and remainder.

@{b}   INPUTS@{ub}
	dividend - unsigned 32 bit dividend.
	divisor - unsigned 32 bit divisor.

@{b}   RESULTS@{ub}
	quotient - unsigned 32 quotient of the division.
	remainder - unsigned 32 remainder of the division.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UMult32()" Link "UMult32()"}
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "UDivMod64()" "utility.library/UDivMod64"

@{b}   NAME@{ub}
	UDivMod64 -- unsigned 64 by 32 division with 32 bit result (V47)

@{b}   SYNOPSIS@{ub}
	result = UDivMod64(dividendhi,dividendlo,divisor);
	D0:D1               D1   	D0	D2

	ULONG UDivMod64(ULONG,ULONG,ULONG);

@{b}   FUNCTION@{ub}
	Returns the quotient of the unsigned 64 bit division of the
	divisor in registers D1 and D0, with the upper 32 bits in D1,
	by the divisor in D2 in D0. The remainder is returned in D1.

@{b}   INPUTS@{ub}
	dividendhi, dividendlo: upper and lower 32 bits of the dividend
	divisor: 32 bit divisor

@{b}   RESULTS@{ub}
	result - the 32 bit quotient in D0 and the remainder in D1
	on overflow, registers are unchanged and the V processor bit
	is set

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}
	@{"UMult64()" Link "UMult64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "UMult32()" "utility.library/UMult32"

@{b}   NAME@{ub}
	UMult32 -- unsigned 32 by 32 bit multiply with 32 bit result. (V36)

@{b}   SYNOPSIS@{ub}
	result = UMult32(arg1,arg2);
	D0               D0   D1

	ULONG UMult32(ULONG,ULONG);

@{b}   FUNCTION@{ub}
	Returns the unsigned 32 bit result of multiplying arg1 by arg2.

@{b}   INPUTS@{ub}
	arg1, arg2 - numbers to multiply

@{b}   RESULTS@{ub}
	result - the unsigned 32 bit result of multiplying arg1 by arg2.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}, @{"UMult64()" Link "UMult64()"}
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "UMult64()" "utility.library/UMult64"

@{b}   NAME@{ub}
	UMult64 -- unsigned 32 by 32 bit multiply with 64 bit result. (V39)

@{b}   SYNOPSIS@{ub}
	result = UMult64(arg1,arg2);
	D0:D1               D0   D1

	ULONG UMult64(ULONG,ULONG);

@{b}   FUNCTION@{ub}
	Returns the unsigned 64 bit result of multiplying arg1 by arg2.

@{b}   INPUTS@{ub}
	arg1, arg2 - numbers to multiply

@{b}   RESULTS@{ub}
	result - the unsigned 64 bit result of multiplying arg1 by arg2.

@{b}   NOTES@{ub}
	Unlike other Amiga library function calls, the utility.library
	32 bit math routines do NOT require A6 to be loaded with a
	pointer to the library base. A6 can contain anything the application
	wishes. This is in order to avoid overhead in calling them.

	In addition, the utility.library math routines preserve all
	address registers including A0 and A1

@{b}   SEE ALSO@{ub}
	@{"SDivMod32()" Link "SDivMod32()"}, @{"SMult32()" Link "SMult32()"}, @{"UDivMod32()" Link "UDivMod32()"}, @{"SMult64()" Link "SMult64()"}
	@{"UDivMod64()" Link "UDivMod64()"}, @{"SDivMod64()" Link "SDivMod64()"}

@EndNode

@Node "UnpackStructureTags()" "utility.library/UnpackStructureTags"

@{b}   NAME@{ub}
	UnpackStructureTags -- unpack a structure to values in taglist. (V39)

@{b}   SYNOPSIS@{ub}
	num = UnpackStructureTags(pack,packTable,tagList);
	D0                        A0   A1        A2

	ULONG UnpackStructureTags(APTR,ULONG *,struct @{"TagItem" Link "INCLUDE:utility/tagitem.h/Main" 30} *);

@{b}   FUNCTION@{ub}
	For each table entry, a @{"FindTagItem()" Link "FindTagItem()"} will be done and if the
	matching tag is found in the taglist, the data in the structure
	will be placed into the memory pointed to by the tag's ti_Data.
	ti_Data *must* point to a LONGWORD.

@{b}   INPUTS@{ub}
	pack - a pointer to the data area to be unpacked
	packTable - a pointer to the packing information table.
		    See @{"<utility/pack.h>" Link "INCLUDE:utility/pack.h/Main" 0} for definition and macros
	tagList - a pointer to the taglist to unpack into

@{b}   RESULTS@{ub}
	num - the number of tag items unpacked

@{b}   SEE ALSO@{ub}
	@{"<utility/pack.h>" Link "INCLUDE:utility/pack.h/Main" 0}, @{"FindTagItem()" Link "FindTagItem()"}, @{"PackStructureTags()" Link "PackStructureTags()"}

@EndNode

@Node "VSNPrintf()" "utility.library/VSNPrintf"

@{b}   NAME@{ub}
	VSNPrintf -- print formatted data, length limited (V47)

@{b}   SYNOPSIS@{ub}
	length = VSNPrintf(buffer,bufsize,fmt,data)
	D0                 A0     D0      A1, A2

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} VSNPrintf(UBYTE *buffer,ULONG bufsize,const @{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *fmt,@{"APTR" Link "INCLUDE:exec/types.h/Main" 75} data);

	@{"LONG" Link "INCLUDE:exec/types.h/Main" 112} SNPrintf(UBYTE *buffer,ULONG bufsize,const @{"UBYTE" Link "INCLUDE:exec/types.h/Main" 97} *fmt,...);

@{b}   FUNCTION@{ub}
	Prints formatted data using the format instructions of @{"RawDoFmt()" Link "exec/RawDoFmt()"}
	into a length-limited buffer, and returns the full number of
	characters (including NUL) that would have been written in total
	for an unlimited buffer size.

@{b}   INPUTS@{ub}
	buffer  - buffer to write to, or @{"NULL" Link "rexxsupport/NULL"} if only the size of the
	          required buffer is to be determined
	bufsize - buffer size into which the output is to fit
	fmt     - format string, using the formatting instructions of
	          @{"RawDoFmt()" Link "exec/RawDoFmt()"}, see there for details
	data    - data stream containing the source to be formatted

@{b}   RESULTS@{ub}
	length  - buffer size required for the output. This may be
	          larger than the buffer

@{b}   NOTES@{ub}
	The output is always NUL terminated if a buffer is supplied and
	its size is non-zero. The return code of this function indicates
	the size the output buffer must at least have to hold the full
	formatted output, INCLUDING the NUL byte. Note that this is different
	from the ANSI function which returns the (hypothetical) string size.

	Starting with version 47.3, both the LVO and the argument register
	order of this function have been changed for compatibility reasons.
	Make sure to have a recent copy of the AmigaOS include files so that
	your applications use the correct API to call VSNPrintf().

@{b}   SEE ALSO@{ub}
	@{"RawDoFmt()" Link "exec/RawDoFmt()"}

@EndNode

