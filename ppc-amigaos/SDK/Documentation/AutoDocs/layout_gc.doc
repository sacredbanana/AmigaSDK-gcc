TABLE OF CONTENTS

layout.gadget/--datasheet--
layout.gadget/ActivateLayoutGadget
layout.gadget/FlushLayoutDomainCache
layout.gadget/LAYOUT_GetClass
layout.gadget/LayoutLimits
layout.gadget/LM_ADDCHILD
layout.gadget/LM_ADDIMAGE
layout.gadget/LM_MODIFYCHILD
layout.gadget/LM_REMOVECHILD
layout.gadget/RethinkLayout


layout.gadget/--datasheet--                       layout.gadget/--datasheet--

    NAME
    layout.gadget -- An automatic GUI layout arrangement gadget.

    SUPERCLASS
    gadgetclass

    REQUIRES
    bevel.image

    DESCRIPTION
    The layout gadget is used to automatically calculate the
    positions and sizes of BOOPSI gadgets and images in a resizable
    window. Instead of handling the positions of gadgets by hand,
    you can just describe your window layout in a hierarchical
    fashion, and the layout gadget will do the rest.

    The basic method of layout of a group is as follows:
    - Calculate the minimum and maximum size of each gadget.
    - Calculate the weight totals for the group. Subtract the size
      of the fixed size (weighted size 0) gadgets from the total
      size of the group.
    - Distribute the remaining space in the group according to the
      relative weighs of the children.
    - If extra space remains, distribute it evenly between the
      children.

    METHODS
    OM_NEW -- Passed to superclass, then adding all the
              children on the taglist to the private list.

    OM_DISPOSE -- Passed to all children (thus disposing all
                  of them) then to superclass.

    OM_SET -- Passed to superclass after scanning the
              taglist for layout specific tags.

    OM_UPDATE -- Passed to superclass after scanning the
                 taglist for layout specific tags.

    OM_GET -- Passed to superclass for non-layout tags.

    GM_GOACTIVE -- Passed to the currently "active" child (one
                   that returned GM_HITTEST).

    GM_HANDLEINPUT -- Passed to the currently active child.

    GM_GOINACTIVE -- Passed to the currently active child.

    GM_DOMAIN -- Passed to all children.

    GM_RENDER -- Passed to all children.

    GM_LAYOUT -- Passed to all children after first setting
                 their size and position with SetAttrs().

    GM_HITTEST -- Passed to the child in whose domain
                  rectangle the pointer is.

    GM_HELPTEST -- Passed to the child in whose domain
                   rectangle the pointer is.

    GM_KEYGOACTIVE -- Passed to the currently "active" child
                      (one that returned GMR_GADGETHIT).

    GM_KEYGOINACTIVE -- Passed to the currently active child.

    GM_CLIPRECT -- Passed to all children.

    DTM_PROCLAYOUT -- Like GM_LAYOUT but passes DTM_PROCLAYOUT
                      forward. Useful if the layout group
                      contains only datatype objects.

    LM_ADDCHILD -- Add gadget to active layout.

    LM_ADDIMAGE -- Add image to active layout.

    LM_REMOVECHILD -- Remove object from active layout.

    LM_MODIFYCHILD -- Modify object in active layout.

    All other methods are passed to the superclass.

    ATTRIBUTES
    Attributes global to the whole layout group. Pass all of
    these before adding child objects:

    GA_TextAttr (struct TextAttr *)
        The font that will be used for the group label.

        Defaults to NULL (RastPort default font).

        Applicability is (OM_NEW, OM_GET)

    GA_ReadOnly (BOOL)
        Disables input to the entire layout group and its children.
        This tag is not propagated to children. The input blocking
        occurs within the layout object itself.

        Defaults to FALSE

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    GA_Disabled (BOOL)
        Disables entire layout group and its children. This tag
        is propagated all children. When setting/clearing this
        tag, take care to re-set/re-clear any children you want
        included from this mass disabling ability.

        Defaults to FALSE

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    GA_HintInfo (STRPTR)
        If you want the user to receive a gadget help hint for this
        entire layout, set this attributes value to a string to
        display if the mouse pointer is inside the bounds of this
        layout. The hint will only be shown provided no other
        children in the layout have already supplied a hintinfo
        string. In short, this hint is only shown if the pointer
        is in this layout but not over any other gadget with a
        hint string defined.
        As a general rule, gadget help hints are designed to show
        the user a brief help text on the usage of a gadget, so
        showing a text when the pointer is over apparently empty
        space could well lead to confusion, so use with care.

        Defaults to NULL.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_Orientation (uint32)
        Whether the objects of this group are arranged horizontally
        or vertically. Possible values are LAYOUT_ORIENT_HORIZ and
        LAYOUT_ORIENT_VERT.

        Defaults to LAYOUT_ORIENT_HORIZ.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_FixedHoriz (BOOL)
        Whether the width of this layout group is fixed to the width
        assigned by the window or parent layout group. If set to FALSE,
        the gadget will minimize its width to the smallest possible
        value. Generally you will have to also set LAYOUT_ShrinkWrap
        to TRUE also. It is recommended that this tag is used only in
        the top layout group. Using a weighted width of 0 gives
        more predictable results elsewhere.

        Defaults to TRUE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_FixedVert (BOOL)
        Whether the height of this layout group is fixed to the height
        assigned by the window or parent layout group. If set to FALSE,
        the gadget will minimize its height to the smallest possible
        value. Generally you will have to also set LAYOUT_ShrinkWrap
        to TRUE also. It is recommended that this tag is used only in
        the top layout group. Using a weighted height of 0 gives
        more predictable results elsewhere.

        Defaults to TRUE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_HorizAlignment (uint32)
        The horizontal alignment of the objects in this layout group.
        Possible values are LALIGN_LEFT, LALIGN_RIGHT, and
        LALIGN_CENTER.

        Defaults to LALIGN_LEFT.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_VertAlignment (uint32)
        The vertical alignment of the objects in this layout group.
        Possible values are LALIGN_TOP, LALIGN_BOTTOM, and
        LALIGN_CENTER.

        Defaults to LALIGN_TOP.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_ShrinkWrap (BOOL)
        If set to TRUE, the layout group will shrink the interspacing
        of the child objects to minimum. Normally all extra space (if
        the total maximum size of the child objects is less than the
        size of the layoutgroup) is evenly distributed between the
        gadgets.

        Defaults to FALSE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_EvenSize (BOOL)
        If TRUE, the layout group will try to reserve enough space to
        make the minimum size of each child object equal to the minimum
        of the largest child. Using this attribute makes it possible to
        have neatly arranged horizontal rows or grids of gadgets. This
        can take quite a bit of room, however, depending on the gadgets.

        Defaults to FALSE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_SpaceInner (BOOL)
        Should layout leave space between objects or not. Set to FALSE
        if objects in a group should be put immediately beside each
        other.

        Defaults to TRUE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_SpaceOuter (BOOL)
        Should layout leave space around the group's objects or not.
        Set to TRUE if the objects should not be laid out using the
        whole group container box (for example if the group has a
        bevel around it).

        Defaults to FALSE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_InnerSpacing (uint32)
        The minimum space left between objects. The value is in "virtual
        pixels", ie absolute pixels assuming bevel is configured for
        thin lines. If bevel configuration is something else, the value
        will be adjusted accordingly.

        Please avoid using this tag, if you do not require absolute
        control over the spacing. The LAYOUT_SpaceInner boolean is
        provided to tell whether there should be spacing or whether
        objects should be immediately connected to each other.

        Defaults to INTERSPACING.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_TopSpacing (uint32)
    LAYOUT_BottomSpacing (uint32)
    LAYOUT_LeftSpacing (uint32)
    LAYOUT_RightSpacing (uint32)
        The minimum space left to the top, bottom, left and right of
        the group, respectively. This value is in "virtual pixels", see
        LAYOUT_Spacing above.

        Please avoid using this tag, if you do not require absolute
        control over the spacing. The LAYOUT_SpaceOuter boolean is
        provided to tell whether there should be spacing or whether
        objects should be immediately connected to each other.

        If you use one of these tags to override a LAYOUT_SpaceOuter,
        pass this tag after the LAYOUT_SpaceOuter tag.

        Defaults to 0.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_BevelStyle (uint16)
        The style of the bevel drawn around the group. This value is
        passed to bevel.image.

        Defaults to BVS_NONE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_BevelState (uint32)
        The state of the bevel drawn around the group. Used to
        DrawImageState() the bevel.image.

        Defaults to IDS_NORMAL.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    LAYOUT_Label (CONST_STRPTR)
        The label drawn in the group bevel. This value is passed to
        bevel.image. Note that if LAYOUT_BevelStyle is set to BVS_NONE,
        no bevel will be rendered, and thus this label will not be used
        either.

        No default (bevel.image default used)

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_LabelImage (Object *)
        The BOOPSI image to use as the group bevel label.
        Passed to bevel.image.

        See LAYOUT_Label.

        NOTE: bevel.image does not yet implement this feature so
              this tag currently does nothing.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_LabelPlace (uint32)
        The position of the label (See LAYOUT_Label).

        Applicability is (OM_NEW, OM_SET, OM_UPDATE, OM_GET)

    LAYOUT_RemoveChild (Object *)
        Pointer to an object you wish to remove from the layout
        hierarchy. The object will be disposed of, so after using this
        tag, the pointer will be invalid.

        Do not use this tag to remove objects while the layout is
        in an active Window. An Intuition deadlock could result.
        Use the LM_REMOVECHILD method instead.

        Applicability is (OM_SET)

    LAYOUT_AddChild (Object *)
        Pointer to an object you wish to add to the list of gadgets for
        this layout hierarchy level.

        Do not use this tag to add gadget objects while the layout is
        in an active Window. An Intuition deadlock could result.
        Use the LM_ADDCHILD method instead.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_AddImage (Object *)
        Same as LAYOUT_AddChild, but will mark the object as an
        imageclass subclass (meaning that IM_DRAW will be used instead
        of GM_RENDER to display it, and that none of the gadgetclass
        methods apply to it).

        Do not use this tag to add image objects while the layout is
        in an active Window. An Intuition deadlock could result.
        Use the LM_ADDIMAGE method instead.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_ModifyChild (Object *)
        Inform layout gadget that the following child specific tags in
        the taglist apply to the specified object. LAYOUT_AddChild will
        do this automatically for new objects.

        Do not use this tag to modify objects while the layout is
        in an active Window. An Intuition deadlock could result.
        Use the LM_MODIFYCHILD method instead.

        Applicability is (OM_SET)

    LAYOUT_RelVerify (BOOL)
        When a gadget returns a code that normally makes Intuition send
        an IDCMP_GADGETUP message to the application, layout.gadget
        will send a notification message (OM_NOTIFY, IDCMP_IDCMPUPDATE)
        with the essential information of the gadgetup message. This is
        because in certain situations the IDCMP_GADGETUP message can
        not be sent (in particular, when tab cycling between gadgets).

        The notification will consist of GA_ID set to the ID of the
        gadget in question, this LAYOUT_RelVerify tag set to TRUE, and
        the LAYOUT_RelCode tag (below) set to the gadget's return code
        (IntuiMessage.Code field of the IDCMP_GADGETUP).

        Applicability is (OM_NOTIFY)

    LAYOUT_RelCode (uint16)
        A copy of the IntuiMessage.Code field of the IDCMP_GADGETUP in
        question, sent via OM_NOTIFY (ie. received as OM_UPDATE or
        IDCMP_IDCMPUPDATE).

        Applicability is (OM_NOTIFY)

    LAYOUT_TabVerify (BOOL)
        If the gadget release was triggered by tab cycling, this
        attribute will be TRUE in the release verify IDCMPUPDATE. This
        lets you distinguish, for example, between pressing tab and
        enter in a string gadget.

        Applicability is (OM_NOTIFY)

    LAYOUT_RelAddress (struct Gadget *)
        Address of the gadget that sent the gadgetup is provided in the
        gadgetup notification using this tag.

        Applicability is (OM_NOTIFY)

    LAYOUT_HelpHit (uint16)
        When a gadget returns a hit for helptest, the return code, along
        with GA_ID, is notified using this tag.

        Applicability is (OM_NOTIFY)

    LAYOUT_Parent (Object *)
        Set automatically by layout.gadget for all child objects, this
        attribute points to the parent layout object. If NULL, the
        layout object is the window's topmost layout.

        When an object is added to the layout hierarchy, it will
        receive this tag in OM_SET. If you so wish, you may use this to
        let the gadget talk to its parent layout group.

        Any group gadget that should work with layout.gadget must
        support this attribute.

        Applicability is (OM_SET, OM_GET)

    LAYOUT_DeferLayout (BOOL)
        By setting this tag to TRUE in your window's top or root layout
        (WINDOW_Layout) you may defer the layout and refresh process off
        of the input.device task context and onto your application's.
        This will make input.device more responsive and drop the possibly
        quite heavy process of recalculating the display to normal
        application priority instead of the priority 20 of input.device.
        Input handling will be retained in input.device context to keep
        the GUI responsive.

        If you use this tag, you must listen to LAYOUT_RequestLayout
        and LAYOUT_RequestRefresh notifications and process them in
        prompt manner or your GUI will not display properly, if at all.
        Note that if you are using window.class these tags are handled
        automatically by the WM_HANDLEINPUT method.

        Deferred layout only works for smart refresh (WA_SmartRefresh)
        windows and you should never use WA_NoCareRefresh as it will
        interfere with the refresh deferral.

        Applicability is (OM_NEW, OM_SET, OM_GET)

    LAYOUT_RequestLayout (Object *)
        If the above LAYOUT_DeferLayout tag is set to TRUE, the gadget
        will defer GM_LAYOUT methods invoked by input.device and notify
        its IC target with this tag. You should be listening to it in
        your application IDCMP handler (IDCMP_IDCMPUPDATE) and calling
        RethinkLayout with FALSE for refresh flag when receiving one.

        Note that if you are using window.class this tag is handled
        automatically by the WM_HANDLEINPUT method.

        Defaults to FALSE.

        Applicability is (OM_NOTIFY)

    LAYOUT_RequestRefresh (Object *)
        If the above LAYOUT_DeferLayout tag is set to TRUE, the gadget
        will defer GM_RENDER methods invoked by input.device and notify
        its IC target with this tag. You should be listening to it in
        your application IDCMP handler (IDCMP_IDCMPUPDATE) and calling
        RefreshGList when receiving one.

        Note that if you are using window.class this tag is handled
        automatically by the WM_HANDLEINPUT method.

        Defaults to FALSE.

        Applicability is (OM_NOTIFY)

    LAYOUT_TextPen (int16)
        The pen that will be used for group label text. See bevel.image.

        Applicability is (OM_NEW)

    LAYOUT_FillPen (int16)
        The pen that will be used for the group fill pattern. See
        bevel.image.

        Applicability is (OM_NEW)

    LAYOUT_FillPattern (uint16 *)
        The fill pattern for the group. See bevel.image.

        Defaults to none.

        Applicability is (OM_NEW)

    GA_BackFill (struct Hook *) (V44)
    LAYOUT_BackFill (struct Hook *)
        A layer backfill hook to use in the group to provide a more
        complex background pattern. This is not propagated to the
        group's children; use LAYOUT_LayoutBackFill for that.
        Pass ~0L to have the group use the window.class backfill.

        Defaults to use the window.class backfill if any exists; else
        to "clear" for the main layout, and "no backfill" for sublayouts.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_LayoutBackFill (struct Hook *) (V50)
        A layer backfill hook to use in the group to provide a more
        complex background pattern. This is always propagated to all
        group's children, provided that they are already part of the
        group when this attribute is set.

        Defaults to use the window.class backfill if any exists; else
        to "clear" for the main layout, and "no backfill" for sublayouts.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_LabelColumn (uint32)
        The side where the on which side of the gadget the label will
        be placed in the group. Valid values are PLACETEXT_LEFT and
        PLACETEXT_RIGHT. See CHILD_Label.

        Defaults to PLACETEXT_LEFT.

        Applicability is (OM_NEW, OM_SET, OM_NOTIFY)

    LAYOUT_LabelWidth (uint32)
        The width of the label column in a vertical group. This attribute
        may be used to justify several layout groups.

        Applicability is (OM_SET, OM_GET)

    LAYOUT_AlignLabels (Object *)
        A pointer to another layout instance that should have equal
        label width with this one. Set to a cycle between all the
        groups, these will automatically justify their labels with each
        other. This attribute should be set as soon as possible, ie. in
        OM_NEW or OM_SET directly afterwards, before the layout size is
        calculated.

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_Inverted (BOOL) (V42.27)
        Causes children to be added to the layout group via
        AddHead() vs AddTail().

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_WeightBar (BOOL) (V43.1)
        Place a user adjustable weighting bar here
        (ie. balance group bar).

        Applicability is (OM_NEW, OM_SET)

    LAYOUT_NoLayout (BOOL) (V45)
        Do not layout the children. All children must have valid
        coordinates. Cannot be used with weight bars.

        Defaults to FALSE.

        Applicability is (OM_NEW, OM_SET, OM_GET)

    LAYOUT_CharSet (uint32) (V51)
        The character set the layout group and all its members should
        display their text in, regardless of the particular font used.
        If zero, no character set will be explicitly enforced.

        Defaults to zero.

        Applicability is (OM_NEW, OM_SET, OM_GET)


    Attributes referring to the "current" child object:

    CHILD_MinWidth, CHILD_MinHeight (uint32)
        The minimum width and height of the object in pixels. Setting
        this attribute means that GM_DOMAIN is not respected in that
        direction.

        Defaults to ~0, which means that the layout gadget will ask the
        object, using GM_DOMAIN.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    CHILD_MaxWidth, CHILD_MaxHeight (uint32)
        As above, for the maximum size.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    CHILD_NominalSize (BOOL)
        If this attribute is TRUE, layout will use GDOMAIN_NOMINAL
        instead of GDOMAIN_MINIMUM when requesting the minimum size of
        the gadget. This is useful when the minimum size of a gadget
        looks unattractive, but the gadget will return a more attractive
        size with GDOMAIN_NOMINAL.

        Defaults to FALSE.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    CHILD_WeightedWidth (uint32)
        The relative width of the child object. See the DESCRIPTION
        above for the layout method. If set to 0, the child will always
        be rendered in the minimum size (specified by either GM_DOMAIN
        or CHILD_MinWidth). Use CHILD_MinWidth and a weighted with of 0
        instead of CHILD_MinWidth and CHILD_MaxWidth. The latter method
        will also work, but will slow down the layout. As a special
        rule, many BOOPSI images using bitmap data can not be resized
        from the initial size. Fix their size by setting MinWidth and
        MinHeight, and the weight to 0.

        Defaults to 100.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    CHILD_WeightedHeight (uint32)
        The relative height of the child object. See CHILD_WeightedWidth.

        Applicability is (OM_NEW, OM_SET, OM_UPDATE)

    CHILD_WeightMinimum (BOOL)
        Setting this tag to TRUE will make the layout group set the
        weighted width and height to the minimum values set with
        CHILD_MinWidth and CHILD_MinHeight or returned by GM_DOMAIN. This
        allows creating layout groups where the relative size of the
        objects always remains the same. Be warned that if the object
        does not support GM_DOMAIN and minimum size is not set manually,
        the weight will be set to 2 (the default minimum size of an
        object). Normally you would want to set this tag for every
        resizable object in a layout group.

        Defaults to FALSE.

        Applicability is (OM_NEW)

    CHILD_ReplaceObject (Object *)
    CHILD_ReplaceImage (Object *)
        Replace the current child object with the one specified. The
        current object will be disposed of. See LAYOUT_ModifyChild.

        Applicability is (OM_SET)

    CHILD_CacheDomain (BOOL)
        To speed up resizing, layout gadget will normally cache the
        first values returned by GM_DOMAIN and use that cache for
        subsequent relayouts instead of calling GM_DOMAIN again.
        Normally this will have the same results all the time. If you
        have a custom gadget that might return varying values between
        calls to GM_DOMAIN (ie. the minimum or maximum size of it could
        vary during runtime), set this tag to FALSE for that object and
        all its parent groups. Note that since layout groups are aware
        of their parent layouts, they can disable caching in the
        hierarchy above them automatically if you SetAttr() this
        attribute *after* creating the whole layout hierarchy.

        Defaults to TRUE.

        Applicability is (OM_NEW, OM_SET) (OM_SET preferred)

    CHILD_Label (Object *)
        The imageclass object to use as the object's label. These
        labels are supported only left or right aligned groups and
        will be placed in the left or right of the gadget even in
        horizontal groups. All the labels will take the space of the
        widest label. Label-less objects will be laid out in full
        width; if you want to leave the label column empty, use
        the special value LCLABEL_NOLABEL. Every object in a group gets
        the same amount of space reserved for a label, whether they have
        a label or not. This also (or in particular) applies to
        horizontal groups; usually the correct effect is reached by
        putting the label on the group itself instead of one of the
        objects in it. See LAYOUT_LabelColumn.

        Defaults to NULL.

        Applicability is (OM_NEW, OM_SET)

    CHILD_NoDispose (BOOL)
        By setting this attribute, you inform the layout object that
        this child object should not be automatically disposed when
        the layout object itself is disposed. This attribute allows
        sharing objects between layouts.

        Default is FALSE.

        Applicability is (OM_NEW, OM_SET)

    CHILD_ScaleWidth (uint16) (V42.27)
        Scales the child minimum domain size to a larger value;

        minwidth = minwidth + ((minsize * scalewidth)/100)

        Default is 0.

        Applicability is (OM_NEW, OM_SET)

    CHILD_ScaleHeight (uint16) (V42.27)
        Scales the child minimum domain size to a larger value;

        minheight = minheight + ((minsize * scaleheight)/100)

        Default is 0.

        Applicability is (OM_NEW, OM_SET)

    CHILD_DataType (BOOL) (V43 BETA)
        This is a datatype and layout will use DTM_PROCLAYOUT,
        SetDTAttrs and RefreshDTObject so waiting for DTA_Sync
        is not required.

        Applicability is (OM_NEW, OM_SET)

    NOTES
    Setting the attributes via SetGadgetAttrs() or RefreshGadgetAttrs()
    will not automatically rerender the display. Call RethinkLayout()
    to relayout and refresh display after setting attributes. If you
    are using window.class then you may need to invoke the WM_RETHINK
    method instead of calling RethinkLayout() because the size of the
    layout may change especially when adding or removing gadgets
    dynamically.

    In this document, the terms layout, group, and object are used
    intermixed. Most of the time, layout and group are used as
    synonyms. Virtually any object referred to could also be a
    layout group.

    Due to current Intuition limitations, IDCMP_GADGETUP messages are
    not fully supported. The IAddress will always point to the root
    layout object of the window, not the actual gadget the message
    originates from. Use GadgetID to distinguish between gadgets.
    When using tab cycle, GADGETUP messages will be lost
    altogether. However, layout.gadget sends a notification for all
    gadgetups, containing the tags GA_ID, LAYOUT_RelVerify and
    LAYOUT_RelCode, containing, respectively, the ID, TRUE, and the
    IntuiMessage.Code value it returned. Additionally a
    LAYOUT_TabVerify tag will be TRUE or FALSE depending on whether
    the gadget release was triggered by tab cycle.
    Use of models and/or IDCMP_IDCMPUPDATE is encouraged.

    The layout.gadget will always use IM_DOMAINFRAME when querying
    image object domains. The old ClassAct IM_DOMAIN method is
    supported as a fallback if the IM_DOMAINFRAME method returns a
    zero value just in case some old ClassAct image class is in use.

    BUGS
    Before 45.9 LAYOUT_WeightBar didn't work correctly when used
    in the root layoutgroup because the render request on SELECTUP was
    rejected by window.class. Possible workarounds for this bug are:
      a) Don't use LAYOUT_DeferLayout
      b) set WFLG_NOCAREREFRESH
      c) don't add the weightbar to the rootlayout, instead add
         a "dummy" group to the rootlayout that contains all the
         children and the weightbar.

    SEE ALSO
    window.class

layout.gadget/ActivateLayoutGadget         layout.gadget/ActivateLayoutGadget

    NAME
    ActivateLayoutGadget -- Activate a gadget within a layout window.

    SYNOPSIS
    BOOL ActivateLayoutGadget(struct Gadget *gad, struct Window *win,
                              struct Requester *req, uint32 obj);

    FUNCTION
    The equivalent of intuition.library's ActivateGadget() for a
    window controlled by layout.gadget. If successful, this means
    that the user does not need to click in the gadget before
    typing.

    The gad parameter must point to the root layout gadget in
    the window and the obj parameter to the gagdet you wish to
    activate.

    This works by calling the private LAYOUT_ACTIVATEOBJECT method
    to search the layout hierarchy for the specified gadget and
    set the handleinput path to that gadget and finally calling
    ActivateGadget() for the root object.

    The rules of calling ActivateGadget() apply to
    ActivateLayoutGadget() as well.

    INPUTS
    gad - pointer to the root layout object for the window.
    win - pointer to the window the gadget is in.
    req - pointer to a requester (may be NULL).
    obj - pointer to the BOOPSI object you wish to activate.

    RESULT
    If the conditions above (and those of ActivateGadget()) are
    met, the function will return TRUE, else FALSE.

    NOTES
    Not only string gadgets can be activated this way. Many
    BOOPSI gadget classes, such as the button.gadget, also
    support keyboard control and thus may be activated this way.

    An attempt to activate a gadget that is not currently visible
    (as on a hidden page) will fail.

    SEE ALSO
    intuition.library/ActivateGadget()

layout.gadget/FlushLayoutDomainCache     layout.gadget/FlushLayoutDomainCache

    NAME
    FlushLayoutDomainCache -- Flush layout domain cache below a level.

    SYNOPSIS
    void FlushLayoutDomainCache(struct Gadget *layout);

    FUNCTION
    Layout gadget normally caches GM_DOMAIN results from the child
    objects to speed up window relayouts. However, on some rare
    occasions a gadget's minimum or maximum domain might change
    after creation. For these instances layout gadget provides two
    methods controlling the domain cache. You can set a caching on a
    child-by-child basis, using the CHILD_CacheDomain attribute, so
    that on each relayout the domain is calculated again. This
    method might have an extra performance hit, if the domain
    changes infrequently. It also has to be set for each parent
    layout level, which makes the amount of extra calculations grow
    quickly. The other method, for the cases where the application
    will know when a gadget's domain changes, is to call
    FlushLayoutDomainCache() with a pointer to the window's topmost
    layout object. This call will flush the whole hierarchy, so
    that the next window relayout will calculate all domains again.

    INPUTS
    layout - the layout object to flush. This should be the topmost
             layout object for the window.

    SEE ALSO
    layout.gadget/CHILD_CacheDomain

layout.gadget/LAYOUT_GetClass                   layout.gadget/LAYOUT_GetClass

    NAME
    LAYOUT_GetClass -- Gets pointer to the layout class.

    SYNOPSIS
    Class * class = LAYOUT_GetClass();

    FUNCTION
    This function is deprecated as of V52.
    Use the "layout.gadget" public class ID instead.

    RESULT
    class - Pointer to the layout class.

layout.gadget/LayoutLimits                         layout.gadget/LayoutLimits

    NAME
    LayoutLimits -- Easy way to find max and min size of layout.

    SYNOPSIS
    LayoutLimits( layout, limits, font, screen )

    void LayoutLimits(struct Gadget *layout,
                      struct LayoutLimits *limits,
                      struct TextFont *font, struct Screen *screen);

    FUNCTION
    This function is an easy way of getting the minimum and maximum
    limit of the layout group. Effectively it creates a RastPort and
    executes the GM_DOMAIN method for both minimum and maximum size
    of the object filling in the LayoutLimits structure with the size
    values. The font passed to this call will most likely affect the
    results (unless the layout passed as an argument already has an
    own font), so use the font you will use with the window. If you
    pass a NULL for the font, the system default font (monospaced)
    will be used, unless you pass the optional screen pointer; in that
    case, the screen font will be used. If you supply a screen pointer,
    the gadget will also be provided a DrawInfo. This will let the
    gadget adjust to the aspect ratio of the screen.

    If you use the resulting size for OpenWindow() or WindowLimits(),
    remember that the results do not include window borders.

    INPUTS
    layout - the layout object to get the size on.
    limits - a pointer to the struct LayoutLimits to fill.
    font - the TextFont to use on the domain requests. May be NULL
           for system default font.
    screen - optional pointer to the screen on which the layout
             will be used on, or NULL.

    NOTES
    This function will invoke the object's GM_DOMAIN method twice,
    with a NULL GadgetInfo. If you call it providing a screen
    pointer, the taglist of the message will contain that screen's
    DrawInfo (GA_DrawInfo) for aspect information.

    SEE ALSO
    gadgetclass/GM_DOMAIN

layout.gadget/LM_ADDCHILD                           layout.gadget/LM_ADDCHILD

    NAME
    LM_ADDCHILD -- Add gadget to active layout. (V53)

    SYNOPSIS
    uint32 result = IDoMethodA(APTR obj, struct lmAddChild * msg);

    FUNCTION
    This method is used to safely add a child object (i.e. Gadget)
    to a layout.gadget which is already attached to a window.

    This method takes the following message structure:

    struct lmAddChild
    {
        uint32           MethodID;  // LM_ADDCHILD
        struct Window *  lm_Window;
        Object *         lm_Object;
        struct TagItem * lm_ObjectAttrs;
    };

    The lm_Window field is a pointer to the window containing the
    layout.gadget. This field may be NULL which means this method
    is equivalent to using the LAYOUT_AddChild tag.

    The lm_Object field provides a pointer to the BOOPSI Gadget object.
    To add a BOOPSI Image object see LM_ADDIMAGE.

    The lm_ObjectAttrs field contains any extra attributes to apply
    to the lm_Object. This field may be NULL to provide no attributes.

    NOTE
    Older code which does not use this method runs the risk of a
    deadlock with Intuition and the user will experience a frozen GUI.

    INPUTS
    obj - layout object pointer
    msg - pointer to fully initialized struct lmAddChild
          (see <gadgets/layout.h>)

    RESULT
    Returns TRUE if successful or FALSE on error.

    The method will not automatically rerender the display.
    Usually a WM_RETHINK method will be required.

    BUGS
    This method always returned FALSE whether it succeeded or not.
    Fixed since 53.7.

    SEE ALSO
    LM_ADDIMAGE, LM_REMOVECHILD, LM_MODIFYCHILD,
    window.class/WM_RETHINK, intuition.library/IDoMethodA()

layout.gadget/LM_ADDIMAGE                           layout.gadget/LM_ADDIMAGE

    NAME
    LM_ADDIMAGE -- Add image to active layout. (V53)

    SYNOPSIS
    uint32 result = IDoMethodA(APTR obj, struct lmAddChild * msg);

    FUNCTION
    This method is used to safely add a child object (i.e. Image)
    to a layout.gadget which is already attached to a window.

    This method takes the following message structure:

    struct lmAddImage
    {
        uint32           MethodID;  // LM_ADDIMAGE
        struct Window *  lm_Window;
        Object *         lm_Object;
        struct TagItem * lm_ObjectAttrs;
    };

    The lm_Window field is a pointer to the window containing the
    layout.gadget. This field may be NULL which means this method
    is equivalent to using the LAYOUT_AddImage tag.

    The lm_Object field provides a pointer to the BOOPSI Image object.
    To add a BOOPSI Gadget object see LM_ADDCHILD.

    The lm_ObjectAttrs field contains any extra attributes to apply
    to the lm_Object. This field may be NULL to provide no attributes.

    NOTE
    Older code which does not use this method runs the risk of a
    deadlock with Intuition and the user will experience a frozen GUI.

    INPUTS
    obj - layout object pointer
    msg - pointer to fully initialized struct lmAddImage
          (see <gadgets/layout.h>)

    RESULT
    Returns TRUE if successful or FALSE on error.

    The method will not automatically rerender the display.
    Usually a WM_RETHINK method will be required.

    BUGS
    This method always returned FALSE whether it succeeded or not.
    Fixed since 53.7.

    SEE ALSO
    LM_ADDCHILD, LM_REMOVECHILD, LM_MODIFYCHILD,
    window.class/WM_RETHINK, intuition.library/IDoMethodA()

layout.gadget/LM_MODIFYCHILD                     layout.gadget/LM_MODIFYCHILD

    NAME
    LM_MODIFYCHILD -- Modify object in active layout. (V53)

    SYNOPSIS
    uint32 result = IDoMethodA(APTR obj, struct lmModifyChild * msg);

    FUNCTION
    This method is used to safely modify a child object in a
    layout.gadget which is already attached to a window.

    This method takes the following message structure:

    struct lmModifyChild
    {
        uint32           MethodID;  // LM_MODIFYCHILD
        struct Window *  lm_Window;
        Object *         lm_Object;
        struct TagItem * lm_ObjectAttrs;
    };

    The lm_Window field is a pointer to the window containing the
    layout.gadget. This field may be NULL which means this method
    is equivalent to using the LAYOUT_ModifyChild tag.

    The lm_Object field provides a pointer to the BOOPSI object.

    The lm_ObjectAttrs field contains the attributes to apply to
    the modified lm_Object. This field may be NULL to provide no
    attributes.

    NOTE
    Older code which does not use this method runs the risk of a
    deadlock with Intuition and the user will experience a frozen GUI.

    INPUTS
    obj - layout object pointer
    msg - pointer to fully initialized struct lmModifyChild
          (see <gadgets/layout.h>)

    RESULT
    No return value is defined for this method.

    The method will not automatically rerender the display.
    Depending on the extent of the modification you may need to call
    RethinkLayout() or WM_RETHINK.

    SEE ALSO
    LM_ADDCHILD, LM_ADDIMAGE, LM_REMOVECHILD, RethinkLayout(),
    window.class/WM_RETHINK, intuition.library/IDoMethodA()

layout.gadget/LM_REMOVECHILD                     layout.gadget/LM_REMOVECHILD

    NAME
    LM_REMOVECHILD -- Remove object from active layout. (V53)

    SYNOPSIS
    uint32 result = IDoMethodA(APTR obj, struct lmRemoveChild * msg);

    FUNCTION
    This method is used to safely remove and dispose a child object
    from a layout.gadget which is already attached to a window.

    After successfully removing the object, this method will dispose
    of the object via the DisposeObject() function.

    This method takes the following message structure:

    struct lmRemoveChild
    {
        uint32          MethodID;  // LM_REMOVECHILD
        struct Window * lm_Window;
        Object *        lm_Object;
    };

    The lm_Window field is a pointer to the window containing the
    layout.gadget. This field may be NULL which means this method
    is equivalent to using the LAYOUT_RemoveChild tag.

    The lm_Object field provides a pointer to the BOOPSI object.
    Once the object is removed from the layout it is disposed
    of via the DisposeObject() function.

    NOTE
    Older code which does not use this method runs the risk of a
    deadlock with Intuition and the user will experience a frozen GUI.

    INPUTS
    obj - layout object pointer
    msg - pointer to fully initialized struct lmRemoveChild
          (see <gadgets/layout.h>)

    RESULT
    No return value is defined for this method.

    The method will not automatically rerender the display.
    Usually a WM_RETHINK method will be required.

    SEE ALSO
    LM_ADDCHILD, LM_ADDIMAGE, LM_MODIFYCHILD,
    window.class/WM_RETHINK, intuition.library/IDoMethodA()

layout.gadget/RethinkLayout                       layout.gadget/RethinkLayout

    NAME
    RethinkLayout -- Relayout and render the layout. (V39)

    SYNOPSIS
    void RethinkLayout(struct Gadget *layout, struct Window *win,
                       struct Requester *req, BOOL refresh);

    FUNCTION
    Relayout and refresh the layout page. Call this function after
    a call to SetGadgetAttrs() returns 1 to display the changes in the
    layout. According to BOOPSI rules, a gadget will return a value
    equal or greater than 1 from OM_SET to tell the application to refresh.
    This is what this function is for. Basically, it will call the
    GM_LAYOUT and GM_RENDER methods of the layout.

    INPUTS
    layout - the layout to refresh. Doesn't have to be the topmost
             object in the hierarchy, if the changes do not affect it.
    win - the window to which the layout (or its parent) is
          attached to.
    req - the window's requester (may be NULL).
    refresh - whether layout.gadget should also refresh the display.

    NOTES
    This function emulates a DoGadgetMethod() on V37 and V38 systems.

    The refresh flag is provided for several reasons. First, when using
    LAYOUT_DeferLayout, you should not refresh upon receiving a
    LAYOUT_RequestLayout notification. Second, datatypes have an
    asynchronous layout, and should not be attempted to refresh before
    that is finished. Wait for DTA_Sync, and then
    RefreshGList( layout, window, requester, 1 ).

    SEE ALSO
    intuition.library/RefreshGList(),
    intuition.library/SetGadgetAttrsA(),
    intuition.library/RefreshSetGadgetAttrsA(),
    intuition.library/DoGadgetMethodA()

