TABLE OF CONTENTS

z.library/Adler32
z.library/Adler32Combine
z.library/Compress
z.library/Compress2
z.library/CompressBound
z.library/CRC32
z.library/CRC32Combine
z.library/Deflate
z.library/DeflateBound
z.library/DeflateCopy
z.library/DeflateEnd
z.library/DeflateInit
z.library/DeflateInit2
z.library/DeflateParams
z.library/DeflatePrime
z.library/DeflateReset
z.library/DeflateSetDictionary
z.library/DeflateSetHeader
z.library/DeflateTune
z.library/Inflate
z.library/InflateBack
z.library/InflateBackEnd
z.library/InflateBackInit
z.library/InflateCopy
z.library/InflateEnd
z.library/InflateGetDictionary
z.library/InflateGetHeader
z.library/InflateInit
z.library/InflateInit2
z.library/InflatePrime
z.library/InflateReset
z.library/InflateReset2
z.library/InflateSetDictionary
z.library/InflateSync
z.library/Uncompress
z.library/Uncompress2
z.library/ZlibVersion
z.library/Adler32                                                                 z.library/Adler32

   NAME
      Adler32 -- Update a running Adler-32 checksum

   SYNOPSIS
      uint32 Adler32(uint32 adler, const uint8 * buf, uint32 len);

   FUNCTION
       Update a running Adler-32 checksum with the bytes buf[0..len-1]
       and return the updated checksum. If buf is NULL, this function
       returns the required initial value for the checksum.

       An Adler-32 checksum is almost as reliable as a CRC-32 but can be
       computed much faster.

   INPUTS
       adler - Initial or current Adler-32 checksum
       buf - Pointer to data or Z_NULL to get the initial checksum value.
       len - Length of data.

   RESULT
       Updated Adler-32 checksum.

   EXAMPLE
       uLong adler = adler32(0L, Z_NULL, 0);

       while (read_buffer(buffer, length) != EOF) {
         adler = adler32(adler, buffer, length);
       }
       if (adler != original_adler) error();

   NOTES

   BUGS

   SEE ALSO
       Adler32Combine(), CRC32(), CRC32Combine()

z.library/Adler32Combine                                                   z.library/Adler32Combine

   NAME
      Adler32Combine -- Combine two Adler-32 checksums into one

   SYNOPSIS
      uint32 Adler32Combine(uint32 adler1, uint32 adler2, int32 len2);

   FUNCTION
       Combine two Adler-32 checksums into one. For two sequences of
       bytes, seq1 and seq2 with lengths len1 and len2, Adler-32
       checksums were calculated for each, adler1 and adler2.
       adler32_combine() returns the Adler-32 checksum of seq1 and seq2
       concatenated, requiring only adler1, adler2, and len2. If len2 is
       negative, the result has no meaning or utility.

   INPUTS
       adler1 - First Adler-32 checksum.
       adler2 - Second Adler-32 checksum.
       len2 - Length of data for second Adler-32 checksum.

   RESULT
       Combined Adler-32 checksum.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       Adler32(), CRC32Combine(), CRC32()

z.library/Compress                                                               z.library/Compress

   NAME
      Compress -- Compress from source to destination buffer.

   SYNOPSIS
      int32 Compress(APTR dest, uint32 * destLen, CONST_APTR source, 
          uint32 sourceLen);

   FUNCTION
       Compresses the source buffer into the destination buffer.
       sourceLen is the byte length of the source buffer. Upon entry,
       destLen is the total size of the destination buffer, which must be
       at least the value returned by compressBound(sourceLen). Upon
       exit, destLen is the actual size of the compressed buffer.

       compress returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_BUF_ERROR if there was not enough room in the
       output buffer.

   INPUTS
       dest - Destination buffer.
       destLen - Length of destination buffer.
       source - Source buffer.
       sourceLen - Length of source buffer.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       CompressBound(), Compress2()

z.library/Compress2                                                             z.library/Compress2

   NAME
      Compress2 -- Compress from source to destination buffer. (V53.2)

   SYNOPSIS
      int32 Compress2(APTR dest, uint32 * destLen, CONST_APTR source, 
          uint32 sourceLen, int32 level);

   FUNCTION
       Compresses the source buffer into the destination buffer. The
       level parameter has the same meaning as in deflateInit. sourceLen
       is the byte length of the source buffer. Upon entry, destLen is
       the total size of the destination buffer, which must be at least
       the value returned by compressBound(sourceLen). Upon exit, destLen
       is the actual size of the compressed buffer.

       compress2 returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_BUF_ERROR if there was not enough room in the
       output buffer, Z_STREAM_ERROR if the level parameter is invalid.

   INPUTS
       dest - Destination buffer.
       destLen - Length of destination buffer.
       source - Source buffer.
       sourceLen - Length of source buffer.
       level - Compression level.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       CompressBound(), Compress()

z.library/CompressBound                                                     z.library/CompressBound

   NAME
      CompressBound -- Calculate the worst case length for compression
                       (V53.4)

   SYNOPSIS
      uint32 CompressBound(uint32 sourceLen);

   FUNCTION
       compressBound() returns an upper bound on the compressed size
       after compress() or compress2() on sourceLen bytes. It would be
       used before a compress() or compress2() call to allocate the
       destination buffer.

   INPUTS
       sourceLen - Length of data to compress.

   RESULT
       The calculated worst case compressed size for the specified length
       of input data.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       Compress(), Compress2()

z.library/CRC32                                                                     z.library/CRC32

   NAME
      CRC32 -- Update a running CRC-32 checksum

   SYNOPSIS
      uint32 CRC32(uint32 crc, const uint8 * buf, uint32 len);

   FUNCTION
       Update a running CRC-32 with the bytes buf[0..len-1] and return
       the updated CRC-32. If buf is Z_NULL, this function returns the
       required initial value for the crc. Pre- and post-conditioning
       (one's complement) is performed within this function so it
       shouldn't be done by the application.

   INPUTS
       crc - Initial or current CRC-32 checksum.
       buf - Pointer to data or Z_NULL to get the initial checksum value.
       len - Length of data.

   RESULT
       Updated CRC-32 checksum.

   EXAMPLE
       uLong crc = crc32(0L, Z_NULL, 0);

       while (read_buffer(buffer, length) != EOF) {
         crc = crc32(crc, buffer, length);
       }
       if (crc != original_crc) error();

   NOTES

   BUGS

   SEE ALSO
       CRC32Combine(), Adler32(), Adler32Combine()

z.library/CRC32Combine                                                       z.library/CRC32Combine

   NAME
      CRC32Combine -- Combine two CRC-32 check values into one

   SYNOPSIS
      uint32 CRC32Combine(uint32 crc1, uint32 crc2, int32 len2);

   FUNCTION
       Combine two CRC-32 check values into one. For two sequences of
       bytes, seq1 and seq2 with lengths len1 and len2, CRC-32 check
       values were calculated for each, crc1 and crc2. crc32_combine()
       returns the CRC-32 check value of seq1 and seq2 concatenated,
       requiring only crc1, crc2, and len2.

   INPUTS
       crc1 - First CRC-32 checksum.
       crc2 - Second CRC-32 checksum.
       len2 - Length of data for second CRC-32 checksum.

   RESULT
       Combined CRC-32 checksum.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       CRC32(), Adler32Combine(), Adler32()

z.library/Deflate                                                                 z.library/Deflate

   NAME
      Deflate -- Perform compression

   SYNOPSIS
      int32 Deflate(z_stream * strm, int32 flush);

   FUNCTION
       deflate compresses as much data as possible, and stops when the
       input buffer becomes empty or the output buffer becomes full. It
       may introduce some output latency (reading input without producing
       any output) except when forced to flush.

       The detailed semantics are as follows. deflate performs one or
       both of the following actions:

           Compress more input starting at next_in and update next_in and
           avail_in accordingly. If not all input can be processed
           (because there is not enough room in the output buffer),
           next_in and avail_in are updated and processing will resume at
           this point for the next call of deflate().

           Provide more output starting at next_out and update next_out
           and avail_out accordingly. This action is forced if the
           parameter flush is non zero. Forcing flush frequently degrades
           the compression ratio, so this parameter should be set only
           when necessary (in interactive applications). Some output may
           be provided even if flush is not set.

       Before the call of deflate(), the application should ensure that
       at least one of the actions is possible, by providing more input
       and/or consuming more output, and updating avail_in or avail_out
       accordingly; avail_out should never be zero before the call. The
       application can consume the compressed output when it wants, for
       example when the output buffer is full (avail_out == 0), or after
       each call of deflate(). If deflate returns Z_OK and with zero
       avail_out, it must be called again after making room in the output
       buffer because there might be more output pending.

       Normally the parameter flush is set to Z_NO_FLUSH, which allows
       deflate to decide how much data to accumulate before producing
       output, in order to maximize compression.

       If the parameter flush is set to Z_SYNC_FLUSH, all pending output
       is flushed to the output buffer and the output is aligned on a
       byte boundary, so that the decompressor can get all input data
       available so far. (In particular avail_in is zero after the call
       if enough output space has been provided before the call.)
       Flushing may degrade compression for some compression algorithms
       and so it should be used only when necessary. This completes the
       current deflate block and follows it with an empty stored block
       that is three bits plus filler bits to the next byte, followed by
       four bytes (00 00 ff ff).

       If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed
       to the output buffer, but the output is not aligned to a byte
       boundary. All of the input data so far will be available to the
       decompressor, as for Z_SYNC_FLUSH. This completes the current
       deflate block and follows it with an empty fixed codes block that
       is 10 bits long. This assures that enough bytes are output in
       order for the decompressor to finish the block before the empty
       fixed code block.

       If flush is set to Z_BLOCK, a deflate block is completed and
       emitted, as for Z_SYNC_FLUSH, but the output is not aligned on a
       byte boundary, and up to seven bits of the current block are held
       to be written as the next byte after the next deflate block is
       completed. In this case, the decompressor may not be provided
       enough bits at this point in order to complete decompression of
       the data provided so far to the compressor. It may need to wait
       for the next block to be emitted. This is for advanced
       applications that need to control the emission of deflate blocks.

       If flush is set to Z_FULL_FLUSH, all output is flushed as with
       Z_SYNC_FLUSH, and the compression state is reset so that
       decompression can restart from this point if previous compressed
       data has been damaged or if random access is desired. Using
       Z_FULL_FLUSH too often can seriously degrade compression.

       If deflate returns with avail_out == 0, this function must be
       called again with the same value of the flush parameter and more
       output space (updated avail_out), until the flush is complete
       (deflate returns with non-zero avail_out). In the case of a
       Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that avail_out is greater
       than six to avoid repeated flush markers due to avail_out == 0 on
       return.

       If the parameter flush is set to Z_FINISH, pending input is
       processed, pending output is flushed and deflate returns with
       Z_STREAM_END if there was enough output space; if deflate returns
       with Z_OK, this function must be called again with Z_FINISH and
       more output space (updated avail_out) but no more input data,
       until it returns with Z_STREAM_END or an error. After deflate has
       returned Z_STREAM_END, the only possible operations on the stream
       are deflateReset or deflateEnd.

       Z_FINISH can be used immediately after deflateInit if all the
       compression is to be done in a single step. In this case,
       avail_out must be at least value returned by deflateBound (see
       below). Then deflate is guaranteed to return Z_STREAM_END. If not
       enough output space is provided, deflate will not return
       Z_STREAM_END, and it must be called again as described above.

       deflate() sets strm->adler to the adler32 checksum of all input
       read so far (that is, total_in bytes).

       deflate() may update strm->data_type if it can make a good guess
       about the input data type (Z_BINARY or Z_TEXT). In doubt, the data
       is considered binary. This field is only for information purposes
       and does not affect the compression algorithm in any manner.

       deflate() returns Z_OK if some progress has been made (more input
       processed or more output produced), Z_STREAM_END if all input has
       been consumed and all output has been produced (only when flush is
       set to Z_FINISH), Z_STREAM_ERROR if the stream state was
       inconsistent (for example if next_in or next_out was NULL),
       Z_BUF_ERROR if no progress is possible (for example avail_in or
       avail_out was zero). Note that Z_BUF_ERROR is not fatal, and
       deflate() can be called again with more input and more output
       space to continue compressing.

   INPUTS
       strm - Pointer to an initialized z_stream.
       flush - Wanted flushing behavior. Usually Z_NO_FLUSH is used.

   RESULT
       Z_OK or Z_STREAM_END for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), DeflateEnd()

z.library/DeflateBound                                                       z.library/DeflateBound

   NAME
      DeflateBound -- Calculate the worst case length for compression

   SYNOPSIS
      uint32 DeflateBound(z_stream * strm, uint32 sourceLen);

   FUNCTION
       deflateBound() returns an upper bound on the compressed size after
       deflation of sourceLen bytes. It must be called after deflate-
       Init() or deflateInit2(). This would be used to allocate an output
       buffer for deflation in a single pass, and so would be called
       before deflate(). If that first deflate() call is provided the
       sourceLen input bytes, an output buffer allocated to the size
       returned by deflateBound(), and the flush value Z_FINISH, then
       deflate() is guaranteed to return Z_STREAM_END. Note that it is
       possible for the compressed size to be larger than the value
       returned by deflateBound() if flush options other than Z_FINISH or
       Z_NO_FLUSH are used.

   INPUTS
       strm - Pointer to an initialized z_stream.
       sourceLen - Length of data to compress.

   RESULT
       The calculated worst case compressed size for the specified length
       of input data.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflateCopy                                                         z.library/DeflateCopy

   NAME
      DeflateCopy -- Duplicate a compression stream

   SYNOPSIS
      int32 DeflateCopy(z_stream * dest, z_stream * source);

   FUNCTION
       Sets the destination stream as a complete copy of the source
       stream.

       This function can be useful when several compression strategies
       will be tried, for example when there are several ways of pre-
       processing the input data with a filter. The streams that will be
       discarded should then be freed by calling deflateEnd. Note that
       deflateCopy duplicates the internal compression state which can be
       quite large, so this strategy is slow and can consume lots of
       memory.

       deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_STREAM_ERROR if the source stream state was
       inconsistent (such as zalloc being NULL). msg is left unchanged in
       both source and destination.

   INPUTS
       dest - Pointer to z_stream to store copy in.
       source - Pointer to z_stream to copy.

   RESULT
       Z_OK for success or error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflateEnd                                                           z.library/DeflateEnd

   NAME
      DeflateEnd -- Perform cleanup after compression

   SYNOPSIS
      int32 DeflateEnd(z_stream * strm);

   FUNCTION
       All dynamically allocated data structures for this stream are
       freed. This function discards any unprocessed input and does not
       flush any pending output.

       deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream
       state was inconsistent, Z_DATA_ERROR if the stream was freed
       prematurely (some input or output was discarded). In the error
       case, msg may be set but then points to a static string (which
       must not be deallocated).

   INPUTS
       strm - Pointer to a z_stream to clean up after.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate()

z.library/DeflateInit                                                         z.library/DeflateInit

   NAME
      DeflateInit -- Initialize a z_stream for compression

   SYNOPSIS
      int32 DeflateInit(z_stream * strm, int32 level);

   FUNCTION
       Initializes the internal stream state for compression. The fields
       zalloc, zfree and opaque must be initialized before by the caller.
       If zalloc and zfree are set to Z_NULL, deflateInit updates them to
       use default allocation functions.

       The compression level must be Z_DEFAULT_COMPRESSION, or between 0
       and 9: 1 gives best speed, 9 gives best compression, 0 gives no
       compression at all (the input data is simply copied a block at a
       time). Z_DEFAULT_COMPRESSION requests a default compromise between
       speed and compression (currently equivalent to level 6).

       deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_STREAM_ERROR if level is not a valid compression
       level, Z_VERSION_ERROR if the zlib library version (zlib_version)
       is incompatible with the version assumed by the caller
       (ZLIB_VERSION). msg is set to null if there is no error message.
       deflateInit does not perform any compression: this will be done by
       deflate().

   INPUTS
       strm - Pointer to a z_stream to initialize.
       level - Compression level.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflateInit2                                                       z.library/DeflateInit2

   NAME
      DeflateInit2 -- Initialize a z_stream for compression

   SYNOPSIS
      int32 DeflateInit2(z_stream * strm, int32 level, int32 method, 
          int32 windowBits, int32 memLevel, int32 strategy);

   FUNCTION
       This is another version of deflateInit with more compression
       options. The fields next_in, zalloc, zfree and opaque must be
       initialized before by the caller.

       The method parameter is the compression method. It must be
       Z_DEFLATED in this version of the library.

       The windowBits parameter is the base two logarithm of the window
       size (the size of the history buffer). It should be in the range
       8..15 for this version of the library. Larger values of this
       parameter result in better compression at the expense of memory
       usage. The default value is 15 if deflateInit is used instead.

       windowBits can also be –8..–15 for raw deflate. In this case,
       -windowBits determines the window size. deflate() will then
       generate raw deflate data with no zlib header or trailer, and will
       not compute an adler32 check value.

       windowBits can also be greater than 15 for optional gzip encoding.
       Add 16 to windowBits to write a simple gzip header and trailer
       around the compressed data instead of a zlib wrapper. The gzip
       header will have no file name, no extra data, no comment, no
       modification time (set to zero), no header crc, and the operating
       system will be set to 255 (unknown). If a gzip stream is being
       written, strm->adler is a crc32 instead of an adler32.

       The memLevel parameter specifies how much memory should be
       allocated for the internal compression state. memLevel=1 uses
       minimum memory but is slow and reduces compression ratio;
       memLevel=9 uses maximum memory for optimal speed. The default
       value is 8. See zconf.h for total memory usage as a function of
       windowBits and memLevel.

       The strategy parameter is used to tune the compression algorithm.
       Use the value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for
       data produced by a filter (or predictor), Z_HUFFMAN_ONLY to force
       Huffman encoding only (no string match), or Z_RLE to limit match
       distances to one (run-length encoding). Filtered data consists
       mostly of small values with a somewhat random distribution. In
       this case, the compression algorithm is tuned to compress them
       better. The effect of Z_FILTERED is to force more Huffman coding
       and less string matching; it is somewhat intermediate between
       Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be
       almost as fast as Z_HUFFMAN_ONLY, but give better compression for
       PNG image data. The strategy parameter only affects the
       compression ratio but not the correctness of the compressed output
       even if it is not set appropriately. Z_FIXED prevents the use of
       dynamic Huffman codes, allowing for a simpler decoder for special
       applications.

       deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
       an invalid method), or Z_VERSION_ERROR if the zlib library version
       (zlib_version) is incompatible with the version assumed by the
       caller (ZLIB_VERSION). msg is set to null if there is no error
       message. deflateInit2 does not perform any compression: this will
       be done by deflate().

   INPUTS
       strm - Pointer to a z_stream to initialize.
       level - Compression level.
       method - Should only be set to Z_DEFLATED for now.
       windowBits - Window size.
       memLevel - Determines how much memory is allocated for storing
           internal compression state data.
       strategy - Used to tune the compression algorithm.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), Deflate(), DeflateEnd()

z.library/DeflateParams                                                     z.library/DeflateParams

   NAME
      DeflateParams -- Change the compression level and strategy

   SYNOPSIS
      int32 DeflateParams(z_stream * strm, int32 level, int32 strategy);

   FUNCTION
       Dynamically update the compression level and compression strategy.
       The interpretation of level and strategy is as in deflateInit2.
       This can be used to switch between compression and straight copy
       of the input data, or to switch to a different kind of input data
       requiring a different strategy. If the compression level is
       changed, the input available so far is compressed with the old
       level (and may be flushed); the new level will take effect only at
       the next call of deflate().

       Before the call of deflateParams, the stream state must be set as
       for a call of deflate(), since the currently available input may
       have to be compressed and flushed. In particular, strm->avail_out
       must be non-zero.

       deflateParams returns Z_OK if success, Z_STREAM_ERROR if the
       source stream state was inconsistent or if a parameter was
       invalid, Z_BUF_ERROR if strm->avail_out was zero.

   INPUTS
       strm - Pointer to z_stream.
       level - New compression level.
       strategy - New compression strategy.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflatePrime                                                       z.library/DeflatePrime

   NAME
      DeflatePrime -- Insert bits in the deflate output stream

   SYNOPSIS
      int32 DeflatePrime(z_stream * strm, int32 bits, int32 value);

   FUNCTION
       deflatePrime() inserts bits in the deflate output stream. The
       intent is that this function is used to start off the deflate
       output with the bits leftover from a previous deflate stream when
       appending to it. As such, this function can only be used for raw
       deflate, and must be used before the first deflate() call after a
       deflateInit2() or deflateReset(). bits must be less than or equal
       to 16, and that many of the least significant bits of value will
       be inserted in the output.

       deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not
       enough room in the internal buffer to insert the bits, or
       Z_STREAM_ERROR if the source stream state was inconsistent.

   INPUTS
       strm - Pointer to an initialized z_stream.
       bits - Number of bits (must be <= 16).
       value - Bits to insert.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflateReset                                                       z.library/DeflateReset

   NAME
      DeflateReset -- Reset compression stream

   SYNOPSIS
      int32 DeflateReset(z_stream * strm);

   FUNCTION
       This function is equivalent to deflateEnd followed by deflateInit,
       but does not free and reallocate all the internal compression
       state. The stream will keep the same compression level and any
       other attributes that may have been set by deflateInit2.

       deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the
       source stream state was inconsistent (such as zalloc or state
       being NULL).

   INPUTS
       strm - Pointer to a z_stream to reset.

   RESULT
       Z_OK for success or error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/DeflateSetDictionary                                       z.library/DeflateSetDictionary

   NAME
      DeflateSetDictionary -- Set initial dictionary for compression

   SYNOPSIS
      int32 DeflateSetDictionary(z_stream * strm, const uint8 * dictionary, 
          uint32 dictLength);

   FUNCTION
       Initializes the compression dictionary from the given byte
       sequence without producing any compressed output. This function
       must be called immediately after deflateInit, deflateInit2 or
       deflateReset, before any call of deflate. The compressor and
       decompressor must use exactly the same dictionary (see
       inflateSetDictionary). without producing any compressed output.
       When using the zlib format, this function must be called
       immediately after deflateInit, deflateInit2 or deflateReset, and
       before any call of deflate. When doing raw deflate, this function
       must be called either before any call of deflate, or immediately
       after the completion of a deflate block, i.e. after all input has
       been consumed and all output has been delivered when using any of
       the flush options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or
       Z_FULL_FLUSH. The compressor and decompressor must use exactly the
       same dictionary (see inflateSetDictionary).

       The dictionary should consist of strings (byte sequences) that are
       likely to be encountered later in the data to be compressed, with
       the most commonly used strings preferably put towards the end of
       the dictionary. Using a dictionary is most useful when the data to
       be compressed is short and can be predicted with good accuracy;
       the data can then be compressed better than with the default empty
       dictionary.

       Depending on the size of the compression data structures selected
       by deflateInit or deflateInit2, a part of the dictionary may in
       effect be discarded, for example if the dictionary is larger than
       the window size in deflate or deflate2. Thus the strings most
       likely to be useful should be put at the end of the dictionary,
       not at the front. In addition, the current implementation of
       deflate will use at most the window size minus 262 bytes of the
       provided dictionary.

       Upon return of this function, strm->adler is set to the adler32
       value of the dictionary; the decompressor may later use this value
       to determine which dictionary has been used by the compressor.
       (The adler32 value applies to the whole dictionary even if only a
       subset of the dictionary is actually used by the compressor.) If a
       raw deflate was requested, then the adler32 value is not computed
       and strm->adler is not set.

       deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if
       a parameter is invalid (such as NULL dictionary) or the stream
       state is inconsistent (for example if deflate has already been
       called for this stream or if not at a block boundary for raw
       deflate). deflateSetDictionary does not perform any compression:
       this will be done by deflate().

   INPUTS
       strm - Pointer to an initialized z_stream.
       dictionary - Pointer to dictionary data.
       dictLength - Length of dictionary data.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateSetDictionary(), DeflateInit(), DeflateInit2(), Deflate(),
       DeflateEnd()

z.library/DeflateSetHeader                                               z.library/DeflateSetHeader

   NAME
      DeflateSetHeader -- Write gzip header into compression stream

   SYNOPSIS
      int32 DeflateSetHeader(z_stream * strm, gz_header * head);

   FUNCTION
       deflateSetHeader() provides gzip header information for when a
       gzip stream is requested by deflateInit2(). deflateSetHeader() may
       be called after deflateInit2() or deflateReset() and before the
       first call of deflate(). The text, time, os, extra field, name,
       and comment information in the provided gz_header structure are
       written to the gzip header (xflag is ignored — the extra flags are
       set according to the compression level). The caller must assure
       that, if not Z_NULL, name and comment are terminated with a zero
       byte, and that if extra is not Z_NULL, that extra_len bytes are
       available there. If hcrc is true, a gzip header crc is included.
       Note that the current versions of the command-line version of gzip
       (up through version 1.3.x) do not support header crc's, and will
       report that it is a "multi-part gzip file" and give up.

       If deflateSetHeader is not used, the default gzip header has text
       false, the time set to zero, and os set to 255, with no extra,
       name, or comment fields. The gzip header is returned to the
       default state by deflateReset().

       deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the
       source stream state was inconsistent.

   INPUTS
       strm - Pointer to an initialized z_stream.
       head - Gzip header data to write into compression stream.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateGetHeader(), DeflateInit(), DeflateInit2(), Deflate(),
       DeflateEnd()

z.library/DeflateTune                                                         z.library/DeflateTune

   NAME
      DeflateTune -- Fine tune deflate's internal compression parameters

   SYNOPSIS
      int32 DeflateTune(z_stream * strm, int32 good_length, int32 max_lazy, 
          int32 nice_length, int32 max_chain);

   FUNCTION
       Fine tune deflate's internal compression parameters. This should
       only be used by someone who understands the algorithm used by
       zlib's deflate for searching for the best matching string, and
       even then only by the most fanatic optimizer trying to squeeze out
       the last compressed bit for their specific input data. Read the
       deflate.c source code for the meaning of the max_lazy,
       good_length, nice_length, and max_chain parameters.

       deflateTune() can be called after deflateInit() or deflateInit2(),
       and returns Z_OK on success, or Z_STREAM_ERROR for an invalid
       deflate stream.

   INPUTS
       strm - Pointer to z_stream.
       good_length - See "deflate.c".
       max_lazy - See "deflate.c".
       nice_length - See "deflate.c".
       max_chain - See "deflate.c".

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateInit(), DeflateInit2(), Deflate(), DeflateEnd()

z.library/Inflate                                                                 z.library/Inflate

   NAME
      Inflate -- Perform decompression

   SYNOPSIS
      int32 Inflate(z_stream * strm, int32 flush);

   FUNCTION
       inflate decompresses as much data as possible, and stops when the
       input buffer becomes empty or the output buffer becomes full. It
       may introduce some output latency (reading input without producing
       any output) except when forced to flush.

       The detailed semantics are as follows. inflate performs one or
       both of the following actions:

           Decompress more input starting at next_in and update next_in
           and avail_in accordingly. If not all input can be processed
           (because there is not enough room in the output buffer),
           next_in is updated and processing will resume at this point
           for the next call of inflate().

           Provide more output starting at next_out and update next_out
           and avail_out accordingly. inflate() provides as much output
           as possible, until there is no more input data or no more
           space in the output buffer (see below about the flush
           parameter).

       Before the call of inflate(), the application should ensure that
       at least one of the actions is possible, by providing more input
       and/or consuming more output, and updating the next_* and avail_*
       values accordingly. The application can consume the uncompressed
       output when it wants, for example when the output buffer is full
       (avail_out == 0), or after each call of inflate(). If inflate
       returns Z_OK and with zero avail_out, it must be called again
       after making room in the output buffer because there might be more
       output pending.

       The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
       Z_FINISH, Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that
       inflate() flush as much output as possible to the output buffer.
       Z_BLOCK requests that inflate() stop if and when it gets to the
       next deflate block boundary. When decoding the zlib or gzip
       format, this will cause inflate() to return immediately after the
       header and before the first block. When doing a raw inflate,
       inflate() will go ahead and process the first block, and will
       return when it gets to the end of that block, or when it runs out
       of data.

       The Z_BLOCK option assists in appending to or combining deflate
       streams. Also to assist in this, on return inflate() will set
       strm->data_type to the number of unused bits in the last byte
       taken from strm->next_in, plus 64 if inflate() is currently
       decoding the last block in the deflate stream, plus 128 if
       inflate() returned immediately after decoding an end-of-block code
       or decoding the complete header up to just before the first byte
       of the deflate stream. The end-of-block will not be indicated
       until all of the uncompressed data from that block has been
       written to strm->next_out. The number of unused bits may in
       general be greater than seven, except when bit 7 of data_type is
       set, in which case the number of unused bits will be less than
       eight. data_type is set as noted here every time inflate() returns
       for all flush options, and so can be used to determine the amount
       of currently consumed input in bits.

       The Z_TREES option behaves as Z_BLOCK does, but it also returns
       when the end of each deflate block header is reached, before any
       actual data in that block is decoded. This allows the caller to
       determine the length of the deflate block header for later use in
       random access within a deflate block. 256 is added to the value of
       strm->data_type when inflate() returns immediately after reaching
       the end of the deflate block header.

       inflate() should normally be called until it returns Z_STREAM_END
       or an error. However if all decompression is to be performed in a
       single step (a single call of inflate), the parameter flush should
       be set to Z_FINISH. In this case all pending input is processed
       and all pending output is flushed; avail_out must be large enough
       to hold all of the uncompressed data for the operation to
       complete. (The size of the uncompressed data may have been saved
       by the compressor for this purpose.) The use of Z_FINISH is not
       required to perform an inflation in one step. However it may be
       used to inform inflate that a faster approach can be used for the
       single inflate() call. Z_FINISH also informs inflate to not
       maintain a sliding window if the stream completes, which reduces
       inflate's memory footprint. If the stream does not complete,
       either because not all of the stream is provided or not enough
       output space is provided, then a sliding window will be allocated
       and inflate() can be called again to continue the operation as if
       Z_NO_FLUSH had been used.

       In this implementation, inflate() always flushes as much output
       as possible to the output buffer, and always uses the faster
       approach on the first call. So the effects of the flush parameter
       in this implementation are on the return value of inflate() as
       noted below, when inflate() returns early when Z_BLOCK or Z_TREES
       is used, and when inflate() avoids the allocation of memory for a
       sliding window when Z_FINISH is used.

       If a preset dictionary is needed after this call (see
       inflateSetDictionary below), inflate sets strm->adler to the
       Adler-32 checksum of the dictionary chosen by the compressor and
       returns Z_NEED_DICT; otherwise it sets strm->adler to the Adler-32
       checksum of all output produced so far (that is, total_out bytes)
       and returns Z_OK, Z_STREAM_END or an error code as described
       below. At the end of the stream, inflate() checks that its
       computed adler32 checksum is equal to that saved by the compressor
       and returns Z_STREAM_END only if the checksum is correct.

       inflate() will decompress and check either zlib-wrapped or gzip-
       wrapped deflate data. The header type is detected automatically,
       if requested when initializing with inflateInit2(). Any
       information contained in the gzip header is not retained, so
       applications that need that information should instead use raw
       inflate, see inflateInit2() below, or inflateBack() and perform
       their own processing of the gzip header and trailer. When
       processing gzip-wrapped deflate data, strm->adler32 is set to the
       CRC-32 of the output producted so far. The CRC-32 is checked
       against the gzip trailer.

       inflate() returns Z_OK if some progress has been made (more input
       processed or more output produced), Z_STREAM_END if the end of the
       compressed data has been reached and all uncompressed output has
       been produced, Z_NEED_DICT if a preset dictionary is needed at
       this point, Z_DATA_ERROR if the input data was corrupted (input
       stream not conforming to the zlib format or incorrect check
       value), Z_STREAM_ERROR if the stream structure was inconsistent
       (for example if next_in or next_out was NULL), Z_MEM_ERROR if
       there was not enough memory, Z_BUF_ERROR if no progress is
       possible or if there was not enough room in the output buffer when
       Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
       inflate() can be called again with more input and more output
       space to continue decompressing. If Z_DATA_ERROR is returned, the
       application may then call inflateSync() to look for a good
       compression block if a partial recovery of the data is desired.

   INPUTS
       strm - Pointer to an initialized z_stream.
       flush - Wanted flushing behavior.

   RESULT
       Z_OK or Z_STREAM_END for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), InflateEnd()

z.library/InflateBack                                                         z.library/InflateBack

   NAME
      InflateBack -- Perform compression using callbacks

   SYNOPSIS
      int32 InflateBack(z_stream * strm, in_func in, void * in_desc, 
          out_func out, void * out_desc);

   FUNCTION
       inflateBack() does a raw inflate with a single call using a call-
       back interface for input and output. This is potentially more
       efficient than inflate() for file i/o applications, in that it
       avoids copying between the output and the sliding window by simply
       making the window itself the output buffer. inflate() can be
       faster on modern CPUs when used with large buffers. inflateBack()
       trusts the application to not change the output buffer passed by
       the output function, at least until inflateBack() returns.

       inflateBackInit() must be called first to allocate the internal
       state and to initialize the state with the user-provided window
       buffer. inflateBack() may then be used multiple times to inflate a
       complete, raw deflate stream with each call. inflateBackEnd() is
       then called to free the allocated state.

       A raw deflate stream is one with no zlib or gzip header or
       trailer. This routine would normally be used in a utility that
       reads zip or gzip files and writes out uncompressed files. The
       utility would decode the header and process the trailer on its
       own, hence this routine expects only the raw deflate stream to
       decompress. This is different from the normal behavior of
       inflate(), which expects either a zlib or gzip header and trailer
       around the deflate stream.

       inflateBack() uses two subroutines supplied by the caller that are
       then called by inflateBack() for input and output. inflateBack()
       calls those routines until it reads a complete deflate stream and
       writes out all of the uncompressed data, or until it encounters an
       error. The function's parameters and return types are defined
       above in the in_func and out_func typedefs. inflateBack() will
       call in(in_desc, &buf) which should return the number of bytes of
       provided input, and a pointer to that input in buf. If there is no
       input available, in() must return zero—buf is ignored in that case
       —and inflateBack() will return a buffer error. inflateBack() will
       call out(out_desc, buf, len) to write the uncompressed data
       buf[0..len-1]. out() should return zero on success, or non-zero on
       failure. If out() returns non-zero, inflateBack() will return with
       an error. Neither in() nor out() are permitted to change the
       contents of the window provided to inflateBackInit(), which is
       also the buffer that out() uses to write from. The length written
       by out() will be at most the window size. Any non-zero amount of
       input may be provided by in().

       For convenience, inflateBack() can be provided input on the first
       call by setting strm->next_in and strm->avail_in. If that input is
       exhausted, then in() will be called. Therefore strm->next_in must
       be initialized before calling inflateBack(). If strm->next_in is
       Z_NULL, then in() will be called immediately for input. If
       strm->next_in is not Z_NULL, then strm->avail_in must also be
       initialized, and then if strm->avail_in is not zero, input will
       initially be taken from strm->next_in[0 .. strm->avail_in - 1].

       The in_desc and out_desc parameters of inflateBack() is passed as
       the first parameter of in() and out() respectively when they are
       called. These descriptors can be optionally used to pass any
       information that the caller- supplied in() and out() functions
       need to do their job.

       On return, inflateBack() will set strm->next_in and strm->avail_in
       to pass back any unused input that was provided by the last in()
       call. The return values of inflateBack() can be Z_STREAM_END on
       success, Z_BUF_ERROR if in() or out() returned an error,
       Z_DATA_ERROR if there was a format error in the deflate stream (in
       which case strm->msg is set to indicate the nature of the error),
       or Z_STREAM_ERROR if the stream was not properly initialized. In
       the case of Z_BUF_ERROR, an input or output error can be
       distinguished using strm->next_in which will be Z_NULL only if
       in() returned an error. If strm->next_in is not Z_NULL, then the
       Z_BUF_ERROR was due to out() returning non-zero. (in() will always
       be called before out(), so strm->next_in is assured to be defined
       if out() returns non-zero.) Note that inflateBack() cannot return
       Z_OK.

   INPUTS
       strm - Pointer to an initialized z_stream.
       in - Input callback function.
       in_desc - Opaque data pointer that will be passed as the first
           argument to the in() function above.
       out - Output callback function.
       out_desc - Opaque data pointer that will be passed as the first
           argument to the out() function above.

   RESULT
       Z_STREAM_END for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateBackInit(), InflateBackEnd()

z.library/InflateBackEnd                                                   z.library/InflateBackEnd

   NAME
      InflateBackEnd -- Perform cleanup after decompression using
                        callbacks

   SYNOPSIS
      int32 InflateBackEnd(z_stream * strm);

   FUNCTION
       All memory allocated by inflateBackInit() is freed.

       inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the
       stream state was inconsistent.

   INPUTS
       strm - Pointer to a z_stream to clean up after.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateBackInit(), InflateBack()

z.library/InflateBackInit                                                 z.library/InflateBackInit

   NAME
      InflateBackInit -- Initialize a z_stream for decompression using
                         callbacks

   SYNOPSIS
      int32 InflateBackInit(z_stream * strm, int32 windowBits, 
          uint8 * window);

   FUNCTION
       Initialize the internal stream state for decompression using
       inflateBack() calls. The fields zalloc, zfree and opaque in strm
       must be initialized before the call. If zalloc and zfree are
       Z_NULL, then the default library- derived memory allocation
       routines are used. windowBits is the base two logarithm of the
       window size, in the range 8..15. window is a caller supplied
       buffer of that size. Except for special applications where it is
       assured that deflate was used with small window sizes, windowBits
       must be 15 and a 32K byte window must be supplied to be able to
       decompress general deflate streams.

       See inflateBack() for the usage of these routines.

       inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any
       of the parameters are invalid, Z_MEM_ERROR if the internal state
       could not be allocated, or Z_VERSION_ERROR if the version of the
       library does not match the version of the header file.

   INPUTS
       strm - Pointer to a z_stream to initialize.
       windowBits - Window size.
       window - Window buffer.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateBack(), InflateBackEnd()

z.library/InflateCopy                                                         z.library/InflateCopy

   NAME
      InflateCopy -- Duplicate a decompression stream

   SYNOPSIS
      int32 InflateCopy(z_stream * dest, z_stream * source);

   FUNCTION
       Sets the destination stream as a complete copy of the source
       stream.

       This function can be useful when randomly accessing a large
       stream. The first pass through the stream can periodically record
       the inflate state, allowing restarting inflate at those points
       when randomly accessing the stream.

       inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_STREAM_ERROR if the source stream state was
       inconsistent (such as zalloc being NULL). msg is left unchanged in
       both source and destination.

   INPUTS
       dest - Pointer to z_stream to store copy in.
       source - Pointer to z_stream to copy.

   RESULT
       Z_OK for success or error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd()

z.library/InflateEnd                                                           z.library/InflateEnd

   NAME
      InflateEnd -- Perform cleanup after decompression

   SYNOPSIS
      int32 InflateEnd(z_stream * strm);

   FUNCTION
       All dynamically allocated data structures for this stream are
       freed. This function discards any unprocessed input and does not
       flush any pending output.

       inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream
       state was inconsistent. In the error case, msg may be set but then
       points to a static string (which must not be deallocated).

   INPUTS
       strm - Pointer to a z_stream to clean up after.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate()

z.library/InflateGetDictionary                                       z.library/InflateGetDictionary

   NAME
      InflateGetDictionary -- Request current state of dictionary (V53.4)

   SYNOPSIS
      int32 InflateGetDictionary(z_stream * strm, uint8 * dictionary, 
          uint32 * dictLength);

   FUNCTION
       Returns the sliding dictionary being maintained by inflate.
       dictLength is set to the number of bytes in the dictionary, and
       that many bytes are copied to dictionary. dictionary must have
       enough space, where 32768 bytes is always enough. If inflateGet-
       Dictionary() is called with dictionary equal to Z_NULL, then only
       the dictionary length is returned, and nothing is copied.
       Similary, if dictLength is Z_NULL, then it is not set.

       inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if
       the stream state is inconsistent.

   INPUTS
       strm - Pointer to an initialized z_stream.
       dictionary - Buffer to store the dictionary data in.
       dictLength - Length of buffer and the read dictionary length is
           stored here.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

z.library/InflateGetHeader                                               z.library/InflateGetHeader

   NAME
      InflateGetHeader -- Read gzip header from decompression stream

   SYNOPSIS
      int32 InflateGetHeader(z_stream * strm, gz_header * head);

   FUNCTION
       inflateGetHeader() requests that gzip header information be stored
       in the provided gz_header structure. inflateGetHeader() may be
       called after inflateInit2() or inflateReset(), and before the
       first call of inflate(). As inflate() processes the gzip stream,
       head->done is zero until the header is completed, at which time
       head->done is set to one. If a zlib stream is being decoded, then
       head->done is set to –1 to indicate that there will be no gzip
       header information forthcoming. Note that Z_BLOCK can be used to
       force inflate() to return immediately after header processing is
       complete and before any actual data is decompressed.

       The text, time, xflags, and os fields are filled in with the gzip
       header contents. hcrc is set to true if there is a header CRC.
       (The header CRC was valid if done is set to one.) If extra is not
       Z_NULL, then extra_max contains the maximum number of bytes to
       write to extra. Once done is true, extra_len contains the actual
       extra field length, and extra contains the extra field, or that
       field truncated if extra_max is less than extra_len. If name is
       not Z_NULL, then up to name_max characters are written there,
       terminated with a zero unless the length is greater than name_max.
       If comment is not Z_NULL, then up to comm_max characters are
       written there, terminated with a zero unless the length is greater
       than comm_max. When any of extra, name, or comment are not Z_NULL
       and the respective field is not present in the header, then that
       field is set to Z_NULL to signal its absence. This allows the use
       of deflateSetHeader() with the returned structure to duplicate the
       header. However if those fields are set to allocated memory, then
       the application will need to save those pointers elsewhere so that
       they can be eventually freed.

       If inflateGetHeader is not used, then the header information is
       simply discarded. The header is always checked for validity,
       including the header CRC if present. inflateReset() will reset the
       process to discard the header information. The application would
       need to call inflateGetHeader() again to retrieve the header from
       the next gzip stream.

       inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the
       source stream state was inconsistent.

   INPUTS
       strm - Pointer to an initialized z_stream.
       head - Gzip header data will be read into here.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       DeflateSetHeader(), InflateInit(), InflateInit2(), Inflate(),
       InflateEnd()

z.library/InflateInit                                                         z.library/InflateInit

   NAME
      InflateInit -- Initialize a z_stream for decompression

   SYNOPSIS
      int32 InflateInit(z_stream * strm);

   FUNCTION
       Initializes the internal stream state for decompression. The
       fields next_in, avail_in, zalloc, zfree and opaque must be
       initialized before by the caller. If next_in is not Z_NULL and
       avail_in is large enough (the exact value depends on the
       compression method), inflateInit determines the compression method
       from the zlib header and allocates all data structures
       accordingly; otherwise the allocation will be deferred to the
       first call of inflate. If zalloc and zfree are set to Z_NULL,
       inflateInit updates them to use default allocation functions.

       inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_VERSION_ERROR if the zlib library version is
       incompatible with the version assumed by the caller, or
       Z_STREAM_ERROR if the parameters are invalid, such as a null
       pointer to the structure. msg is set to null if there is no error
       message. inflateInit does not perform any decompression apart from
       possibly reading the zlib header if present: actual decompression
       will be done by inflate(). (So next_in and avail_in may be
       modified, but next_out and avail_out are unused and unchanged.)
       The current implementation of inflateInit() does not process any
       header information -- that is deferred until inflate() is called.

   INPUTS
       strm - Pointer to a z_stream to initialize.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit2(), Inflate(), InflateEnd()

z.library/InflateInit2                                                       z.library/InflateInit2

   NAME
      InflateInit2 -- Initialize a z_stream for decompression

   SYNOPSIS
      int32 InflateInit2(z_stream * strm, int32 windowBits);

   FUNCTION
       This is another version of inflateInit with an extra parameter.
       The fields next_in, avail_in, zalloc, zfree and opaque must be
       initialized before by the caller.

       The windowBits parameter is the base two logarithm of the maximum
       window size (the size of the history buffer). It should be in the
       range 8..15 for this version of the library. The default value is
       15 if inflateInit is used instead. windowBits must be greater than
       or equal to the windowBits value provided to deflateInit2() while
       compressing, or it must be equal to 15 if deflateInit2() was not
       used. If a compressed stream with a larger window size is given as
       input, inflate() will return with the error code Z_DATA_ERROR
       instead of trying to allocate a larger window.

       windowBits can also be zero to request that inflate use the window
       size in the zlib header of the compressed stream.

       windowBits can also be –8..–15 for raw inflate. In this case,
       -windowBits determines the window size. inflate() will then
       process raw deflate data, not looking for a zlib or gzip header,
       not generating a check value, and not looking for any check values
       for comparison at the end of the stream. This is for use with
       other formats that use the deflate compressed data format such as
       zip. Those formats provide their own check values. If a custom
       format is developed using the raw deflate format for compressed
       data, it is recommended that a check value such as an adler32 or a
       crc32 be applied to the uncompressed data as is done in the zlib,
       gzip, and zip formats. For most applications, the zlib format
       should be used as is. Note that comments above on the use in
       deflateInit2() applies to the magnitude of windowBits.

       windowBits can also be greater than 15 for optional gzip decoding.
       Add 32 to windowBits to enable zlib and gzip decoding with
       automatic header detection, or add 16 to decode only the gzip
       format (the zlib format will return a Z_DATA_ERROR). If a gzip
       stream is being decoded, strm->adler is a crc32 instead of an
       adler32.

       inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_VERSION_ERROR if the zlib library version is
       incompatible with the version assumed by the caller,
       Z_STREAM_ERROR if a parameters are invalid, such as a null pointer
       to the structure. msg is set to null if there is no error message.
       inflateInit2 does not perform any decompression apart from reading
       the zlib header if present: actual decompression be done by
       inflate(). (So next_in and avail_in may be modified, but next_out
       and avail_out are unused and unchanged.) The current
       implementation of inflateInit2() does not process any header
       information -- that is deferred until inflate() is called.

   INPUTS
       strm - Pointer to a z_stream to initialize.
       windowBits - Window size.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), Inflate(), InflateEnd()

z.library/InflatePrime                                                       z.library/InflatePrime

   NAME
      InflatePrime -- Insert bits in the inflate input stream

   SYNOPSIS
      int32 InflatePrime(z_stream * strm, int32 bits, int32 value);

   FUNCTION
       This function inserts bits in the inflate input stream. The intent
       is that this function is used to start inflating at a bit position
       in the middle of a byte. The provided bits will be used before any
       bytes are used from next_in. This function should only be used
       with raw inflate, and should be used before the first inflate()
       call after inflateInit2() or inflateReset(). bits must be less
       than or equal to 16, and that many of the least significant bits
       of value will be inserted in the input.

       If bits is negative, then the input stream bit buffer is emptied.
       Then inflatePrime() can be called again to put bits in the buffer.
       This is used to clear out bits leftover after feeding inflate a
       block description prior to feeding inflate codes.

       inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the
       source stream state was inconsistent.

   INPUTS
       strm - Pointer to an initialized z_stream.
       bits - Number of bits (must be <= 16).
       value - Bits to insert.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd()

z.library/InflateReset                                                       z.library/InflateReset

   NAME
      InflateReset -- Reset decompression stream

   SYNOPSIS
      int32 InflateReset(z_stream * strm);

   FUNCTION
       This function is equivalent to inflateEnd followed by inflateInit,
       but does not free and reallocate all the internal decompression
       state. The stream will keep attributes that may have been set by
       inflateInit2.

       inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the
       source stream state was inconsistent (such as zalloc or state
       being NULL).

   INPUTS
       strm - Pointer to a z_stream to reset.

   RESULT
       Z_OK for success or error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd()

z.library/InflateReset2                                                     z.library/InflateReset2

   NAME
      InflateReset2 -- Reset decompression stream.

   SYNOPSIS
      int32 InflateReset2(z_stream * strm, int32 windowBits);

   FUNCTION
      This function is the same as inflateReset, but it also permits 
      changing  the wrap and window size requests.  The windowBits parameter
      is interpreted  the same as it is for inflateInit2.  If the window 
      size is changed, then the  memory allocated for the window is freed,
      and the window will be reallocated   by inflate() if needed.

      InflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
      stream state was inconsistent (such as zalloc or state being Z_NULL), 
      or if  the windowBits parameter is invalid.

   INPUTS
       strm - Pointer to a z_stream to reset.
       windowBits - Window size.

   RESULT
       Z_OK for success or error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd() InflateReset()

z.library/InflateSetDictionary                                       z.library/InflateSetDictionary

   NAME
      InflateSetDictionary -- Set initial dictionary for decompression

   SYNOPSIS
      int32 InflateSetDictionary(z_stream * strm, const uint8 * dictionary, 
          uint32 dictLength);

   FUNCTION
       Initializes the decompression dictionary from the given
       uncompressed byte sequence. This function must be called
       immediately after a call of inflate, if that call returned
       Z_NEED_DICT. The dictionary chosen by the compressor can be
       determined from the adler32 value returned by that call of
       inflate. The compressor and decompressor must use exactly the same
       dictionary (see deflateSetDictionary). For raw inflate, this
       function can be called at any time to set the dictionary. If the
       provided dictionary is smaller than the window and there is
       already data in the window, then the provided dictionary will
       amend what's there. The application must insure that the
       dictionary that was used for compression is provided.

       inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
       parameter is invalid (such as NULL dictionary) or the stream state
       is inconsistent, Z_DATA_ERROR if the given dictionary doesn't
       match the expected one (incorrect adler32 value). inflateSet-
       Dictionary does not perform any decompression: this will be done
       by subsequent calls of inflate().

   INPUTS
       strm - Pointer to an initialized z_stream.
       dictionary - Pointer to dictionary data.
       dictLength - Length of dictionary data.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd()

z.library/InflateSync                                                         z.library/InflateSync

   NAME
      InflateSync -- Search for a possible full flush point

   SYNOPSIS
      int32 InflateSync(z_stream * strm);

   FUNCTION
       Skips invalid compressed data until a possible full flush point
       (see above for the description of deflate with Z_FULL_FLUSH) can
       be found, or until all available input is skipped. No output is
       provided.

       inflateSync searches for a 00 00 FF FF pattern in the compressed
       data. All full flush points have this pattern, but not all
       occurrences of this pattern are full flush points.

       inflateSync returns Z_OK if a possible full flush point has been
       found, Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if
       no flush point has been found, or Z_STREAM_ERROR if the stream
       structure was inconsistent. In the success case, the application
       may save the current current value of total_in which indicates
       where valid compressed data was found. In the error case, the
       application may repeatedly call inflateSync, providing more input
       each time, until success or end of the input data.

   INPUTS
       strm - Pointer to an initialized z_stream.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO
       InflateInit(), InflateInit2(), Inflate(), InflateEnd()

z.library/Uncompress                                                           z.library/Uncompress

   NAME
      Uncompress -- Decompress from source to destination buffer

   SYNOPSIS
      int32 Uncompress(APTR dest, uint32 * destLen, CONST_APTR source, 
          uint32 sourceLen);

   FUNCTION
       Decompresses the source buffer into the destination buffer.
       sourceLen is the byte length of the source buffer. Upon entry,
       destLen is the total size of the destination buffer, which must be
       large enough to hold the entire uncompressed data. (The size of
       the uncompressed data must have been saved previously by the
       compressor and transmitted to the decompressor by some mechanism
       outside the scope of this compression library.) Upon exit, destLen
       is the actual size of the compressed buffer.

       uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
       enough memory, Z_BUF_ERROR if there was not enough room in the
       output buffer, or Z_DATA_ERROR if the input data was corrupted or
       incomplete. In the case where there is not enough room,
       uncompress() will fill the output buffer with the uncompressed
       data up to that point.

   INPUTS
       dest - Destination buffer.
       destLen - Length of destination buffer.
       source - Source buffer.
       sourceLen - Length of source buffer.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

z.library/Uncompress2                                                         z.library/Uncompress2

   NAME
      Uncompress2 -- Decompress from source to destination buffer

   SYNOPSIS
      int32 Uncompress2(APTR dest, uint32 * destLen, CONST_APTR source, 
          uint32 * sourceLen);

   FUNCTION
       Same as uncompress, except that sourceLen is a pointer, where the
       length of the source is *sourceLen.  On return, *sourceLen is the
       number of source bytes consumed.

   INPUTS
       dest - Destination buffer.
       destLen - Length of destination buffer.
       source - Source buffer.
       sourceLen - Length of source buffer.

   RESULT
       Z_OK for success or an error code for failure.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

z.library/ZlibVersion                                                         z.library/ZlibVersion

   NAME
      ZlibVersion -- Get the zlib version as a string

   SYNOPSIS
      CONST_STRPTR ZlibVersion(void);

   FUNCTION
       The application can compare zlibVersion and ZLIB_VERSION for
       consistency. If the first character differs, the library code
       actually used is not compatible with the zlib.h header file used
       by the application. This check is automatically made by deflateInit
       and inflateInit.

   INPUTS

   RESULT
       Version string in the form "x.y.z" where x is the version number
       and y and z are the major and minor revisons.

   EXAMPLE

   NOTES

   BUGS

   SEE ALSO

